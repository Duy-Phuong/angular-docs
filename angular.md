MUC LUC
https://www.academind.com/learn/javascript/understanding-rxjs/  
http://phocode.com/javascript/  
https://freetuts.net/template-trong-angular-4-1330.html  
xuanthulap.com  
https://www.youtube.com/channel/UCSJbGtTlrDami-tDGPUV9-w/playlists  
 acdemind.com

C:\Users\phuong\AppData\Local\Programs\Python\Python37\python.exe D:/Source/Source_All/python/Test/readfile.py  
======== name dir ========

---

- [Angular 8 (formerly Angular 2) - The Complete Guide](#angular-8-formerly-angular-2---the-complete-guide)
  - [1. Getting Started](#1-getting-started)
    - [1. Course Introduction](#1-course-introduction)
    - [2. What is Angular](#2-what-is-angular)
    - [3. Angular vs Angular 2 vs Angular 8](#3-angular-vs-angular-2-vs-angular-8)
    - [4. CLI Deep Dive & Troubleshooting.html](#4-cli-deep-dive--troubleshootinghtml)
    - [5. Project Setup and First App](#5-project-setup-and-first-app)
    - [6. Editing the First App](#6-editing-the-first-app)
    - [7. The Course Structure](#7-the-course-structure)
    - [9. What is TypeScript](#9-what-is-typescript)
    - [10. A Basic Project Setup using Bootstrap for Styling](#10-a-basic-project-setup-using-bootstrap-for-styling)
    - [11. Where to find the Course Source Code.html](#11-where-to-find-the-course-source-codehtml)
  - [2. The Basics](#2-the-basics)
    - [1. Module Introduction](#1-module-introduction)
    - [2. How an Angular App gets Loaded and Started](#2-how-an-angular-app-gets-loaded-and-started)
    - [4. Creating a New Component](#4-creating-a-new-component)
    - [5. Understanding the Role of AppModule and Component Declaration](#5-understanding-the-role-of-appmodule-and-component-declaration)
    - [6. Using Custom Components](#6-using-custom-components)
    - [7. Creating Components with the CLI & Nesting Components](#7-creating-components-with-the-cli--nesting-components)
    - [8. Working with Component Templates](#8-working-with-component-templates)
    - [9. Working with Component Styles](#9-working-with-component-styles)
    - [10. Fully Understanding the Component Selector](#10-fully-understanding-the-component-selector)
    - [11. Practicing Components.html](#11-practicing-componentshtml)
    - [12. [OPTIONAL] Assignment Solution](#12-optional-assignment-solution)
    - [13. What is Databinding](#13-what-is-databinding)
    - [14. String Interpolation](#14-string-interpolation)
    - [15. Property Binding](#15-property-binding)
    - [16. Property Binding vs String Interpolation](#16-property-binding-vs-string-interpolation)
    - [17. Event Binding](#17-event-binding)
    - [18. Bindable Properties and Events.html](#18-bindable-properties-and-eventshtml)
    - [19. Passing and Using Data with Event Binding](#19-passing-and-using-data-with-event-binding)
    - [20. Important FormsModule is Required for Two-Way-Binding!.html](#20-important-formsmodule-is-required-for-two-way-bindinghtml)
    - [21. Two-Way-Databinding](#21-two-way-databinding)
    - [22. Combining all Forms of Databinding](#22-combining-all-forms-of-databinding)
    - [23. Practicing Databinding.html](#23-practicing-databindinghtml)
    - [24. [OPTIONAL] Assignment Solution](#24-optional-assignment-solution)
    - [25. Understanding Directives](#25-understanding-directives)
    - [26. Using ngIf to Output Data Conditionally](#26-using-ngif-to-output-data-conditionally)
    - [27. Enhancing ngIf with an Else Condition](#27-enhancing-ngif-with-an-else-condition)
    - [28. Styling Elements Dynamically with ngStyle](#28-styling-elements-dynamically-with-ngstyle)
    - [29. Applying CSS Classes Dynamically with ngClass](#29-applying-css-classes-dynamically-with-ngclass)
    - [30. Outputting Lists with ngFor](#30-outputting-lists-with-ngfor)
    - [31. Practicing Directives.html](#31-practicing-directiveshtml)
    - [32. [OPTIONAL] Assignment Solution](#32-optional-assignment-solution)
    - [33. Getting the Index when using ngFor](#33-getting-the-index-when-using-ngfor)
  - [3. Course Project - The Basics](#3-course-project---the-basics)
    - [1. Project Introduction](#1-project-introduction)
    - [2. Planning the App](#2-planning-the-app)
    - [3. Installing Bootstrap Correctly.html](#3-installing-bootstrap-correctlyhtml)
    - [4. Setting up the Application](#4-setting-up-the-application)
    - [5. Creating the Components](#5-creating-the-components)
    - [6. Using the Components](#6-using-the-components)
    - [7. Adding a Navigation Bar](#7-adding-a-navigation-bar)
    - [8. Alternative Non-Collapsable Navigation Bar.html](#8-alternative-non-collapsable-navigation-barhtml)
    - [9. Creating a Recipe Model](#9-creating-a-recipe-model)
    - [10. Adding Content to the Recipes Components](#10-adding-content-to-the-recipes-components)
    - [11. Outputting a List of Recipes with ngFor](#11-outputting-a-list-of-recipes-with-ngfor)
    - [12. Displaying Recipe Details](#12-displaying-recipe-details)
    - [13. Working on the ShoppingListComponent](#13-working-on-the-shoppinglistcomponent)
    - [14. Creating an Ingredient Model](#14-creating-an-ingredient-model)
    - [15. Creating and Outputting the Shopping List](#15-creating-and-outputting-the-shopping-list)
    - [16. Adding a Shopping List Edit Section](#16-adding-a-shopping-list-edit-section)
    - [17. Wrap Up & Next Steps](#17-wrap-up--next-steps)
  - [4. Debugging](#4-debugging)
    - [1. Understanding Angular Error Messages](#1-understanding-angular-error-messages)
    - [2. Debugging Code in the Browser Using Sourcemaps](#2-debugging-code-in-the-browser-using-sourcemaps)
    - [3. Using Augury to Dive into Angular Apps](#3-using-augury-to-dive-into-angular-apps)
  - [5. Components & Databinding Deep Dive](#5-components--databinding-deep-dive)
    - [1. Module Introduction](#1-module-introduction-1)
    - [2. Splitting Apps into Components](#2-splitting-apps-into-components)
    - [3. Property & Event Binding Overview](#3-property--event-binding-overview)
    - [4. Binding to Custom Properties: @Input](#4-binding-to-custom-properties-input)
    - [5. Assigning an Alias to Custom Properties](#5-assigning-an-alias-to-custom-properties)
    - [6. Binding to Custom Events](#6-binding-to-custom-events)
    - [7. Assigning an Alias to Custom Events](#7-assigning-an-alias-to-custom-events)
    - [8. Custom Property and Event Binding Summary](#8-custom-property-and-event-binding-summary)
    - [9. Understanding View Encapsulation](#9-understanding-view-encapsulation)
    - [10. More on View Encapsulation](#10-more-on-view-encapsulation)
    - [11. Using Local References in Templates](#11-using-local-references-in-templates)
    - [12. @ViewChild() in Angular 8.html](#12-viewchild-in-angular-8html)
    - [13. Getting Access to the Template & DOM with @ViewChild](#13-getting-access-to-the-template--dom-with-viewchild)
    - [14. Projecting Content into Components with ng-content](#14-projecting-content-into-components-with-ng-content)
    - [15. Understanding the Component Lifecycle](#15-understanding-the-component-lifecycle)
    - [16. Seeing Lifecycle Hooks in Action](#16-seeing-lifecycle-hooks-in-action)
    - [17. Lifecycle Hooks and Template Access](#17-lifecycle-hooks-and-template-access)
    - [18. @ContentChild() in Angular 8.html](#18-contentchild-in-angular-8html)
    - [19. Getting Access to ng-content with @ContentChild](#19-getting-access-to-ng-content-with-contentchild)
    - [20. Wrap Up](#20-wrap-up)
    - [21. Practicing Property & Event Binding and View Encapsulation.html](#21-practicing-property--event-binding-and-view-encapsulationhtml)
    - [22. [OPTIONAL] Assignment Solution](#22-optional-assignment-solution)
  - [6. Course Project - Components & Databinding](#6-course-project---components--databinding)
    - [1. Introduction](#1-introduction)
    - [2. Adding Navigation with Event Binding and ngIf](#2-adding-navigation-with-event-binding-and-ngif)
    - [3. Passing Recipe Data with Property Binding](#3-passing-recipe-data-with-property-binding)
    - [4. Passing Data with Event and Property Binding (Combined)](#4-passing-data-with-event-and-property-binding-combined)
    - [5. Make sure you have FormsModule added!.html](#5-make-sure-you-have-formsmodule-addedhtml)
    - [6. Allowing the User to Add Ingredients to the Shopping List](#6-allowing-the-user-to-add-ingredients-to-the-shopping-list)
  - [7. Directives Deep Dive](#7-directives-deep-dive)
    - [1. Module Introduction](#1-module-introduction-2)
    - [2. ngFor and ngIf Recap](#2-ngfor-and-ngif-recap)
    - [3. ngClass and ngStyle Recap](#3-ngclass-and-ngstyle-recap)
    - [4. Creating a Basic Attribute Directive](#4-creating-a-basic-attribute-directive)
    - [5. Using the Renderer to build a Better Attribute Directive](#5-using-the-renderer-to-build-a-better-attribute-directive)
    - [6. More about the Renderer.html](#6-more-about-the-rendererhtml)
    - [7. Using HostListener to Listen to Host Events](#7-using-hostlistener-to-listen-to-host-events)
    - [8. Using HostBinding to Bind to Host Properties](#8-using-hostbinding-to-bind-to-host-properties)
    - [9. Binding to Directive Properties](#9-binding-to-directive-properties)
    - [10. What Happens behind the Scenes on Structural Directives](#10-what-happens-behind-the-scenes-on-structural-directives)
    - [11. Building a Structural Directive](#11-building-a-structural-directive)
    - [12. Understanding ngSwitch](#12-understanding-ngswitch)
  - [8. Course Project - Directives](#8-course-project---directives)
    - [1. Building and Using a Dropdown Directive](#1-building-and-using-a-dropdown-directive)
    - [2. Closing the Dropdown From Anywhere.html](#2-closing-the-dropdown-from-anywherehtml)
  - [9. Using Services & Dependency Injection](#9-using-services--dependency-injection)
    - [1. Module Introduction](#1-module-introduction-3)
    - [2. Why would you Need Services](#2-why-would-you-need-services)
    - [3. Creating a Logging Service](#3-creating-a-logging-service)
    - [4. Injecting the Logging Service into Components](#4-injecting-the-logging-service-into-components)
    - [5. Creating a Data Service](#5-creating-a-data-service)
    - [6. Understanding the Hierarchical Injector](#6-understanding-the-hierarchical-injector)
    - [7. How many Instances of Service Should It Be](#7-how-many-instances-of-service-should-it-be)
    - [8. Injecting Services into Services](#8-injecting-services-into-services)
    - [9. Using Services for Cross-Component Communication](#9-using-services-for-cross-component-communication)
    - [10. Practicing Services.html](#10-practicing-serviceshtml)
    - [11. [OPTIONAL] Assignment Solution](#11-optional-assignment-solution)
    - [12. Services in Angular 6+.html](#12-services-in-angular-6html)
  - [10. Course Project - Services & Dependency Injection](#10-course-project---services--dependency-injection)
    - [1. Introduction](#1-introduction-1)
    - [2. Setting up the Services](#2-setting-up-the-services)
    - [3. Managing Recipes in a Recipe Service](#3-managing-recipes-in-a-recipe-service)
    - [4. Using a Service for Cross-Component Communication](#4-using-a-service-for-cross-component-communication)
    - [5. Adding the Shopping List Service](#5-adding-the-shopping-list-service)
    - [6. Using Services for Pushing Data from A to B](#6-using-services-for-pushing-data-from-a-to-b)
    - [7. Adding Ingredients to Recipes](#7-adding-ingredients-to-recipes)
    - [8. Passing Ingredients from Recipes to the Shopping List (via a Service)](#8-passing-ingredients-from-recipes-to-the-shopping-list-via-a-service)
  - [11. Changing Pages with Routing](#11-changing-pages-with-routing)
    - [1. Module Introduction](#1-module-introduction-4)
    - [3. Understanding the Example Project.html](#3-understanding-the-example-projecthtml)
    - [4. Setting up and Loading Routes](#4-setting-up-and-loading-routes)
    - [5. Navigating with Router Links](#5-navigating-with-router-links)
    - [6. Understanding Navigation Paths](#6-understanding-navigation-paths)
    - [7. Styling Active Router Links](#7-styling-active-router-links)
    - [8. Navigating Programmatically](#8-navigating-programmatically)
    - [9. Using Relative Paths in Programmatic Navigation](#9-using-relative-paths-in-programmatic-navigation)
    - [10. Passing Parameters to Routes](#10-passing-parameters-to-routes)
    - [11. Fetching Route Parameters](#11-fetching-route-parameters)
    - [12. Fetching Route Parameters Reactively](#12-fetching-route-parameters-reactively)
    - [13. An Important Note about Route Observables](#13-an-important-note-about-route-observables)
    - [14. Passing Query Parameters and Fragments](#14-passing-query-parameters-and-fragments)
    - [15. Retrieving Query Parameters and Fragments](#15-retrieving-query-parameters-and-fragments)
    - [16. Practicing and some Common Gotchas](#16-practicing-and-some-common-gotchas)
    - [17. Setting up Child (Nested) Routes](#17-setting-up-child-nested-routes)
    - [18. Using Query Parameters - Practice](#18-using-query-parameters---practice)
    - [19. Configuring the Handling of Query Parameters](#19-configuring-the-handling-of-query-parameters)
    - [20. Redirecting and Wildcard Routes](#20-redirecting-and-wildcard-routes)
    - [21. Important Redirection Path Matching.html](#21-important-redirection-path-matchinghtml)
    - [22. Outsourcing the Route Configuration](#22-outsourcing-the-route-configuration)
    - [23. An Introduction to Guards](#23-an-introduction-to-guards)
    - [24. Protecting Routes with canActivate](#24-protecting-routes-with-canactivate)
    - [25. Protecting Child (Nested) Routes with canActivateChild](#25-protecting-child-nested-routes-with-canactivatechild)
    - [26. Using a Fake Auth Service](#26-using-a-fake-auth-service)
    - [27. Controlling Navigation with canDeactivate](#27-controlling-navigation-with-candeactivate)
    - [28. Passing Static Data to a Route](#28-passing-static-data-to-a-route)
    - [29. Resolving Dynamic Data with the resolve Guard](#29-resolving-dynamic-data-with-the-resolve-guard)
    - [30. Understanding Location Strategies](#30-understanding-location-strategies)
    - [31. Wrap Up](#31-wrap-up)
  - [12. Course Project - Routing](#12-course-project---routing)
    - [1. Planning the General Structure](#1-planning-the-general-structure)
    - [2. Setting Up Routes](#2-setting-up-routes)
    - [3. Adding Navigation to the App](#3-adding-navigation-to-the-app)
    - [4. Marking Active Routes](#4-marking-active-routes)
    - [5. Fixing Page Reload Issues](#5-fixing-page-reload-issues)
    - [6. Child Routes Challenge](#6-child-routes-challenge)
    - [7. Adding Child Routing Together](#7-adding-child-routing-together)
    - [8. Configuring Route Paramieters](#8-configuring-route-paramieters)
    - [9. Passing Dynamic Parameters to Links](#9-passing-dynamic-parameters-to-links)
    - [10. Styling Active Recipe Items](#10-styling-active-recipe-items)
    - [11. Adding Editing Routes](#11-adding-editing-routes)
    - [12. Retrieving Route Parameters](#12-retrieving-route-parameters)
    - [13. Programmatic Navigation to the Edit Page](#13-programmatic-navigation-to-the-edit-page)
    - [14. One Note about Route Observables](#14-one-note-about-route-observables)
    - [15. Project Cleanup.html](#15-project-cleanuphtml)
  - [13. Understanding Observables](#13-understanding-observables)
    - [1. Module Introduction](#1-module-introduction-5)
    - [2. Analyzing Angular Observables](#2-analyzing-angular-observables)
    - [3. Getting Closer to the Core of Observables](#3-getting-closer-to-the-core-of-observables)
    - [4. Building a Custom Observable](#4-building-a-custom-observable)
    - [5. Errors & Completion](#5-errors--completion)
    - [6. Observables & You!](#6-observables--you)
    - [7. Understanding Operators](#7-understanding-operators)
    - [8. Subjects](#8-subjects)
    - [9. Wrap Up](#9-wrap-up)
    - [10. Useful Resources & Links.html](#10-useful-resources--linkshtml)
  - [14. Course Project - Observables](#14-course-project---observables)
    - [1. Improving the Reactive Service with Observables (Subjects)](#1-improving-the-reactive-service-with-observables-subjects)
    - [2. Changed the Subscription Name.html](#2-changed-the-subscription-namehtml)
  - [15. Handling Forms in Angular Apps](#15-handling-forms-in-angular-apps)
    - [1. Module Introduction](#1-module-introduction-6)
    - [2. Why do we Need Angular's Help](#2-why-do-we-need-angulars-help)
    - [3. Template-Driven (TD) vs Reactive Approach](#3-template-driven-td-vs-reactive-approach)
    - [4. An Example Form](#4-an-example-form)
    - [5. TD Creating the Form and Registering the Controls](#5-td-creating-the-form-and-registering-the-controls)
    - [6. TD Submitting and Using the Form](#6-td-submitting-and-using-the-form)
    - [7. TD Understanding Form State](#7-td-understanding-form-state)
    - [8. TD Accessing the Form with @ViewChild](#8-td-accessing-the-form-with-viewchild)
    - [9. TD Adding Validation to check User Input](#9-td-adding-validation-to-check-user-input)
    - [10. Built-in Validators & Using HTML5 Validation.html](#10-built-in-validators--using-html5-validationhtml)
    - [11. TD Using the Form State](#11-td-using-the-form-state)
    - [12. TD Outputting Validation Error Messages](#12-td-outputting-validation-error-messages)
    - [13. TD Set Default Values with ngModel Property Binding](#13-td-set-default-values-with-ngmodel-property-binding)
    - [14. TD Using ngModel with Two-Way-Binding](#14-td-using-ngmodel-with-two-way-binding)
    - [15. TD Grouping Form Controls](#15-td-grouping-form-controls)
    - [16. TD Handling Radio Buttons](#16-td-handling-radio-buttons)
    - [17. TD Setting and Patching Form Values](#17-td-setting-and-patching-form-values)
    - [18. TD Using Form Data](#18-td-using-form-data)
    - [19. TD Resetting Forms](#19-td-resetting-forms)
    - [20. Practicing Template-Driven Forms.html](#20-practicing-template-driven-formshtml)
    - [21. Introduction to the Reactive Approach](#21-introduction-to-the-reactive-approach)
    - [22. Reactive Setup](#22-reactive-setup)
    - [23. Reactive Creating a Form in Code](#23-reactive-creating-a-form-in-code)
    - [24. Reactive Syncing HTML and Form](#24-reactive-syncing-html-and-form)
    - [25. Reactive Submitting the Form](#25-reactive-submitting-the-form)
    - [26. Reactive Adding Validation](#26-reactive-adding-validation)
    - [27. Reactive Getting Access to Controls](#27-reactive-getting-access-to-controls)
    - [28. Reactive Grouping Controls](#28-reactive-grouping-controls)
    - [Fixing a Bug](#fixing-a-bug)
    - [29. Reactive Arrays of Form Controls (FormArray)](#29-reactive-arrays-of-form-controls-formarray)
    - [30. Reactive Creating Custom Validators](#30-reactive-creating-custom-validators)
    - [31. Reactive Using Error Codes](#31-reactive-using-error-codes)
    - [32. Reactive Creating a Custom Async Validator](#32-reactive-creating-a-custom-async-validator)
    - [33. Reactive Reacting to Status or Value Changes](#33-reactive-reacting-to-status-or-value-changes)
    - [34. Reactive Setting and Patching Values](#34-reactive-setting-and-patching-values)
    - [35. Practicing Reactive Forms.html](#35-practicing-reactive-formshtml)
    - [36. [OPTIONAL] Assignment Solution](#36-optional-assignment-solution)
  - [16. Course Project - Forms](#16-course-project---forms)
    - [1. Introduction](#1-introduction-2)
    - [2. TD Adding the Shopping List Form](#2-td-adding-the-shopping-list-form)
    - [3. Adding Validation to the Form](#3-adding-validation-to-the-form)
    - [4. Allowing the Selection of Items in the List](#4-allowing-the-selection-of-items-in-the-list)
    - [5. Loading the Shopping List Items into the Form](#5-loading-the-shopping-list-items-into-the-form)
    - [6. Updating existing Items](#6-updating-existing-items)
    - [7. Resetting the Form](#7-resetting-the-form)
    - [8. Allowing the the User to Clear (Cancel) the Form](#8-allowing-the-the-user-to-clear-cancel-the-form)
    - [9. Allowing the Deletion of Shopping List Items](#9-allowing-the-deletion-of-shopping-list-items)
    - [10. Creating the Template for the (Reactive) Recipe Edit Form](#10-creating-the-template-for-the-reactive-recipe-edit-form)
    - [11. Creating the Form For Editing Recipes](#11-creating-the-form-for-editing-recipes)
    - [12. Syncing HTML with the Form](#12-syncing-html-with-the-form)
    - [13. Adding Ingredient Controls to a Form Array](#13-adding-ingredient-controls-to-a-form-array)
    - [14. Fixing a Bug.html](#14-fixing-a-bughtml)
    - [15. Adding new Ingredient Controls](#15-adding-new-ingredient-controls)
    - [16. Validating User Input](#16-validating-user-input)
    - [17. Submitting the Recipe Edit Form](#17-submitting-the-recipe-edit-form)
    - [18. Adding a Delete and Clear (Cancel) Functionality](#18-adding-a-delete-and-clear-cancel-functionality)
    - [19. Redirecting the User (after Deleting a Recipe)](#19-redirecting-the-user-after-deleting-a-recipe)
    - [20. Adding an Image Preview](#20-adding-an-image-preview)
    - [21. Providing the Recipe Service Correctly](#21-providing-the-recipe-service-correctly)
    - [22. Deleting Ingredients and Some Finishing Touches](#22-deleting-ingredients-and-some-finishing-touches)
    - [23. Deleting all Items in a FormArray.html](#23-deleting-all-items-in-a-formarrayhtml)
  - [17. Using Pipes to Transform Output](#17-using-pipes-to-transform-output)
    - [1. Introduction & Why Pipes are Useful](#1-introduction--why-pipes-are-useful)
    - [2. Using Pipes](#2-using-pipes)
    - [3. Parametrizing Pipes](#3-parametrizing-pipes)
    - [4. Where to learn more about Pipes](#4-where-to-learn-more-about-pipes)
    - [5. Chaining Multiple Pipes](#5-chaining-multiple-pipes)
    - [6. Creating a Custom Pipe](#6-creating-a-custom-pipe)
    - [7. Parametrizing a Custom Pipe](#7-parametrizing-a-custom-pipe)
    - [8. Example Creating a Filter Pipe](#8-example-creating-a-filter-pipe)
    - [9. Pure and Impure Pipes (or How to fix the Filter Pipe)](#9-pure-and-impure-pipes-or-how-to-fix-the-filter-pipe)
    - [10. Understanding the async Pipe](#10-understanding-the-async-pipe)
    - [11. Practicing Pipes.html](#11-practicing-pipeshtml)
  - [18. Making Http Requests](#18-making-http-requests)
    - [1. A New IDE](#1-a-new-ide)
    - [3. How Does Angular Interact With Backends](#3-how-does-angular-interact-with-backends)
    - [3.1 Securing JS Code.html](#31-securing-js-codehtml)
    - [3.2 Building a REST API.html](#32-building-a-rest-apihtml)
    - [4. The Anatomy of a Http Request](#4-the-anatomy-of-a-http-request)
    - [5. Backend (Firebase) Setup](#5-backend-firebase-setup)
    - [6. Sending a POST Request](#6-sending-a-post-request)
    - [7. GETting Data](#7-getting-data)
    - [8. Using RxJS Operators to Transform Response Data](#8-using-rxjs-operators-to-transform-response-data)
    - [9. Using Types with the HttpClient](#9-using-types-with-the-httpclient)
    - [10. Outputting Posts](#10-outputting-posts)
    - [11. Showing a Loading Indicator](#11-showing-a-loading-indicator)
    - [12. Using a Service for Http Requests](#12-using-a-service-for-http-requests)
    - [13. Services & Components Working Together](#13-services--components-working-together)
    - [14. Sending a DELETE Request](#14-sending-a-delete-request)
    - [15. Handling Errors](#15-handling-errors)
    - [16. Using Subjects for Error Handling](#16-using-subjects-for-error-handling)
    - [17. Using the catchError Operator](#17-using-the-catcherror-operator)
    - [18. Error Handling & UX](#18-error-handling--ux)
    - [19. Setting Headers](#19-setting-headers)
    - [20. Adding Query Params](#20-adding-query-params)
    - [21. Observing Different Types of Responses](#21-observing-different-types-of-responses)
    - [22. Changing the Response Body Type](#22-changing-the-response-body-type)
    - [23. Introducing Interceptors](#23-introducing-interceptors)
    - [24. Manipulating Request Objects](#24-manipulating-request-objects)
    - [25. Response Interceptors](#25-response-interceptors)
    - [26. Multiple Interceptors](#26-multiple-interceptors)
    - [27. Wrap Up](#27-wrap-up)
    - [28. Useful Resources & Links.html](#28-useful-resources--linkshtml)
  - [19. Course Project - Http](#19-course-project---http)
    - [1. Module Introduction](#1-module-introduction-7)
    - [2. Backend (Firebase) Setup](#2-backend-firebase-setup)
    - [3. Setting Up the DataStorage Service](#3-setting-up-the-datastorage-service)
    - [4. Storing Recipes](#4-storing-recipes)
    - [5. Fetching Recipes](#5-fetching-recipes)
    - [6. Transforming Response Data](#6-transforming-response-data)
    - [7. Resolving Data Before Loading](#7-resolving-data-before-loading)
    - [8. Fixing a Bug with the Resolver](#8-fixing-a-bug-with-the-resolver)
  - [20. Authentication & Route Protection in Angular](#20-authentication--route-protection-in-angular)
    - [1. Module Introduction](#1-module-introduction-8)
    - [2. How Authentication Works](#2-how-authentication-works)
    - [3. Adding the Auth Page](#3-adding-the-auth-page)
    - [4. Switching Between Auth Modes](#4-switching-between-auth-modes)
    - [5. Handling Form Input](#5-handling-form-input)
    - [6. Preparing the Backend](#6-preparing-the-backend)
    - [7. Make sure you got Recipes in your backend!.html](#7-make-sure-you-got-recipes-in-your-backendhtml)
    - [8. Preparing the Signup Request](#8-preparing-the-signup-request)
    - [9. Sending the Signup Request](#9-sending-the-signup-request)
    - [10. Adding a Loading Spinner & Error Handling Logic](#10-adding-a-loading-spinner--error-handling-logic)
    - [11. Improving Error Handling](#11-improving-error-handling)
    - [12. Sending Login Requests](#12-sending-login-requests)
    - [13. Login Error Handling](#13-login-error-handling)
    - [14. Creating & Storing the User Data](#14-creating--storing-the-user-data)
    - [15. Reflecting the Auth State in the UI](#15-reflecting-the-auth-state-in-the-ui)
    - [16. Adding the Token to Outgoing Requests](#16-adding-the-token-to-outgoing-requests)
    - [17. Attaching the Token with an Interceptor](#17-attaching-the-token-with-an-interceptor)
    - [18. Adding Logout](#18-adding-logout)
    - [19. Adding Auto-Login](#19-adding-auto-login)
    - [20. Adding Auto-Logout](#20-adding-auto-logout)
    - [21. Adding an Auth Guard](#21-adding-an-auth-guard)
    - [22. Wrap Up](#22-wrap-up)
    - [23. Useful Resources & Links.html](#23-useful-resources--linkshtml)
  - [21. Dynamic Components](#21-dynamic-components)
    - [1. Module Introduction](#1-module-introduction-9)
    - [10. Useful Resources & Links.html](#10-useful-resources--linkshtml-1)
    - [2. Adding an Alert Modal Component](#2-adding-an-alert-modal-component)
    - [3. Understanding the Different Approaches](#3-understanding-the-different-approaches)
    - [4. Using ngIf](#4-using-ngif)
    - [5. Preparing Programmatic Creation](#5-preparing-programmatic-creation)
    - [6. Creating a Component Programmatically](#6-creating-a-component-programmatically)
    - [7. Understanding entryComponents](#7-understanding-entrycomponents)
    - [8. Data Binding & Event Binding](#8-data-binding--event-binding)
    - [9. Wrap Up](#9-wrap-up-1)
  - [22. Angular Modules & Optimizing Angular Apps](#22-angular-modules--optimizing-angular-apps)
    - [1. Module Introduction](#1-module-introduction-10)
    - [2. What are Modules](#2-what-are-modules)
    - [3. Analyzing the AppModule](#3-analyzing-the-appmodule)
    - [4. Getting Started with Feature Modules](#4-getting-started-with-feature-modules)
    - [5. Splitting Modules Correctly](#5-splitting-modules-correctly)
    - [6. Adding Routes to Feature Modules](#6-adding-routes-to-feature-modules)
    - [7. Component Declarations](#7-component-declarations)
    - [8. The ShoppingList Feature Module](#8-the-shoppinglist-feature-module)
    - [9. Understanding Shared Modules](#9-understanding-shared-modules)
    - [10. Understanding the Core Module](#10-understanding-the-core-module)
    - [11. Adding an Auth Feature Module](#11-adding-an-auth-feature-module)
    - [12. Understanding Lazy Loading](#12-understanding-lazy-loading)
    - [13. Implementing Lazy Loading](#13-implementing-lazy-loading)
    - [14. Alternative Lazy Loading Syntax.html](#14-alternative-lazy-loading-syntaxhtml)
    - [15. More Lazy Loading](#15-more-lazy-loading)
    - [16. Preloading Lazy-Loaded Code](#16-preloading-lazy-loaded-code)
    - [17. Modules & Services](#17-modules--services)
    - [18. Loading Services Differently](#18-loading-services-differently)
    - [19. Ahead-of-Time Compilation](#19-ahead-of-time-compilation)
    - [21. Useful Resources & Links.html](#21-useful-resources--linkshtml)
  - [23. Deploying an Angular App](#23-deploying-an-angular-app)
    - [1. Module Introduction](#1-module-introduction-11)
    - [2. Deployment Preparation & Steps](#2-deployment-preparation--steps)
    - [3. Using Environment Variables](#3-using-environment-variables)
    - [4. Deployment Example Firebase Hosting](#4-deployment-example-firebase-hosting)
    - [5. Server Routing vs Browser Routing.html](#5-server-routing-vs-browser-routinghtml)
  - [24. Bonus Working with NgRx in our Project](#24-bonus-working-with-ngrx-in-our-project)
    - [1. Module Introduction](#1-module-introduction-12)
    - [2. What is Application State](#2-what-is-application-state)
    - [3. What is NgRx](#3-what-is-ngrx)
    - [4. Getting Started with Reducers](#4-getting-started-with-reducers)
    - [5. Adding Logic to the Reducer](#5-adding-logic-to-the-reducer)
    - [6. Understanding & Adding Actions](#6-understanding--adding-actions)
    - [7. Setting Up the NgRx Store](#7-setting-up-the-ngrx-store)
    - [8. Selecting State](#8-selecting-state)
    - [9. Dispatching Actions](#9-dispatching-actions)
    - [10. Multiple Actions](#10-multiple-actions)
    - [11. Preparing Update & Delete Actions](#11-preparing-update--delete-actions)
    - [12. Updating & Deleting Ingredients](#12-updating--deleting-ingredients)
    - [13. Expanding the State](#13-expanding-the-state)
    - [14. Managing More State via NgRx](#14-managing-more-state-via-ngrx)
    - [15. Removing Redundant Component State Management](#15-removing-redundant-component-state-management)
    - [16. First Summary & Clean Up](#16-first-summary--clean-up)
    - [17. One Root State](#17-one-root-state)
    - [18. Setting Up Auth Reducer & Actions](#18-setting-up-auth-reducer--actions)
    - [19. Dispatching Auth Actions](#19-dispatching-auth-actions)
    - [20. Auth Finished (For Now...)](#20-auth-finished-for-now)
    - [21. And Important Note on Actions](#21-and-important-note-on-actions)
    - [22. Exploring NgRx Effects](#22-exploring-ngrx-effects)
    - [23. Defining the First Effect](#23-defining-the-first-effect)
    - [24. Effects & Error Handling](#24-effects--error-handling)
    - [25. Login via NgRx Effects](#25-login-via-ngrx-effects)
    - [26. Managing UI State in NgRx](#26-managing-ui-state-in-ngrx)
    - [27. Finishing the Login Effect](#27-finishing-the-login-effect)
    - [28. Preparing Other Auth Actions](#28-preparing-other-auth-actions)
    - [29. Adding Signup](#29-adding-signup)
    - [30. Further Auth Effects](#30-further-auth-effects)
    - [31. Adding Auto-Login with NgRx](#31-adding-auto-login-with-ngrx)
    - [32. Adding Auto-Logout](#32-adding-auto-logout)
    - [33. Finishing the Auth Effects](#33-finishing-the-auth-effects)
    - [34. Using the Store Devtools](#34-using-the-store-devtools)
    - [35. The Router Store](#35-the-router-store)
    - [36. Getting Started with NgRx for Recipes](#36-getting-started-with-ngrx-for-recipes)
    - [37. Fetching Recipe Detail Data](#37-fetching-recipe-detail-data)
    - [38. Fetching Recipes & Using the Resolver](#38-fetching-recipes--using-the-resolver)
    - [39. Fixing the Auth Redirect](#39-fixing-the-auth-redirect)
    - [40. Update, Delete and Add Recipes](#40-update-delete-and-add-recipes)
    - [41. Storing Recipes via Effects](#41-storing-recipes-via-effects)
    - [42. Cleanup Work](#42-cleanup-work)
    - [43. Wrap Up - Alternative NgRx Syntax](#43-wrap-up---alternative-ngrx-syntax)
    - [44. Useful Resources & Links.html](#44-useful-resources--linkshtml)
    - [45. MUST READ The [LEGACY] Lectures.html](#45-must-read-the-legacy-lectureshtml)
  - [25. Bonus Angular Universal](#25-bonus-angular-universal)
    - [1. Module Introduction](#1-module-introduction-13)
    - [Angular Universal & ModuleMapLoader](#angular-universal--modulemaploader)
    - [Adding Angular Universal](#adding-angular-universal)
    - [Adding Angular Universal with NestJS](#adding-angular-universal-with-nestjs)
    - [Deploying Universal Apps](#deploying-universal-apps)
    - [Important: Remaining Lectures](#important-remaining-lectures)
    - [Module Introduction](#module-introduction)
    - [Getting Started with Angular Universal](#getting-started-with-angular-universal)
    - [Working on the App Module](#working-on-the-app-module)
    - [Adding a Server-Side Build Workflow](#adding-a-server-side-build-workflow)
    - [Adding a NodeJS Server](#adding-a-nodejs-server)
    - [Pre-Rendering the App on the Server](#pre-rendering-the-app-on-the-server)
    - [Next Steps](#next-steps)
    - [Angular Universal Gotchas](#angular-universal-gotchas)
    - [2. Important Official Docs & Starting Project.html](#2-important-official-docs--starting-projecthtml)
    - [3. Getting Started with Angular Universal](#3-getting-started-with-angular-universal)
    - [4. Working on the App Module](#4-working-on-the-app-module)
    - [5. Adding a Server-Side Build Workflow](#5-adding-a-server-side-build-workflow)
    - [6. Adding a NodeJS Server](#6-adding-a-nodejs-server)
    - [7. Pre-Rendering the App on the Server](#7-pre-rendering-the-app-on-the-server)
    - [8. Next Steps](#8-next-steps)
    - [9. Angular Universal Gotchas.html](#9-angular-universal-gotchashtml)
  - [26. Angular Animations](#26-angular-animations)
    - [1. Making Animations Work with Angular 4+.html](#1-making-animations-work-with-angular-4html)
    - [](#)
    - [2. Introduction](#2-introduction)
    - [3. Setting up the Starting Project](#3-setting-up-the-starting-project)
    - [4. Animations Triggers and State](#4-animations-triggers-and-state)
    - [5. Switching between States](#5-switching-between-states)
    - [6. Transitions](#6-transitions)
    - [7. Advanced Transitions](#7-advanced-transitions)
    - [8. Transition Phases](#8-transition-phases)
    - [9. The void State](#9-the-void-state)
    - [10. Using Keyframes for Animations](#10-using-keyframes-for-animations)
    - [11. Grouping Transitions](#11-grouping-transitions)
    - [12. Using Animation Callbacks](#12-using-animation-callbacks)
  - [27. Adding Offline Capabilities with Service Workers](#27-adding-offline-capabilities-with-service-workers)
    - [1. Module Introduction](#1-module-introduction-14)
    - [2. Adding Service Workers](#2-adding-service-workers)
    - [3. Caching Assets for Offline Use](#3-caching-assets-for-offline-use)
    - [4. Caching Dynamic Assets & URLs](#4-caching-dynamic-assets--urls)
    - [5. Further Links & Resources.html](#5-further-links--resourceshtml)
  - [28. A Basic Introduction to Unit Testing in Angular Apps](#28-a-basic-introduction-to-unit-testing-in-angular-apps)
    - [1. About this Section.html](#1-about-this-sectionhtml)
    - [2. Introduction](#2-introduction-1)
    - [3. Why Unit Tests](#3-why-unit-tests)
    - [4. Analyzing the Testing Setup (as created by the CLI)](#4-analyzing-the-testing-setup-as-created-by-the-cli)
    - [5. Running Tests (with the CLI)](#5-running-tests-with-the-cli)
    - [6. Adding a Component and some fitting Tests](#6-adding-a-component-and-some-fitting-tests)
    - [7. Testing Dependencies Components and Services](#7-testing-dependencies-components-and-services)
    - [8. Simulating Async Tasks](#8-simulating-async-tasks)
    - [9. Using fakeAsync and tick](#9-using-fakeasync-and-tick)
    - [10. Isolated vs Non-Isolated Tests](#10-isolated-vs-non-isolated-tests)
    - [11. Further Resources & Where to Go Next.html](#11-further-resources--where-to-go-nexthtml)
  - [29. Angular Changes & New Features](#29-angular-changes--new-features)
    - [1. What's New with Angular 8](#1-whats-new-with-angular-8)
    - [2. What's New & How to Update.html](#2-whats-new--how-to-updatehtml)
  - [30. Course Roundup](#30-course-roundup)
    - [1. Course Roundup](#1-course-roundup)
    - [2. Bonus More Content!.html](#2-bonus-more-contenthtml)
  - [31. Custom Project & Workflow Setup](#31-custom-project--workflow-setup)
    - [1. Introduction](#1-introduction-3)
    - [2. Initializing the Project](#2-initializing-the-project)
    - [3. Setting up the Basic Project Files](#3-setting-up-the-basic-project-files)
    - [4. Installing the Core Dependencies](#4-installing-the-core-dependencies)
    - [5. Filling the Project Files with Some Life](#5-filling-the-project-files-with-some-life)
    - [6. index.html & Polyfills](#6-indexhtml--polyfills)
    - [6. index.html & Polyfills.vtt](#6-indexhtml--polyfillsvtt)
    - [7. Installing Development Dependencies](#7-installing-development-dependencies)
    - [8. Setting up a Development Workflow](#8-setting-up-a-development-workflow)
    - [9. Updating to Angular 6 + Webpack 4.html](#9-updating-to-angular-6--webpack-4html)
    - [10. Finishing & Using the Development Workflow](#10-finishing--using-the-development-workflow)
    - [11. Setting up a Production Workflow](#11-setting-up-a-production-workflow)
    - [12. Adding Types & Fixing Bugs](#12-adding-types--fixing-bugs)
    - [13. Finishing Touches](#13-finishing-touches)
  - [32. Bonus TypeScript Introduction (for Angular 2 Usage)](#32-bonus-typescript-introduction-for-angular-2-usage)
    - [1. Introduction](#1-introduction-4)
    - [2. Using Types](#2-using-types)
    - [3. Classes](#3-classes)
    - [4. Interfaces](#4-interfaces)
    - [5. Generics](#5-generics)
    - [6. Wrap up & Modules](#6-wrap-up--modules)
    - [7. Deep dive into TypeScript.html](#7-deep-dive-into-typescripthtml)

---

# Angular 8 (formerly Angular 2) - The Complete Guide

https://www.udemy.com/course/the-complete-guide-to-angular-2/

## 1. Getting Started

### 1. Course Introduction

### 2. What is Angular

- is a javascript framework to create a reactive SPA
- SPA la khi navigate thì chỉ có 1 file HTML, page sẽ không reload lại

### 3. Angular vs Angular 2 vs Angular 8

Angular JS
Angular 2
Angular 8

![image-20200523221350884](angular.assets/image-20200523221350884.png)

### 4. CLI Deep Dive & Troubleshooting.html

In the next lecture, we're going to build our first little app!

If the CLI prompts you to **answer some questions** (some versions do that), you can simply hit ENTER for all questions. This will accept the default settings which are fine for this course.

The CLI generates a different welcome screen than you're going to see in my video though. No worries, you'll still be able to follow along without issues! Just make sure to code along so that your code equals mine - Angular itself didn't change a bit :)

Depending on the CLI version you're using, you might also need to add the FormsModule to the imports[] array in your app.module.ts file (add it if you don't see it there). You might not fully understand what that all means but we're going to cover that in this course, no worries.

If you don't have **FormsModule** in imports[] in AppModule , please do add it and also add an import at the top of that file:

```ts
import { FormsModule } from '@angular/forms';
```

---

If you want to dive deeper into the CLI and learn more about its usage, have a look at its official documentation: https://github.com/angular/angular-cli/wiki

You encountered issues during the installation of the CLI or setup of a new Angular project?

A lot of problems are solved by making sure you're using the latest version of NodeJS, npm and the CLI itself.

Updating NodeJS:

Go to nodejs.org and download the latest version - uninstall (all) installed versions on your machine first.

Updating npm:

Run `[sudo] npm install -g npm` (sudo is only required on Mac/ Linux)

Updating the CLI

```js
[sudo] npm uninstall -g angular-cli @angular/cli

npm cache verify

[sudo] npm install -g @angular/cli

```

Here are some common issues & solutions:

- Creation of a new project takes forever (longer than 3 minutes)
  That happens on Windows from time to time => Try running the command line as administrator

- You get an EADDR error (Address already in use)
  You might already have another ng serve process running - make sure to quit that or use

```ts
ng serve --port ANOTHERPORT

```

to serve your project on a new port

- My changes are not reflected in the browser (App is not compiling)
  Check if the window running `ng serve` displays an error. If that's not the case, make sure you're using the latest CLI version and try restarting your CLI

### 5. Project Setup and First App

Node.js Download

At the moment, the Node webpage (nodejs.org) which we're going to use in the next lecture looks different.

This will only be the case temporarily (as you can tell if you visit the page) but in the meantime, since you're going to need to download NodeJS from the site, here's the download link: https://nodejs.org/en/download/

We'll need that in the next lecture.

https://angular.io/guide/setup-local

**To install the Angular CLI**:  
https://github.com/angular/angular-cli/wiki

```js
node -v
npm -v
npm install -g typescript
npm install -g @angular/clilatest

```

Generating and serving an Angular project via a development server Create and run a new project:

```js
ng new my-project
cd my-project
ng serve

ng serve --port 3000

```

**C:\Users\phuong\AppData\Roaming\npm\node_modules\@angular\cli\bin**
**C:\Users\phuong\AppData\Roaming\npm**

Vào Path thêm rồi restart

```js
npm uninstall -g angular-cli

npm uninstall --save-dev angular-cli

npm cache clean

npm install -g @angular/cli@latest

```

![image-20200605142459873](angular.assets/image-20200605142459873.png)

I followed below steps for resolution for this issue in Windows 10:

First make sure you have installed Angular CLI . You can use below to install same.
`npm install -g @angular/cli@latest`

**Make sure that AppData is visible and navigate to path below.**
`C:\Users\rkota\AppData\Roaming\npm`

Same path can be found by running below too:

`npm config get prefix`

Add the above path i.e. " C:\Users\rkota\AppData\Roaming\npm" in Environment variable PATH and make sure it got added by running path in command prompt.

Close command prompt and now try to run below:
`ng --version`

you will be able to see CLI version.

![image-20200605141651197](angular.assets/image-20200605141651197.png)

![image-20200605141709194](angular.assets/image-20200605141709194.png)

---

Component includes: html, css, file ts

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  title = 'app';
}

// @Component duoc goi la decorator
```

Sau do vao file module.ts them Component moi duoc tao ra:

```ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

### 6. Editing the First App

app.component.html

```html
<input type="text" [(ngModel)]="name" />
<p>{{ name }}</p>
```

app.component.ts

```js
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  // add
  name = 'Max';
}
```

app.module.ts

```js
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';

import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    FormsModule, // add
  ],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

### 7. The Course Structure

![img](angular.assets/2019-11-16-12-15-30.png)

### 9. What is TypeScript

TypeScript is compile to JS

![image-20200523223602000](angular.assets/image-20200523223602000.png)

However, Typescript doesn't run in the browser, so it is compiled to JavaScript in the end.

This compilation is handled by the CLI; one of the reasons why we need the CLI, why we need a project management tool like the CLI.

### 10. A Basic Project Setup using Bootstrap for Styling

```ts
Npm install --save bootstrap@3
```

=> install locally

![image-20200523223802291](../../../../angular/angular-docs/angular-setting.assets/image-20200523223802291.png)

Tại file angular.json sửa lại tại options :

```js
"styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css",
              "src/styles.css"
            ],

```

### 11. Where to find the Course Source Code.html

In the next lecture, we set up the course project. For that, we'll install the Bootstrap CSS Framework.
In this course, we use version 3 of the framework, install it via `npm install --save bootstrap@3` => The @3 is important!  
Additionally, when using a project created with Angular CLI 6+ (check via ng -v ), you'll have an angular.json file instead of an .angular-cli.json file.

In that file, you still need to add Bootstrap to the styles[] array as shown in the next video, but the path should be `node_modules/bootstrap/dist/css/bootstrap.min.css` , NOT `../node_modules/bootstrap/dist/css/bootstrap.min.css` .

The leading ../ must not be included.
Also see this lecture - I do show the complete setup process there: https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/6655614/

app.components.html

```html
<div class="container">
  <div class="form-group">
    <label for="usr">Name:</label>
    <input type="text" class="form-control" id="usr" [(ngModel)]="name" />
  </div>
  <div class="form-group">
    <label for="pwd">Password:</label>
    <input type="password" class="form-control" id="pwd" [(ngModel)]="pwd" />
  </div>

  <div class="alert alert-info">
    <button type="button" class="close" data-dismiss="alert" aria-hidden="true">
      &times;
    </button>
    <strong>{{ name }}</strong>
  </div>
</div>
```

app.component.ts

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  name = 'first-app-chap1';
  pwd = '123';
}
```

app.module.ts thêm FormsModule vì nếu k có [(ngModel)] sẽ báo lỗi

```ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, FormsModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

**Must inport FormsModule**
angular.json

```js
"styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css",
              "src/styles.css"
            ],

```

---

## 2. The Basics

**Run with cmd**

> ```
> netstat -ano | findstr :PORT_NUMBER
> ```

(Replace PORT_NUMBER with the port number you want, but keep the colon)

![img](angular.assets/lEpCZ.png)

The area circled in red shows the PID (process identifier). Locate the PID of the process that's using the port you want.

**Step 2:**

Next, run the following command:

> ```
> taskkill /PID PORT_NUMBER /F
> ```

(No colon this time)

![img](angular.assets/8k64x.png)

### 1. Module Introduction

Angular is a js framework, change your DOM(‘html’) at runtime
Component: divide your application into many components => chia thành các phần có thể tái SD

Xem lại: https://phocode.com/javascript/lap-trinh-web-voi-angularjs-2/angular-typescript-phan-1/

### 2. How an Angular App gets Loaded and Started

File main.ts sẽ liên kết toàn bộ các file thành một ứng dụng hoàn chỉnh.

![image-20200605163545934](angular.assets/image-20200605163545934.png)

### 4. Creating a New Component

- Create server folder
- Create server component
  Add decorater @component in typescript class
  **Source**: basics-components.zip
  Add in modules

### 5. Understanding the Role of AppModule and Component Declaration

Angular doesn't scan all class so yout must tell angular component exist in AppModule
Go to declarations to add new **ServerComponent**

```ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { FormsModule } from '@angular/forms';

import { AppComponent } from './app.component';
import { ServerComponent } from './server/server.component';
import { ServersComponent } from './servers/servers.component';

@NgModule({
  // add new
  declarations: [AppComponent, ServerComponent, ServersComponent],
  imports: [BrowserModule, FormsModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

### 6. Using Custom Components

declare in html file

### 7. Creating Components with the CLI & Nesting Components

```ts
Ng generate component servers
Ng g c servers
Ng g c servers –-spec false
=> tạo ra k có file test .spec
Ng g c servers/child –-spec false
=> tạo ở trong folder servers
Angular will auto add in app.module.ts
```

### 8. Working with Component Templates

Nếu định nghĩa template trong 1 file thì sử dụng dấu `` nếu viết trên nhiều dòng, dấu '' thì viết chỉ được trên line:

```ts
@Component({
  selector: 'server-root',
  // selector: '[server-root]', là 1 thuộc tính
  // selector: '.server-root', là 1 class

  template: `code in here mutiple lines…`,
  styles: [`code in here…`]
})

```

Change templateUrl => template to write code

```ts
@Component({
  // selector: '[app-servers]',
  // selector: '.app-servers',
  selector: 'app-servers',
  template: `
    <app-server></app-server>
    <app-server></app-server>
  `,
  styleUrls: ['./servers.component.css'],
})
export class ServersComponent implements OnInit {
  constructor() {}

  ngOnInit() {}
}
```

### 9. Working with Component Styles

app.component.ts

Change styleUrls => styles

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  // styleUrls: ['./app.component.css']
  styles: [
    `
      h3 {
        color: dodgerblue;
      }
    `,
  ],
})
export class AppComponent {}
```

### 10. Fully Understanding the Component Selector

```ts
  selector: 'server-root',
  // selector: '[server-root]', là 1 thuộc tính
  // selector: '.server-root', là 1 class

app.component.html
        <!--<div app-servers></div>-->
      <!--<div class="app-servers"></div>-->
```

### 11. Practicing Components.html

### 12. [OPTIONAL] Assignment Solution

![image-20200607195555001](angular.assets/image-20200607195555001.png)

warning-alert.component.ts

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-warning-alert',
  template: ` <p>This is a warning, you are in danger!</p> `,
  styles: [
    `
      p {
        padding: 20px;
        background-color: mistyrose;
        border: 1px solid red;
      }
    `,
  ],
})
export class WarningAlertComponent {}
```

app.component.html

```html
<app-warning-alert></app-warning-alert>
<app-success-alert></app-success-alert>
```

app.module.ts

```ts
@NgModule({
  declarations: [AppComponent, WarningAlertComponent, SuccessAlertComponent],
  imports: [BrowserModule, FormsModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

### 13. What is Databinding

![](angular.assets/2019-11-17-02-20-04.png)

### 14. String Interpolation

server.component.html

```html
<p>{{ 'Server' }} with ID {{ serverId }} is {{ getServerStatus() }}</p>
```

server.component.ts

```ts
@Component({
  selector: 'app-server',
  templateUrl: './server.component.html',
})
export class ServerComponent {
  serverId: number = 10;
  serverStatus: string = 'offline';

  getServerStatus() {
    return this.serverStatus;
  }
}
```

### 15. Property Binding

use by []
servers.component.html

```html
<button
  class="btn btn-primary"
  [disabled]="!allowNewServer"">Add Server</button>
```

servers.component.ts

```ts
constructor() {
    setTimeout(() => {
      this.allowNewServer = true;
    }, 2000);
  }
```

### 16. Property Binding vs String Interpolation

servers.component.html
Print value of `allowNewServer`

```html
<p [innerText]="allowNewServer"></p>
```

### 17. Event Binding

servers.component.html

```html
<button
  class="btn btn-primary"
  [disabled]="!allowNewServer"
  (click)="onCreateServer()"
>
  Add Server
</button>
```

### 18. Bindable Properties and Events.html

How do you know to which Properties or Events of HTML Elements you may bind? You can basically bind to all Properties and Events - a good idea is to console.log() the element you're interested in to see which properties and events it offers.

Important: For events, you don't bind to onclick but only to click (=> (click)).

The MDN (Mozilla Developer Network) offers nice lists of all properties and events of the element you're interested in. Googling for YOUR_ELEMENT properties or YOUR_ELEMENT events should yield nice results.

### 19. Passing and Using Data with Event Binding

send data with event
servers.component.html

```html
<input /> type="text" class="form-control" (input)="onUpdateServerName($event)">
```

servers.component.ts

```ts
  onUpdateServerName(event: any) {
    console.log(event);
  }
  ---
  onUpdateServerName(event: Event) {
    this.serverName = (<HTMLInputElement>event.target).value;
  }
```

### 20. Important FormsModule is Required for Two-Way-Binding!.html

Important: For Two-Way-Binding (covered in the next lecture) to work, you need to enable the `ngModel` directive. This is done by adding the `FormsModule` to the `imports[]` array in the AppModule.

You then also need to add the import from `@angular/forms` in the app.module.ts file:

```ts
import { FormsModule } from '@angular/forms';
```

### 21. Two-Way-Databinding

servers.component.ts

```html
<input type="text" class="form-control" [(ngModel)]="serverName" />
<!--<p>{{ serverName }}</p>-->
```

click button => create sever

ngModel được gọi là directive

### 22. Combining all Forms of Databinding

### 23. Practicing Databinding.html

### 24. [OPTIONAL] Assignment Solution

![image-20200607204305128](angular.assets/image-20200607204305128.png)

```html
<div class="container">
  <div class="row">
    <div class="col-xs-12">
      <ol>
        <li>
          Add a Input field which updates a property ('username') via
          Two-Way-Binding
        </li>
        <li>
          Output the username property via String Interpolation (in a paragraph
          below the input)
        </li>
        <li>
          Add a button which may only be clicked if the username is NOT an empty
          string
        </li>
        <li>
          Upon clicking the button, the username should be reset to an empty
          string
        </li>
      </ol>
      <hr />
      <label>Username</label>
      <input type="text" class="form-control" [(ngModel)]="username" />
      <p>{{ username }}</p>
      <button
        class="btn btn-primary"
        [disabled]="username === ''"
        (click)="username = ''"
      >
        Reset User
      </button>
    </div>
  </div>
</div>
```

### 25. Understanding Directives

![](angular.assets/2019-11-17-10-03-21.png)

### 26. Using ngIf to Output Data Conditionally

basics-final.zip
servers.component.html

```html
<p *ngIf="serverCreated">Server was created, server name is {{ serverName }}</p>
```

servers.component.ts

```ts
onCreateServer() {
    this.serverCreated = true;
    this.serverCreationStatus = 'Server was created! Name is ' + this.serverName;
  }
```

### 27. Enhancing ngIf with an Else Condition

Use local references to mark else **#condition**

```html
<p *ngIf="is_available; else false_condition">Điểu kiện đúng trong thẻ ngIf</p>
<ng-template #false_condition><p>Điều kiện sai trong template</p></ng-template>
```

### 28. Styling Elements Dynamically with ngStyle

![image-20200607210539183](angular.assets/image-20200607210539183.png)

Attribute directive
server.component.html

```html
<p
  [ngStyle]="{backgroundColor: getColor()}"
  [ngClass]="{online: serverStatus === 'online'}"
>
  {{ 'Server' }} with ID {{ serverId }} is {{ getServerStatus() }}
</p>

--- can write [ngStyle]="{'font-style': this.canSave}"
```

server.component.ts

```ts
@Component({
  selector: 'app-server',
  templateUrl: './server.component.html',
  // add styles
  styles: [`
    .online {
      color: white;
    }
  `]
})
.....
 constructor() {
    this.serverStatus = Math.random() > 0.5 ? 'online' : 'offline';
  }

  getServerStatus() {
    return this.serverStatus;
  }

  getColor() {
    return this.serverStatus === 'online' ? 'green' : 'red';
  }
```

### 29. Applying CSS Classes Dynamically with ngClass

### 30. Outputting Lists with ngFor

```html
<app-server *ngFor="let server of servers"></app-server>
```

![image-20200607211342506](angular.assets/image-20200607211342506.png)

### 31. Practicing Directives.html

### 32. [OPTIONAL] Assignment Solution

```html
<button class="btn btn-primary" (click)="onToggleDetails()">Display Details</button>
      <p *ngIf="showSecret">Secret Password = tuna</p>
      <div
        *ngFor="let logItem of log"
        [ngStyle]="{backgroundColor: logItem >= 5 ? 'blue' : 'transparent'}"
        [ngClass]="{'white-text': logItem >= 5}"
      >{{ logItem }}</div>
    </div>
```

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  showSecret = false;
  log = [];

  onToggleDetails() {
    this.showSecret = !this.showSecret;
    this.log.push(this.log.length + 1);
  }
}
```

### 33. Getting the Index when using ngFor

![image-20200607211813408](angular.assets/image-20200607211813408.png)

33.1 basics-ngfor-addition.zip

```html
<button class="btn btn-primary" (click)="onToggleDetails()">Display Details</button>
      <p *ngIf="showSecret">Secret Password = tuna</p>
      <div
        *ngFor="let logItem of log; let i = index"
        [ngStyle]="{backgroundColor: i >= 5 ? 'blue' : 'transparent'}"
        [ngClass]="{'white-text': i >= 5}"
      >{{ logItem }}</div>
    </div>
```

## 3. Course Project - The Basics

### 1. Project Introduction

### 2. Planning the App

![](angular.assets/2019-11-17-12-27-06.png)

### 3. Installing Bootstrap Correctly.html

In the next lecture, we set up the course project. For that, we'll install the Bootstrap CSS Framework.

In this course, we use version 3 of the framework, install it via npm install --save bootstrap@3 => The @3 is important!

Additionally, when using a project created with Angular CLI 6+ (check via ng -v ), you'll have an angular.json file instead of an .angular-cli.json file. In that file, you still need to add Bootstrap to the styles[] array as shown in the next video, but the path should be node_modules/bootstrap/dist/css/bootstrap.min.css , NOT ../node_modules/bootstrap/dist/css/bootstrap.min.css . The leading ../ must not be included.

Also see this lecture - I do show the complete setup process there: https://www.udemy.com/the-complete-guide-to-angular-2/learn/v4/t/lecture/6655614/

### 4. Setting up the Application

install bs3

### 5. Creating the Components

![image-20200608003510267](angular.assets/image-20200608003510267.png)

Create header and Add new Component in modules

```ts
ng g c header --spec false
ng g c recepies --spec false
ng g c recepies/recepie-list --spec false
ng g c shopping-list --spec false
```

Tại file app.component.html:

```html
<app-header></app-header>

<div class="container">
  <div class="row">
    <div class="col-md-12">
      <app-recipes></app-recipes>
      <app-shopping-list></app-shopping-list>
    </div>
  </div>
</div>
```

Tại file recipes.component.html;

```html
<div class="row">
  <div class="col-md-5">
    <app-recipe-list></app-recipe-list>
  </div>
  <div class="col-md-7">
    <app-recipe-detail></app-recipe-detail>
  </div>
</div>
```

Tại file recipe-list.component.html :

```html
<div class="row">
  <div class="col-xs-12">
    <button class="btn btn-success">New Recipe</button>
  </div>
</div>
<hr />
<div class="row">
  <div class="col-xs-12">
    <app-recipe-item></app-recipe-item>
  </div>
</div>
```

Tại file shopping-list.component.html

```html
<div class="row">
  <div class="col-xs-10">
    <app-shopping-edit></app-shopping-edit>
    <hr />
    <ul class="list-group"></ul>
  </div>
</div>
```

### 6. Using the Components

### 7. Adding a Navigation Bar

```html
<nav class="navbar navbar-default">
  <div class="container-fluid">
    <div class="navbar-header">
      <a href="#" class="navbar-brand">Recipe Book</a>
    </div>

    <div class="collapse navbar-collapse">
      <ul class="nav navbar-nav">
        <li><a href="#">Recipes</a></li>
        <li><a href="#">Shopping List</a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" role="button"
            >Manage <span class="caret"></span
          ></a>
          <ul class="dropdown-menu">
            <li><a href="#">Save Data</a></li>
            <li><a href="#">Fetch Data</a></li>
          </ul>
        </li>
      </ul>
    </div>
  </div>
</nav>
```

![image-20200607222152486](angular.assets/image-20200607222152486.png)

### 8. Alternative Non-Collapsable Navigation Bar.html

The way we added it, the Navbar will collapse on smaller screens. Since we didn't implement a Hamburger menu, that means that there's no way of accessing our links on smaller screens.

You can either add such a menu on your own (see below), or you replace collapse navbar-collapse with just navbar-default.

Adding a Hamburger Menu:

Alternatively, if you want to make the navigation bar responsive, please replace these lines in header.component.html:

```html
<div class="navbar-header">
  <a routerLink="/" class="navbar-brand">Recipe Book</a>
</div>
<div class="collapse navbar-collapse"></div>
```

with these lines:

```html

<div class="navbar-header">
    <button
      type="button"
      class="navbar-toggle"
      (click)="collapsed = !collapsed"
    >
      <span class="icon-bar" *ngFor="let iconBar of [1, 2, 3]"></span>
    </button>
    <a routerLink="/" class="navbar-brand">Recipe Book</a>
  </div>
  <div
    class="navbar-collapse"
    [class.collapse]="collapsed"
    (window:resize)="collapsed = true"
  ></div>
</div>
```

and add this line to header.component.ts:

collapsed = true;

### 9. Creating a Recipe Model

```ts
export class Recipe {
  public name: string;
  public description: string;
  public imagePath: string;

  constructor(name: string, desc: string, imagePath: string) {
    this.name = name;
    this.description = desc;
    this.imagePath = imagePath;
  }
}
```

### 10. Adding Content to the Recipes Components

### 11. Outputting a List of Recipes with ngFor

recipe-list.component.ts

```ts
export class RecipeListComponent implements OnInit {
  recipes: Recipe[] = [
    new Recipe(
      'A Test Recipe',
      'This is simply a test',
      'https://upload.wikimedia.org/wikipedia/commons/1/15/Recipe_logo.jpeg'
    ),
    new Recipe(
      'A Test Recipe',
      'This is simply a test',
      'https://upload.wikimedia.org/wikipedia/commons/1/15/Recipe_logo.jpeg'
    ),
  ];

  constructor() {}

  ngOnInit() {}
}
```

Tại file recipe-list.component.html sửa lại để đổ data:

```html
<div class="row">
  <div class="col-xs-12">
    <button class="btn btn-success">New Recipe</button>
  </div>
</div>
<hr />
<div class="row">
  <div class="col-xs-12">
    <a href="#" class="list-group-item clearfix" *ngFor="let recipe of recipes">
      <div class="pull-left">
        <h4 class="list-group-item-heading">{{ recipe.name }}</h4>
        <p class="list-group-item-text">{{ recipe.description }}</p>
      </div>
      <span class="pull-right">
        <img
          [src]="recipe.imagePath"
          alt="{{ recipe.name }}"
          class="img-responsive"
          style="max-height: 50px;"
        />
      </span>
    </a>
    <app-recipe-item></app-recipe-item>
  </div>
</div>
```

Can write src="{{recipe.imagePath}}"

![image-20200607233107824](angular.assets/image-20200607233107824.png)

### 12. Displaying Recipe Details

recipe-detail.component.html

```html
<div class="row">
  <div class="col-xs-12">
    <img src="" alt="" class="img-responsive" />
  </div>
</div>
<div class="row">
  <div class="col-xs-12">
    <h1>Recipe Name</h1>
  </div>
</div>
<div class="row">
  <div class="col-xs-12">
    <div class="btn-group">
      <button type="button" class="btn btn-primary dropdown-toggle">
        Manage Recipe <span class="caret"></span>
      </button>
      <ul class="dropdown-menu">
        <li><a href="#">To Shopping List</a></li>
        <li><a href="#">Edit Recipe</a></li>
        <li><a href="#">Delete Recipe</a></li>
      </ul>
    </div>
  </div>
</div>
<div class="row">
  <div class="col-xs-12">Description</div>
</div>
<div class="row">
  <div class="col-xs-12">Ingredients</div>
</div>
```

![image-20200608000729831](angular.assets/image-20200608000729831.png)

### 13. Working on the ShoppingListComponent

### 14. Creating an Ingredient Model

share/ingredient.model.ts

```ts
export class Ingredient {
  constructor(public name: string, public amount: number) {}
}
```

Co the viet gon lai ntn thay vi gan value cho prop da khai bao trong typescripts

### 15. Creating and Outputting the Shopping List

shopping-list.component.ts

```ts
import { Component, OnInit } from '@angular/core';

import { Ingredient } from '../shared/ingredient.model';

@Component({
  selector: 'app-shopping-list',
  templateUrl: './shopping-list.component.html',
  styleUrls: ['./shopping-list.component.css'],
})
export class ShoppingListComponent implements OnInit {
  ingredients: Ingredient[] = [
    new Ingredient('Apples', 5),
    new Ingredient('Tomatoes', 10),
  ];

  constructor() {}

  ngOnInit() {}
}
```

shopping-list.component.html

```html
<div class="row">
  <div class="col-xs-10">
    <app-shopping-edit></app-shopping-edit>
    <hr />
    <ul class="list-group">
      <a
        class="list-group-item"
        style="cursor: pointer"
        *ngFor="let ingredient of ingredients"
      >
        {{ ingredient.name }} ({{ ingredient.amount }})
      </a>
    </ul>
  </div>
</div>
```

### 16. Adding a Shopping List Edit Section

shopping-edit

```html
<div class="row">
  <div class="col-xs-12">
    <form>
      <div class="row">
        <div class="col-sm-5 form-group">
          <label for="name">Name</label>
          <input type="text" id="name" class="form-control" />
        </div>
        <div class="col-sm-2 form-group">
          <label for="amount">Amount</label>
          <input type="number" id="amount" class="form-control" />
        </div>
      </div>
      <div class="row">
        <div class="col-xs-12">
          <button class="btn btn-success" type="submit">Add</button>
          <button class="btn btn-danger" type="button">Delete</button>
          <button class="btn btn-primary" type="button">Clear</button>
        </div>
      </div>
    </form>
  </div>
</div>
```

### 17. Wrap Up & Next Steps

![image-20200608003510267](angular.assets/image-20200608003510267.png)

## 4. Debugging

### 1. Understanding Angular Error Messages

### 2. Debugging Code in the Browser Using Sourcemaps

Delete the last intem is not work
=> Use chrome
Vao folder webpack/./src

![image-20200608003733305](angular.assets/image-20200608003733305.png)

### 3. Using Augury to Dive into Angular Apps

install Augury extensions

## 5. Components & Databinding Deep Dive

### 1. Module Introduction

### 2. Splitting Apps into Components

```ts
ng g c cockpit –-spec false
ng g c server-element –-spec false
```

App tạo server và blue print server(khi hiển thị sẽ in nghiêng và có màu khác): get server được tạo ra bởi cockpit và thêm vào list server ở app component

![image-20200608004202825](angular.assets/image-20200608004202825.png)

cmp-databinding-start

app.component.html

```html
<div class="container">
  <div class="row">
    <div class="col-xs-12">
      <p>Add new Servers or blueprints!</p>
      <label>Server Name</label>
      <input type="text" class="form-control" [(ngModel)]="newServerName" />
      <label>Server Content</label>
      <input type="text" class="form-control" [(ngModel)]="newServerContent" />
      <br />
      <button class="btn btn-primary" (click)="onAddServer()">
        Add Server
      </button>
      <button class="btn btn-primary" (click)="onAddBlueprint()">
        Add Server Blueprint
      </button>
    </div>
  </div>
  <hr />
  <div class="row">
    <div class="col-xs-12">
      <div class="panel panel-default" *ngFor="let element of serverElements">
        <div class="panel-heading">{{ element.name }}</div>
        <div class="panel-body">
          <p>
            <strong *ngIf="element.type === 'server'" style="color: red"
              >{{ element.content }}</strong
            >
            <em *ngIf="element.type === 'blueprint'">{{ element.content }}</em>
          </p>
        </div>
      </div>
    </div>
  </div>
</div>
```

app.components.ts

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  serverElements = [];
  newServerName = '';
  newServerContent = '';

  onAddServer() {
    this.serverElements.push({
      type: 'server',
      name: this.newServerName,
      content: this.newServerContent,
    });
  }

  onAddBlueprint() {
    this.serverElements.push({
      type: 'blueprint',
      name: this.newServerName,
      content: this.newServerContent,
    });
  }
}
```

### 3. Property & Event Binding Overview

![](angular.assets/2019-11-18-23-49-15.png)

### 4. Binding to Custom Properties: @Input

Cách bắt dữ liệu từ Component khác
server-element.component.ts

```ts
import {
  OnInit,
  Input
} from '@angular/core';
// alias
@Input('srvElement') element: {type: string, name: string, content: string};
@Input() name: string;
```

app.component.html

```html
<app-server-element
  *ngFor="let serverElement of serverElements"
  [srvElement]="serverElement"
  [name]="serverElement.name"
>
</app-server-element>
```

### 5. Assigning an Alias to Custom Properties

### 6. Binding to Custom Events

How to inform app-component event emitted from cockpit
File app-component.html listen

```html
<app-cockpit
  (serverCreated)="onServerAdded($event)"
  (bpCreated)="onBlueprintAdded($event)"
></app-cockpit>
```

File app-component.ts

```ts
onServerAdded(serverData: {serverName: string, serverContent: string}) {
    this.serverElements.push({
      type: 'server',
      name: serverData.serverName,
      content: serverData.serverContent
    });
  }

  onBlueprintAdded(blueprintData: {serverName: string, serverContent: string}) {
    this.serverElements.push({
      type: 'blueprint',
      name: blueprintData.serverName,
      content: blueprintData.serverContent
    });
  }

```

Tại file cockpit.ts

```ts
@Output() serverCreated = new EventEmitter<{serverName: string, serverContent: string}>();
@Output('bpCreated') blueprintCreated = new EventEmitter<{serverName: string, serverContent: string}>();

onAddServer() {
    this.serverCreated.emit({
      serverName: this. newServerName,
      serverContent: this.newServerCOntent
    });
  }

  onAddBlueprint() {
    this.blueprintCreated.emit({
      serverName: this. newServerName,
      serverContent: this.newServerCOntent
    });
  }

```

![](angular.assets/2019-11-19-00-45-54.png)

### 7. Assigning an Alias to Custom Events

### 8. Custom Property and Event Binding Summary

### 9. Understanding View Encapsulation

app.component.css

```css
.container {
  margin-top: 30px;
}

p {
  color: blue;
}
```

**Only apply for elements of that component**
Shallow DOM is a technology that is not supported by all browsers where each element has own shallow DOM behind it, where you can assign styles to each element and that is the default behavior of view encapsulation in angular

### 10. More on View Encapsulation

server-element.ts

```ts
@Component({
  selector: 'app-server-element',
  templateUrl: './server-element.component.html',
  styleUrls: ['./server-element.component.css'],
  // add new
  encapsulation: ViewEncapsulation.Emulated // None, Native
})
export class ServerElementComponent
```

- **Emulated** là default nên bạn không cần add
- **None** có nghĩ là component này không sử dụng View encapsulation => effect all similar tag
- **Native** cũng như emaulated…

The other components still will use it, there you still see these attributes but if you now define any styles for this component in the CSS file of this component, they will actually get applied globally and I can demonstrate this by going into this CSS file and if I change the label color and the label is in the cockpit, not in this component, to red, now you will see the label there is overwritten whilst this label of course still has its custom unique attribute, it still is a label in the end and in this server element component, we disable encapsulation. So there our selectors aren't changed by Angular, they don't receive their unique selector, therefore they are enforced => **NONE**

Nếu thay đổi label của server-element cho màu đỏ thì apply all tag label của toàn bộ app và chỉ có component này không được thêm các class đặc biệt của angular

### 11. Using Local References in Templates

có thể sử dụng reference chỉ trong template
cockpit.component.html

```html
<div class="row">
  <div class="col-xs-12">
    <p>Add new Servers or blueprints!</p>
    <label>Server Name</label>
    <!--<input type="text" class="form-control" [(ngModel)]="newServerName">-->
    <input type="text" class="form-control" #serverNameInput />
    <label>Server Content</label>
    <!--<input type="text" class="form-control" [(ngModel)]="newServerContent">-->
    <input type="text" class="form-control" #serverContentInput />
    <br />
    <button class="btn btn-primary" (click)="onAddServer(serverNameInput)">
      Add Server
    </button>
    <button class="btn btn-primary" (click)="onAddBlueprint(serverNameInput)">
      Add Server Blueprint
    </button>
  </div>
</div>
```

cockpit.component.ts

```ts
  onAddServer(nameInput: HTMLInputElement) {
    this.serverCreated.emit({
      serverName: nameInput.value,
      serverContent: this.serverContentInput.nativeElement.value
    });
  }

  onAddBlueprint(nameInput: HTMLInputElement) {
    this.blueprintCreated.emit({
      serverName: nameInput.value,
      serverContent: this.serverContentInput.nativeElement.value
    });
  }
```

### 12. @ViewChild() in Angular 8.html

In Angular 8, the @ViewChild() syntax which you'll see in the next lecture needs to be changed slightly:

Instead of:

```ts
@ViewChild('serverContentInput') serverContentInput: ElementRef;

```

use

```ts
@ViewChild('serverContentInput', {static: true}) serverContentInput: ElementRef;

```

The same change (add { static: true } as a second argument) needs to be applied to ALL usages of @ViewChild() (and also @ContentChild() which you'll learn about later) IF you plan on **accessing the selected element inside of ngOnInit()**.

If you DON'T access the selected element in ngOnInit (but anywhere else in your component), set static: false instead!

This is a temporary adjustment which will NOT be required anymore once Angular 9 is released!

If you're using Angular 9, you only need to add `{ static: true }` (if needed) but not `{ static: false }`.

### 13. Getting Access to the Template & DOM with @ViewChild

```ts
@ViewChild('serverContentInput', { static: false }) serverContentInput: ElementRef;
```

True neu chúng ta sẽ sử dụng trong ngOnInit
Nên sử dụng string interpolation hay pro binding thay vì this.serverContentInput.nativeElement.value để gán giá trị output

### 14. Projecting Content into Components with ng-content

Khi muốn chuyển đoạn html bên dưới từ server-element ra ngoài app.component.html

```html
<app-server-element
  *ngFor="let serverElement of serverElements"
  [srvElement]="serverElement"
  [name]="serverElement.name"
>
  // add và thay serverElement để đổ data ra
  <p #contentParagraph>
    <strong *ngIf="serverElement.type === 'server'" style="color: red"
      >{{ serverElement.content }}</strong
    >
    <em *ngIf="serverElement.type === 'blueprint'"
      >{{ serverElement.content }}</em
    >
  </p>
</app-server-element>
```

Thay bằng tại server-element.component.html

```html
<ng-content></ng-content>
```

### 15. Understanding the Component Lifecycle

![img](angular.assets/2019-11-19-01-54-30.png)

ngOnInit will run after the constructor. Then we have ngDoCheck, that will also run multiple times, actually this method will be executed a lot because this will run whenever change detection runs.

Now change detection simply is the system by which Angular determines whether something changed on the

template of a component or inside of a component I should say, so whether it needs to change something in the template. So whether some property value changed from 1 to 2 let's say and that property is output in the template,

well of course Angular needs to re-render that part of the template and ngDoCheck is a hook executed

on every check Angular makes. Now important, on every check, so not just if something changed,

a lot of times ngDoCheck will run because you clicked some button which doesn't change anything

but still it's an event and on events, Angular has to check if something changed because how else would

it know?

server-element.component.ts

```ts
import {
  Component,
  OnInit,
  Input,
  ViewEncapsulation,
  OnChanges,
  SimpleChanges,
  DoCheck,
  AfterContentInit,
  AfterContentChecked,
  AfterViewInit,
  AfterViewChecked,
  OnDestroy,
  ViewChild,
  ElementRef,
  ContentChild,
} from '@angular/core';

@Component({
  selector: 'app-server-element',
  templateUrl: './server-element.component.html',
  styleUrls: ['./server-element.component.css'],
  encapsulation: ViewEncapsulation.Emulated, // None, Native
})
export class ServerElementComponent
  implements
    OnInit,
    OnChanges,
    DoCheck,
    AfterContentInit,
    AfterContentChecked,
    AfterViewInit,
    AfterViewChecked,
    OnDestroy {
  @Input('srvElement') element: { type: string; name: string; content: string };
  @Input() name: string;
  @ViewChild('heading', { static: true }) header: ElementRef;
  @ContentChild('contentParagraph', { static: true }) paragraph: ElementRef;

  constructor() {
    console.log('constructor called!');
  }

  ngOnChanges(changes: SimpleChanges) {
    console.log('ngOnChanges called!');
    console.log(changes);
  }

  ngOnInit() {
    console.log('ngOnInit called!');
    console.log('Text Content: ' + this.header.nativeElement.textContent);
    console.log(
      'Text Content of paragraph: ' + this.paragraph.nativeElement.textContent
    );
  }

  ngDoCheck() {
    console.log('ngDoCheck called!');
  }

  ngAfterContentInit() {
    console.log('ngAfterContentInit called!');
    console.log(
      'Text Content of paragraph: ' + this.paragraph.nativeElement.textContent
    );
  }

  ngAfterContentChecked() {
    console.log('ngAfterContentChecked called!');
  }

  ngAfterViewInit() {
    console.log('ngAfterViewInit called!');
    console.log('Text Content: ' + this.header.nativeElement.textContent);
  }

  ngAfterViewChecked() {
    console.log('ngAfterViewChecked called!');
  }

  ngOnDestroy() {
    console.log('ngOnDestroy called!');
  }
}
```

![image-20200608104558036](angular.assets/image-20200608104558036.png)

@Input('srvElement') element => in ra khi change

### 16. Seeing Lifecycle Hooks in Action

app.component.ts

```ts
onChangeFirst() {
    this.serverElements[0].name = 'Changed!';
  }
// O file server
console.log(changes);
In change have previous value



onDestroyFirst() {
    this.serverElements.splice(0, 1);
  }
```

app.component.html

```html
<!--Add button-->
<button class="btn btn-primary" (click)="onChangeFirst()">
  Change first Element
</button>
<!--Add name-->
<button class="btn btn-danger" (click)="onDestroyFirst()">
  Destroy first Component
</button>
<app-server-element
  *ngFor="let serverElement of serverElements"
  [srvElement]="serverElement"
  [name]="serverElement.name"
></app-server-element>
```

Sau khi click button onChangeFirst sẽ print object

![image-20200608105744127](angular.assets/image-20200608105744127.png)

DoCheck: Khi ấn nut change và sau đó ấn nút add

![image-20200608105716731](angular.assets/image-20200608105716731.png)

Ban đầu khi mới reload app thì doCHeck được gọi 2 lần nhưng nó chỉ có khi ở **dev mode**

So ngDoCheck as I told you gets called whenever Angular checks for any changes and there are a couple

of triggers which trigger this method and event was called by clicking or a promise gave us back

some data, so a lot of triggers for **ngDoCheck**.

So that is not something where you want to run amazingly powerful code in because that would cost you a

lot of performance but the fact that change detection runs as often as it does on its own is not a problem

and this can be a great hook if you want to check, if you do need to change something manually because

Angular didn't pick it up or something like that.

Constructor được gọi đầu tiên => change => onInit => do Check => @AfterContentInit

Now let's call this console log **ngAfterContentInit** called.

If we do this here, you will see that here it is, there it is called after do check and **it is called only once** because it doesn't get initialized again. Remember, content is the thing we projected into this through ng-content, so this here will be our content in the end.

AfterContentInit

![image-20200608110236459](angular.assets/image-20200608110236459.png)

Khi reload app

![image-20200608110519006](angular.assets/image-20200608110519006.png)

![image-20200608111158975](angular.assets/image-20200608111158975.png)

![image-20200608111300216](angular.assets/image-20200608111300216.png)

### 17. Lifecycle Hooks and Template Access

server-element.component.html
Add #heading

```html
<div class="panel-heading" #heading>{{ name }}</div>
```

server-element.component.ts

```ts
@ViewChild('heading', {static: true}) header: ElementRef;

  constructor() {
    console.log('constructor called!');
  }


  ngOnInit() {
    console.log('ngOnInit called!');
    // Add
    console.log('Text Content: ' + this.header.nativeElement.textContent);
  }


  ngAfterViewInit() {
    console.log('ngAfterViewInit called!');
    console.log('Text Content: ' + this.header.nativeElement.textContent);
  }
```

print value of Heading name

![image-20200608112204863](angular.assets/image-20200608112204863.png)

### 18. @ContentChild() in Angular 8.html

In Angular 8, the @ContentChild() syntax which you'll see in the next lecture needs to be changed slightly:

Instead of:

```ts
@ContentChild('contentParagraph') paragraph: ElementRef;
```

use

```ts
@ContentChild('contentParagraph', {static: true}) paragraph: ElementRef;

```

The same change (add { static: true } as a second argument) needs to be applied to ALL usages of @ContentChild() if you use the selected element inside of ngOnInit (as we do it in the lectures).

If you DON'T use the selected element in ngOnInit, set static: false instead.

### 19. Getting Access to ng-content with @ContentChild

Add contentParagraph
app.component.html

```html
<p #contentParagraph>
  <strong *ngIf="serverElement.type === 'server'" style="color: red"
    >{{ serverElement.content }}</strong
  >
  <em *ngIf="serverElement.type === 'blueprint'"
    >{{ serverElement.content }}</em
  >
</p>
```

server

```ts
  @ContentChild('contentParagraph', {static: true}) paragraph: ElementRef;

  ngOnInit() {
    console.log('ngOnInit called!');
    // Add
    console.log('Text Content: ' + this.header.nativeElement.textContent);
    console.log('Text Content of paragraph: ' + this.paragraph.nativeElement.textContent);
  }

ngAfterContentInit() {
    console.log('ngAfterContentInit called!');
    console.log('Text Content of paragraph: ' + this.paragraph.nativeElement.textContent);
  }
```

Sau AfterContentInit

![image-20200608112648262](angular.assets/image-20200608112648262.png)

### 20. Wrap Up

### 21. Practicing Property & Event Binding and View Encapsulation.html

### 22. [OPTIONAL] Assignment Solution

app.component.html

```html
<div class="row">
  <div class="col-xs-12">
    <app-game-control
      (intervalFired)="onIntervalFired($event)"
    ></app-game-control>
  </div>
</div>
<div class="row">
  <div class="col-xs-12">
    <app-odd
      *ngFor="let oddNumber of oddNumbers"
      [number]="oddNumber"
    ></app-odd>
    <app-even
      *ngFor="let evenNumber of evenNumbers"
      [number]="evenNumber"
    ></app-even>
  </div>
</div>
```

app.component.ts

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  oddNumbers: number[] = [];
  evenNumbers: number[] = [];

  onIntervalFired(firedNumber: number) {
    if (firedNumber % 2 === 0) {
      this.evenNumbers.push(firedNumber);
    } else {
      this.oddNumbers.push(firedNumber);
    }
  }
}
```

game-control.component.html

```html
<button class="btn btn-success" (click)="onStartGame()">Start Game</button>
<button class="btn btn-danger" (click)="onPauseGame()">Pause Game</button>
```

game-control.component.ts

```ts
import { Component, OnInit, EventEmitter, Output } from '@angular/core';

@Component({
  selector: 'app-game-control',
  templateUrl: './game-control.component.html',
  styleUrls: ['./game-control.component.css'],
})
export class GameControlComponent implements OnInit {
  @Output() intervalFired = new EventEmitter<number>();
  interval;
  lastNumber = 0;

  constructor() {}

  ngOnInit() {}

  onStartGame() {
    this.interval = setInterval(() => {
      this.intervalFired.emit(this.lastNumber + 1);
      this.lastNumber++;
    }, 1000);
  }

  onPauseGame() {
    clearInterval(this.interval);
  }
}
```

even.component.ts

```ts
import { Component, OnInit, Input } from '@angular/core';

@Component({
  selector: 'app-even',
  templateUrl: './even.component.html',
  styleUrls: ['./even.component.css'],
})
export class EvenComponent implements OnInit {
  @Input() number: number;

  constructor() {}

  ngOnInit() {}
}
```

![image-20200608113613167](angular.assets/image-20200608113613167.png)

## 6. Course Project - Components & Databinding

### 1. Introduction

### 2. Adding Navigation with Event Binding and ngIf

App shopping list and recipe hiển thị tùy loại khi bấm vào nav bar header
header.component.html bắt event click

```html
<ul class="nav navbar-nav">
  <li><a href="#" (click)="onSelect('recipe')">Recipes</a></li>
  <li><a href="#" (click)="onSelect('shopping-list')">Shopping List</a></li>
</ul>
```

header.component.ts

```ts
import { Component, EventEmitter, Output } from '@angular/core';

@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
})
export class HeaderComponent {
  @Output() featureSelected = new EventEmitter<string>();

  onSelect(feature: string) {
    this.featureSelected.emit(feature);
  }
}
```

app.component.html

```html
<app-header (featureSelected)="onNavigate($event)"></app-header>
<div class="container">
  <div class="row">
    <div class="col-md-12">
      <app-recipes *ngIf="loadedFeature === 'recipe'"></app-recipes>
      <app-shopping-list *ngIf="loadedFeature !== 'recipe'"></app-shopping-list>
    </div>
  </div>
</div>
```

app.component.ts

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  loadedFeature = 'recipe';

  onNavigate(feature: string) {
    this.loadedFeature = feature;
  }
}
```

![image-20200609082414085](angular.assets/image-20200609082414085.png)

![image-20200609082426350](angular.assets/image-20200609082426350.png)

### 3. Passing Recipe Data with Property Binding

Copy từ recipe-list sang recipe-item

```html
<a href="#" class="list-group-item clearfix" (click)="onSelected()">
  <div class="pull-left">
    <h4 class="list-group-item-heading">{{ recipe.name }}</h4>
    <p class="list-group-item-text">{{ recipe.description }}</p>
  </div>
  <span class="pull-right">
    <img
      [src]="recipe.imagePath"
      alt="{{ recipe.name }}"
      class="img-responsive"
      style="max-height: 50px;"
    />
  </span>
</a>
```

recipe-list.component.html

```html
<div class="col-xs-12">
  <app-recipe-item
    *ngFor="let recipeEl of recipes"
    [recipe]="recipeEl"
  ></app-recipe-item>
</div>
```

recipe-item.component.ts

```ts
 @Input() recipe: Recipe;

```

### 4. Passing Data with Event and Property Binding (Combined)

Khi click vào list thì recipe detail tương ứng sẽ được load
recipe-item.component.ts

```ts
  @Output() recipeSelected = new EventEmitter<void>();

  constructor() { }

  ngOnInit() {
  }

  onSelected() {
    this.recipeSelected.emit();
  }

```

recipe-list.component.html

```ts
<div class="col-xs-12">
    <app-recipe-item
      *ngFor="let recipeEl of recipes"
      [recipe]="recipeEl"
      (recipeSelected)="onRecipeSelected(recipeEl)"></app-recipe-item>
  </div>

```

recipe-list.component.ts

```ts
@Output() recipeWasSelected = new EventEmitter<Recipe>();


  onRecipeSelected(recipe: Recipe) {
   this.recipeWasSelected.emit(recipe);
  }


```

recipes.component.html

```html
<app-recipe-list
  (recipeWasSelected)="selectedRecipe = $event"
></app-recipe-list>
```

recipes.component.ts

```ts
export class RecipesComponent implements OnInit {
  selectedRecipe: Recipe;

  constructor() {}

  ngOnInit() {}
}
```

recipes.component.html

```html
<div class="col-md-7">
  <app-recipe-detail
    *ngIf="selectedRecipe; else infoText"
    [recipe]="selectedRecipe"
  ></app-recipe-detail>
  <ng-template #infoText>
    <p>Please select a Recipe!</p>
  </ng-template>
</div>
```

recipe-detail.component.ts

```ts
export class RecipeDetailComponent implements OnInit {
  @Input() recipe: Recipe;

  constructor() {}

  ngOnInit() {}
}
```

recipe-detail.component.html

```html
<div class="col-xs-12">
  <img
    [src]="recipe.imagePath"
    alt="{{ recipe.name }}"
    class="img-responsive"
    style="max-height: 300px;"
  />
</div>
```

### 5. Make sure you have FormsModule added!.html

In case you're hitting an error in the next lecture, make sure you have FormsModule added to your imports[] in the AppModule.

```ts
@NgModule({
  declarations: [
    AppComponent,
    HeaderComponent,
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    ShoppingListComponent,
    ShoppingEditComponent,
  ],
  imports: [BrowserModule, FormsModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

### 6. Allowing the User to Add Ingredients to the Shopping List

shopping-edit.component.html thêm local ref

```html
<div class="col-sm-5 form-group">
  <label for="name">Name</label>
  <input type="text" id="name" class="form-control" #nameInput /> // add
  #nameInput
</div>
<div class="col-sm-2 form-group">
  <label for="amount">Amount</label>
  <input type="number" id="amount" class="form-control" #amountInput />
</div>

<button class="btn btn-success" type="submit" (click)="onAddItem()">Add</button>
```

shopping-edit.component.ts

```ts
export class ShoppingEditComponent implements OnInit {
  @ViewChild('nameInput', { static: false }) nameInputRef: ElementRef;
  @ViewChild('amountInput', { static: false }) amountInputRef: ElementRef;
  @Output() ingredientAdded = new EventEmitter<Ingredient>();

  constructor() {}

  ngOnInit() {}

  onAddItem() {
    const ingName = this.nameInputRef.nativeElement.value;
    const ingAmount = this.amountInputRef.nativeElement.value;
    const newIngredient = new Ingredient(ingName, ingAmount);
    this.ingredientAdded.emit(newIngredient);
  }
}
```

shopping-list.component.html

```html
<app-shopping-edit
  (ingredientAdded)="onIngredientAdded($event)"
></app-shopping-edit>
<hr />
```

shopping-list.component.ts

```ts
onIngredientAdded(ingredient: Ingredient) {
    this.ingredients.push(ingredient);
  }
```

## 7. Directives Deep Dive

### 1. Module Introduction

![](angular.assets/2019-11-19-23-54-31.png)

### 2. ngFor and ngIf Recap

Chia làm 2 mảng số chẵn và số lẻ nếu true thì hiển thị mảng chẵn và ngược lại, dùng ngIf để kiểm tra điều kiện

```ts
export class AppComponent {
  // numbers = [1, 2, 3, 4, 5];
  oddNumbers = [1, 3, 5];
  evenNumbers = [2, 4];
  onlyOdd = false;
  value = 5;
}
```

```html
<button class="btn btn-primary" (click)="onlyOdd = !onlyOdd">
  Only show odd numbers
</button>
<!--<div *ngIf="!onlyOdd">-->
<!--<li-->
<!--class="list-group-item"-->
<!--[ngClass]="{odd: even % 2 !== 0}"-->
<!--[ngStyle]="{backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'}"-->
<!--*ngFor="let even of evenNumbers">-->
<!--{{ even }}-->
<!--</li>-->
<!--</div>-->
```

### 3. ngClass and ngStyle Recap

![image-20200609094756175](angular.assets/image-20200609094756175.png)

ấn toggle để test

### 4. Creating a Basic Attribute Directive

basic-highlight.directive.ts

```ts
import { Directive, ElementRef, OnInit } from '@angular/core';

@Directive({
  selector: '[appBasicHighlight]',
})
export class BasicHighlightDirective implements OnInit {
  // Auto inject value
  constructor(private elementRef: ElementRef) {}

  ngOnInit() {
    this.elementRef.nativeElement.style.backgroundColor = 'green';
  }
}
```

**Add to Module**

```ts
@NgModule({
  declarations: [
    AppComponent,
    // Add
    BasicHighlightDirective,
    BetterHighlightDirective,
    UnlessDirective,
  ],
  imports: [BrowserModule, FormsModule],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

file html

```html
<p appBasicHighlight>Style me with basic directive!</p>
```

Nhưng cách trên k tốt - access direct element is not good

### 5. Using the Renderer to build a Better Attribute Directive

This however is not the best way of changing that style because as you might recall from some earlier

lecture in this course, **accessing elements directly like this is not a good practice**,

you should use a different tool which I'll show you in a second because Angular actually is also able

to render your templates without a DOM and then these properties might not be available.

```ts
ng g d better-highlight

```

Vào module khai báo **BetterHighlightDirective**

```ts
constructor(private elRef: ElementRef, private renderer: Renderer2){ }

ngOnInit() {
    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'blue');
  }

```

Sau đó sửa lại html như phần 4

**Now why is it a better approach?**

Angular is not limited to running in the browser here, it for example also works with service workers

and these are environments where you might not have access to the DOM.

So if you try to change the DOM as you did here in basic highlight by directly accessing the native

element and the style of this element, **you might get an error in some circumstances.**

Now to be honest, in most circumstances you probably don't and you probably also know if your app is

going to run in the browser or not, still it is a better practice to use the renderer for DOM access and to use the methods the renderer provides to access the DOM.

### 6. More about the Renderer.html

In the last lecture, we used the Angular Renderer class to change the style of a HTML element. As explained in that lecture, you should use the Renderer for any DOM manipulations.

Of course, you can do more than simply change the styling of an element via setStyle(). Learn more about the available Renderer methods here.
https://angular.io/api/core/Renderer2

### 7. Using HostListener to Listen to Host Events

better-highlight.directive

```ts
  @HostListener('mouseenter') mouseover(eventData: Event) {
     this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'blue');
  }

  @HostListener('mouseleave') mouseleave(eventData: Event) {
    this.renderer.setStyle(this.elRef.nativeElement, 'background-color', 'transparent');
  }

```

### 8. Using HostBinding to Bind to Host Properties

```ts
  @HostBinding('style.backgroundColor') backgroundColor: string;

ngOnInit() {
    // add
    this.backgroundColor = this.defaultColor;
  }

  @HostListener('mouseenter') mouseover(eventData: Event) {
      // add
    this.backgroundColor = this.highlightColor;
  }

  @HostListener('mouseleave') mouseleave(eventData: Event) {
      // add
    this.backgroundColor = this.defaultColor;
  }

```

### 9. Binding to Directive Properties

```ts
@Input() defaultColor: string = 'transparent';
  @Input('appBetterHighlight') highlightColor: string = 'blue';

```

File html

```html
<p [appBetterHighlight]="'red'" defaultColor="yellow">---</p>

<p [appBetterHighlight]="'red'" [defaultColor]="'yellow'"></p>
```

Luu y: dau [], ''

### 10. What Happens behind the Scenes on Structural Directives

`*` => strutural directive
Dấu \* đại diện cho structural directive

Behind the scene thêm ng-template

```html
<!--<ng-template [ngIf]="!onlyOdd">-->
<!--<div>-->
<!--<li-->
<!--class="list-group-item"-->
<!--[ngClass]="{odd: even % 2 !== 0}"-->
<!--[ngStyle]="{backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'}"-->
<!--*ngFor="let even of evenNumbers">-->
<!--{{ even }}-->
<!--</li>-->
<!--</div>-->
<!--</ng-template>-->
```

### 11. Building a Structural Directive

it's just a setter of the property which is a method which gets executed whenever the property changes and it of course changes whenever it changes outside of this directive, so whenever the condition we pass changes or some parameter of this condition.

```ts
ng g d unless
----
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appUnless]'
})
export class UnlessDirective {
  @Input() set appUnless(condition: boolean) {
    if (!condition) {
      this.vcRef.createEmbeddedView(this.templateRef);
    } else {
      this.vcRef.clear();
    }
  }

  constructor(private templateRef: TemplateRef<any>, private vcRef: ViewContainerRef) { }

}

```

Phương thức setter của prop sẽ execute khi prop co bất kì thay đổi: `set appUnless`

Vào module khai báo **UnlessDirective**

File html

```html
<div *appUnless="onlyOdd">
  <li
    class="list-group-item"
    [ngClass]="{ odd: even % 2 !== 0 }"
    [ngStyle]="{
              backgroundColor: even % 2 !== 0 ? 'yellow' : 'transparent'
            }"
    *ngFor="let even of evenNumbers"
  >
    {{ even }}
  </li>
</div>
```

### 12. Understanding ngSwitch

```html
<div [ngSwitch]="value">
  <p *ngSwitchCase="5">Value is 5</p>
  <p *ngSwitchCase="10">Value is 10</p>
  <p *ngSwitchCase="100">Value is 100</p>
  <p *ngSwitchDefault>Value is Default</p>
</div>
```

## 8. Course Project - Directives

### 1. Building and Using a Dropdown Directive

Recipe book app
Vào folder share tạo file dropdown.directive.ts

```ts
import { Directive, HostListener, HostBinding } from '@angular/core';

@Directive({
  selector: '[appDropdown]',
})
export class DropdownDirective {
  @HostBinding('class.open') isOpen = false;

  @HostListener('click') toggleOpen() {
    this.isOpen = !this.isOpen;
  }
}
```

recipe-detail.component.html

```html
<div class="btn-group" appDropdown>
  <button type="button" class="btn btn-primary dropdown-toggle">
    Manage Recipe <span class="caret"></span>
  </button>
  <ul class="dropdown-menu">
    <li><a href="#">To Shopping List</a></li>
    <li><a href="#">Edit Recipe</a></li>
    <li><a href="#">Delete Recipe</a></li>
  </ul>
</div>
```

Nếu k dùng directive class="btn-group open" nó sẽ có khung bao và hiện lên

```ts
declarations: [
    DropdownDirective
  ],

```

Vào header thêm để show như recipe-detail

```html
<li class="dropdown" appDropdown></li>
```

thay class có sẵn là **open** = appDropdown

![image-20200609121203623](angular.assets/image-20200609121203623.png)

### 2. Closing the Dropdown From Anywhere.html

If you want that a dropdown can also be closed by a click anywhere outside (which also means that a click on one dropdown closes any other one, btw.), replace the code of dropdown.directive.ts by this one (placing the listener not on the dropdown, but on the document):

`import {Directive, ElementRef, HostBinding, HostListener} from '@angular/core';`

```ts
@Directive({
  selector: '[appDropdown]',
})
export class DropdownDirective {
  @HostBinding('class.open') isOpen = false;
  @HostListener('document:click', ['$event']) toggleOpen(event: Event) {
    this.isOpen = this.elRef.nativeElement.contains(event.target)
      ? !this.isOpen
      : false;
  }
  constructor(private elRef: ElementRef) {}
}
```

## 9. Using Services & Dependency Injection

### 1. Module Introduction

![](angular.assets/2019-11-20-22-57-59.png)

### 2. Why would you Need Services

account.component.html

```html
<div class="row">
  <div class="col-xs-12 col-md-8 col-md-offset-2">
    <h5>{{ account.name }}</h5>
    <hr />
    <p>This account is {{ account.status }}</p>
    <button class="btn btn-default" (click)="onSetTo('active')">
      Set to 'active'
    </button>
    <button class="btn btn-default" (click)="onSetTo('inactive')">
      Set to 'inactive'
    </button>
    <button class="btn btn-default" (click)="onSetTo('unknown')">
      Set to 'unknown'
    </button>
  </div>
</div>
```

account.component.ts

```ts
import { Component, EventEmitter, Input, Output } from '@angular/core';

@Component({
  selector: 'app-account',
  templateUrl: './account.component.html',
  styleUrls: ['./account.component.css'],
})
export class AccountComponent {
  @Input() account: { name: string; status: string };
  @Input() id: number;
  @Output() statusChanged = new EventEmitter<{
    id: number;
    newStatus: string;
  }>();

  onSetTo(status: string) {
    this.statusChanged.emit({ id: this.id, newStatus: status });
    console.log('A server status changed, new status: ' + status);
  }
}
```

app.component.html

```html
<div class="container">
  <div class="row">
    <div class="col-xs-12 col-md-8 col-md-offset-2">
      <app-new-account
        (accountAdded)="onAccountAdded($event)"
      ></app-new-account>
      <hr />
      <app-account
        *ngFor="let acc of accounts; let i = index"
        [account]="acc"
        [id]="i"
        (statusChanged)="onStatusChanged($event)"
      ></app-account>
    </div>
  </div>
</div>
```

app.component.ts

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  accounts = [
    {
      name: 'Master Account',
      status: 'active',
    },
    {
      name: 'Testaccount',
      status: 'inactive',
    },
    {
      name: 'Hidden Account',
      status: 'unknown',
    },
  ];

  onAccountAdded(newAccount: { name: string; status: string }) {
    this.accounts.push(newAccount);
  }

  onStatusChanged(updateInfo: { id: number; newStatus: string }) {
    this.accounts[updateInfo.id].status = updateInfo.newStatus;
  }
}
```

new-account.component.ts

```ts
export class NewAccountComponent {
  @Output() accountAdded = new EventEmitter<{ name: string; status: string }>();

  onCreateAccount(accountName: string, accountStatus: string) {
    this.accountAdded.emit({
      name: accountName,
      status: accountStatus,
    });
    console.log('A server status changed, new status: ' + accountStatus);
  }
}
```

App create account and log => not duplicate
Tạo file logging.service.ts

```ts
export class LoggingService {
  logStatusChange(status: string) {
    console.log('A server status changed, new status: ' + status);
  }
}
```

// sau đó import vào tạo instance bằng new sử dụng bt => cách sai in angular

![image-20200609122251587](angular.assets/image-20200609122251587.png)

### 3. Creating a Logging Service

Inform angular to require an instance => inject an instance to component

new-account.component

```ts
// Inject service
  constructor(private loggingService: LoggingService) {}

```

Khai báo để inform angular how to create

new-account.component

```ts
@Component({
  selector: 'app-account',
  templateUrl: './account.component.html',
  styleUrls: ['./account.component.css'],
  providers: [LoggingService]
})

```

Và gọi bằng cách

```ts
onCreateAccount(accountName: string, accountStatus: string) {
    this.loggingService.logStatusChange(accountStatus);
  }
```

### 4. Injecting the Logging Service into Components

Well a dependency is something a class of ours will depend on,

for example the new account component depends on the loggingService because we want to call a method

in that service and the dependency injector simply injects this dependency, injects an instance of this

class into our component automatically.

### 5. Creating a Data Service

accounts.service.ts

```ts
export class AccountsService {
  accounts = [
    {
      name: 'Master Account',
      status: 'active',
    },
    {
      name: 'Testaccount',
      status: 'inactive',
    },
    {
      name: 'Hidden Account',
      status: 'unknown',
    },
  ];
  constructor(private loggingService: LoggingService) {}

  addAccount(name: string, status: string) {
    this.accounts.push({ name: name, status: status });
    this.loggingService.logStatusChange(status);
  }

  updateStatus(id: number, status: string) {
    this.accounts[id].status = status;
    this.loggingService.logStatusChange(status);
  }
}
```

App.component.ts

```ts
import { Component, OnInit } from '@angular/core';

import { AccountsService } from './accounts.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
  providers: [AccountsService],
})
export class AppComponent implements OnInit {
  // add
  accounts: { name: string; status: string }[] = [];

  constructor(private accountsService: AccountsService) {}

  ngOnInit() {
    this.accounts = this.accountsService.accounts;
  }
}
```

app.component.html

```html
<div class="container">
  <div class="row">
    <div class="col-xs-12 col-md-8 col-md-offset-2">
      <app-new-account></app-new-account>
      <hr />
      <app-account
        *ngFor="let acc of accounts; let i = index"
        [account]="acc"
        [id]="i"
      ></app-account>
    </div>
  </div>
</div>
```

new-account.component.ts

```ts
@Component({
  selector: 'app-new-account',
  templateUrl: './new-account.component.html',
  styleUrls: ['./new-account.component.css'],
  providers: [LoggingService],
})
export class NewAccountComponent {
  constructor(
    private loggingService: LoggingService,
    private accountsService: AccountsService
  ) {}

  onCreateAccount(accountName: string, accountStatus: string) {
    // add
    this.accountsService.addAccount(accountName, accountStatus);
    // this.loggingService.logStatusChange(accountStatus);
  }
}
```

File account.component.ts

```ts
export class AccountComponent {
  @Input() account: { name: string; status: string };
  @Input() id: number;

  constructor(
    private loggingService: LoggingService,
    private accountsService: AccountsService
  ) {}

  onSetTo(status: string) {
    // add
    this.accountsService.updateStatus(this.id, status);
    this.loggingService.logStatusChange(status);
  }
}
```

### 6. Understanding the Hierarchical Injector

Service được cung cấp cho 1 component và tất cả các con của nó => the same instance

![](angular.assets/2019-11-21-00-06-50.png)

If we provide a service there, **the app module** does have a providers array, the same instance and that's important, the same instance of the class, of the service is available in our whole app, in all components, in all

directives, in all other services where we maybe inject the service. Yes, we can inject services into services,

I'll come back to this. The next level for example would be the app component, there the app component and

all its child components do have the same instance of the service and this is true for any component,

so even if we have a child of the app component, if we provide it on that child, all the children of this

child will have the same instance and the child itself but not the app component.

### 7. How many Instances of Service Should It Be

Khi sử dụng providers thì nó sẽ k hoạt động như mong muốn => many instance
Nếu new-account component khai báo instance mới nó sẽ override instance được khai báo trong app-component => muốn có 1 instance thì chỉ cần khai báo trong app-component

### 8. Injecting Services into Services

app.module.ts

```ts
@NgModule({
  declarations: [
    AppComponent,
    AccountComponent,
    NewAccountComponent
  ],
  imports: [
    BrowserModule,
    FormsModule,
  ],
  // Add
  providers: [AccountsService, LoggingService],
  bootstrap: [AppComponent]
})

```

accounts.service.ts thêm:

```ts
  constructor(private loggingService: LoggingService) {}

// ADD
@Injectable()
export class AccountsService

```

Thông báo service is injectable or something is can be injected in there => inject service into another service

### 9. Using Services for Cross-Component Communication

app.component.html xóa event add account đi trọng 2 thẻ

```html
<app-new-account></app-new-account>
<hr />
<app-account
  *ngFor="let acc of accounts; let i = index"
  [account]="acc"
  [id]="i"
></app-account>
```

account.service.ts

```ts
statusUpdated = new EventEmitter<string>();
```

account.component.ts

```ts
onSetTo(status: string) {
    this.accountsService.updateStatus(this.id, status);
    // this.loggingService.logStatusChange(status);
    this.accountsService.statusUpdated.emit(status);
  }

```

new-account.component.ts

```ts
constructor(private loggingService: LoggingService,
              private accountsService: AccountsService) {
    this.accountsService.statusUpdated.subscribe(
      (status: string) => alert('New Status: ' + status)
    );
  }

```

khi bấm change status thì nó sẽ alert and update luôn acc

### 10. Practicing Services.html

### 11. [OPTIONAL] Assignment Solution

counter.service.ts

```ts
export class CounterService {
  activeToInactiveCounter = 0;
  inactiveToActiveCounter = 0;

  incrementActiveToInactive() {
    this.activeToInactiveCounter++;
    console.log('Active to Inactive: ' + this.activeToInactiveCounter);
  }

  incrementInActiveToActive() {
    this.inactiveToActiveCounter++;
    console.log('Inactive to Active: ' + this.inactiveToActiveCounter);
  }
}
```

users.service.ts

```ts
import { Injectable } from '@angular/core';

import { CounterService } from './counter.service';

@Injectable()
export class UserService {
  activeUsers = ['Max', 'Anna'];
  inactiveUsers = ['Chris', 'Manu'];

  constructor(private counterService: CounterService) {}

  setToActive(id: number) {
    this.activeUsers.push(this.inactiveUsers[id]);
    this.inactiveUsers.splice(id, 1);
    this.counterService.incrementInActiveToActive();
  }

  setToInactive(id: number) {
    this.inactiveUsers.push(this.activeUsers[id]);
    this.activeUsers.splice(id, 1);
    this.counterService.incrementActiveToInactive();
  }
}
```

active-users.component

```ts
export class ActiveUsersComponent implements OnInit {
  users: string[];

  // add
  constructor(private userService: UserService) {}

  ngOnInit() {
    // add
    this.users = this.userService.activeUsers;
  }

  onSetToInactive(id: number) {
    this.userService.setToInactive(id);
  }
}
```

Nhớ khai báo providers: [UserService] in AppComponent

![image-20200609154044546](angular.assets/image-20200609154044546.png)

Khai báo CounterService in app.modules

### 12. Services in Angular 6+.html

If you're using **Angular 6+** (check your `package.json` to find out), you can provide application-wide services in a different way.

Instead of adding a service class to the `providers[]` array in `AppModule` , you can set the following config in `@Injectable()` :

```ts
@Injectable({providedIn: 'root'})
export class MyService { ... }

// This is exactly the same as:

export class MyService { ... }
and

import { MyService } from './path/to/my.service';

@NgModule({
    ...
    providers: [MyService]
})
export class AppModule { ... }

```

Using this new syntax is **completely optional**, the traditional syntax (using `providers[]` ) will still work. The "new syntax" does offer one advantage though: Services **can be loaded lazily** by Angular (behind the scenes) and redundant code can be removed automatically. This can lead to a better performance and loading speed - though this really only kicks in for bigger services and apps in general.

## 10. Course Project - Services & Dependency Injection

### 1. Introduction

Which services do we need?

Let's have a look at our application again, this is the application the way it looks right now.

Now services allow us to centralize tasks, manage data in a central place and so on.

So we probably need a service for both feature areas, we will need a shopping list service and a recipe service. The shopping list service managing our shopping list and we will also access it from the recipe area because we want to add items to the shopping list from there and well the recipe service, that will be responsible for managing our recipe, managing the data there and so on.

### 2. Setting up the Services

Tạo file recipe.service.ts và shopping-list.service.ts trong folder tương ứng

### 3. Managing Recipes in a Recipe Service

recipe.service.ts

```ts
import { EventEmitter, Injectable } from '@angular/core';

import { Recipe } from './recipe.model';
import { Ingredient } from '../shared/ingredient.model';
import { ShoppingListService } from '../shopping-list/shopping-list.service';

@Injectable()
export class RecipeService {
  private recipes: Recipe[] = [
    new Recipe(
      'A Test Recipe',
      'This is simply a test',
      'https://upload.wikimedia.org/wikipedia/commons/1/15/Recipe_logo.jpeg'
    ),
    new Recipe(
      'Another Test Recipe',
      'This is simply a test',
      'https://upload.wikimedia.org/wikipedia/commons/1/15/Recipe_logo.jpeg'
    ),
  ];

  getRecipes() {
    return this.recipes.slice(); // trả về mảng mới copy lại
  }
}
```

recipes.component.ts vì truy cập service chỉ trong phần này

```ts
@Component({
  selector: "app-recipes",
  templateUrl: "./recipes.component.html",
  styleUrls: ["./recipes.component.css"],
  providers: [RecipeService]
})
```

---

recipe-list.component.ts

```ts
// thêm constructor và vào hàm init thêm
export class RecipeListComponent implements OnInit {
  recipes: Recipe[];

  constructor(private recipeService: RecipeService) {}

  ngOnInit() {
    this.recipes = this.recipeService.getRecipes();
  }
}
```

### 4. Using a Service for Cross-Component Communication

Khi nhấn vào item ở trong list thì detail được update
recipe.service.ts

```ts
recipeSelected = new EventEmitter<Recipe>();
```

recipe-item.component.ts

```ts
export class RecipeItemComponent implements OnInit {
  @Input() recipe: Recipe;

  constructor(private recipeService: RecipeService) {} // add

  ngOnInit() {}

  onSelected() {
    this.recipeService.recipeSelected.emit(this.recipe); // add
  }
}
```

Xóa hàm onRecipeSelected ở file recipe-list.component.html

```html
<app-recipe-item
  *ngFor="let recipeEl of recipes"
  [recipe]="recipeEl"
  (recipeSelected)="onRecipeSelected(recipeEl)" // delete
></app-recipe-item>
```

recipe-list.component.ts xóa những thứ k cần thiết

```ts
export class RecipeListComponent implements OnInit {
  recipes: Recipe[];

  constructor(private recipeService: RecipeService) {}

  ngOnInit() {
    this.recipes = this.recipeService.getRecipes();
  }
}
```

Xóa event tròn file recipeWasSelected ở recipes.component.html

```html
<app-recipe-list
  (recipeWasSelected)="selectedRecipe = $event"
></app-recipe-list>
```

recipes.component.ts

```ts
export class RecipesComponent implements OnInit {
  selectedRecipe: Recipe;

  constructor(private recipeService: RecipeService) {} // add

  ngOnInit() {
    this.recipeService.recipeSelected.subscribe((recipe: Recipe) => {
      this.selectedRecipe = recipe;
    });
  }
}
```

### 5. Adding the Shopping List Service

shopping-list.service.ts

```ts
import { Ingredient } from '../shared/ingredient.model';
import { EventEmitter } from '@angular/core';

export class ShoppingListService {
  ingredientsChanged = new EventEmitter<Ingredient[]>();
  private ingredients: Ingredient[] = [
    new Ingredient('Apples', 5),
    new Ingredient('Tomatoes', 10),
  ];

  getIngredients() {
    return this.ingredients.slice();
  }
}
```

Vào app-modules khai báo service

```ts
providers: [ShoppingListService],

```

we can provide it here in the shopping list component and therefore it would also be available in the

shopping edit component but actually later I also want to access it from my recipe section.

That is why I will actually **provide it in app module** and here, I will add it to this providers array therefore, shopping

list service.

shopping-list.component.ts

```ts
export class ShoppingListComponent implements OnInit {
  ingredients: Ingredient[];

  constructor(private slService: ShoppingListService) {} // inject

  ngOnInit() {
    this.ingredients = this.slService.getIngredients();
  }
}
```

Vào service thêm

```ts
// add
ingredientsChanged = new EventEmitter<Ingredient[]>();

addIngredient(ingredient: Ingredient) {
    this.ingredients.push(ingredient);
    this.ingredientsChanged.emit(this.ingredients.slice());
  }

```

Vào xóa sự kiện emit trong file shopping-edit.component.ts

```ts
// Xóa
 // @Output() ingredientAdded = new EventEmitter<Ingredient>();

 // chuyển thành
  constructor(private slService: ShoppingListService) { }

  onAddItem() {
    const ingName = this.nameInputRef.nativeElement.value;
    const ingAmount = this.amountInputRef.nativeElement.value;
    const newIngredient = new Ingredient(ingName, ingAmount);
    this.slService.addIngredient(newIngredient);
   // this.ingredientAdded.emit(newIngredient); // xóa
  }

```

Vào file shopping-list xóa hàm onIngredientAdded

```html
// Xóa (ingredientAdded)="onIngredientAdded($event)"
<app-shopping-edit
 (ingredientAdded)="onIngredientAdded($event)" // delete
></app-shopping-edit>
```

### 6. Using Services for Pushing Data from A to B

Khi ấn vào k add được vì lúc trả về là array copy

Vào service tạo

shopping-list.service.ts

```ts
  ingredientsChanged = new EventEmitter<Ingredient[]>();

  addIngredient(ingredients: Ingredient[]) {
    this.ingredients.push(...ingredients);
    // add
    this.ingredientsChanged.emit(this.ingredients.slice());
  }

```

Sửa lại hàm trong file shopping-list.component.ts

```ts
ngOnInit() {
    this.ingredients = this.slService.getIngredients();
    this.slService.ingredientsChanged
      .subscribe(
        (ingredients: Ingredient[]) => {
          this.ingredients = ingredients;
        }
      );
  }

```

### 7. Adding Ingredients to Recipes

Make To shopping list work
Cập nhật model Recipe

```ts
export class Recipe {
  public name: string;
  public description: string;
  public imagePath: string;
  // add
  public ingredients: Ingredient[];
}
```

Cập nhật lại service

```ts
private recipes: Recipe[] = [
    new Recipe(
      'Tasty Schnitzel',
      'A super-tasty Schnitzel - just awesome!',
      'https://upload.wikimedia.org/wikipedia/commons/7/72/Schnitzel.JPG',
      [
        new Ingredient('Meat', 1),
        new Ingredient('French Fries', 20)
      ]),
    new Recipe('Big Fat Burger',
      'What else you need to say?',
      'https://upload.wikimedia.org/wikipedia/commons/b/be/Burger_King_Angus_Bacon_%26_Cheese_Steak_Burger.jpg',
      [
        new Ingredient('Buns', 2),
        new Ingredient('Meat', 1)
      ])
  ];

```

recipe-detail.component.html thêm đoạn output ingredients

```html
<div class="row">
  <div class="col-xs-12">
    // Add
    <ul class="list-group">
      <li class="list-group-item" *ngFor="let ingredient of recipe.ingredients">
        {{ ingredient.name }} - {{ ingredient.amount }}
      </li>
    </ul>
  </div>
</div>
```

![image-20200609161303634](angular.assets/image-20200609161303634.png)

### 8. Passing Ingredients from Recipes to the Shopping List (via a Service)

modify button To shopping list

recipe-detail.component.html

```html
<ul class="dropdown-menu">
  <!-- add -->
  <li>
    <a (click)="onAddToShoppingList()" style="cursor: pointer;"
      >To Shopping List</a
    >
  </li>
  <li><a href="#">Edit Recipe</a></li>
  <li><a href="#">Delete Recipe</a></li>
</ul>
```

recipe-detail.component.ts

```ts
constructor(private recipeService: RecipeService) { }

onAddToShoppingList() {
    this.recipeService.addIngredientsToShoppingList(this.recipe.ingredients);
  }

```

recipe.service.ts

```ts
	constructor(private slService: ShoppingListService) {}

	// add
  addIngredientsToShoppingList(ingredients: Ingredient[]) {
    this.slService.addIngredients(ingredients);
  }

```

Nhớ thêm @Injectable() cho recipe.service.ts

shopping-list.service.ts

```ts
addIngredients(ingredients: Ingredient[]) {
    // for (let ingredient of ingredients) {
    //   this.addIngredient(ingredient);
    // }
    // es6
    this.ingredients.push(...ingredients);
    this.ingredientsChanged.emit(this.ingredients.slice());
  }

```

## 11. Changing Pages with Routing

### 1. Module Introduction

![](angular.assets/2019-11-22-00-33-37.png)

### 3. Understanding the Example Project.html

In our app, we got three sections:

- Home
- Servers
  - View and Edit Servers
  - A Service is used to load and update Servers
- Users
- View Users
  This app will be improved by adding routing but definitely feel free to play around with it - besides routing, everything should be working fine.

### 4. Setting up and Loading Routes

App.module.ts

```ts
import { Routes, RouterModule } from '@angular/router';

const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'users', component: UsersComponent },
  { path: 'servers', component: ServersComponent },
];

// và phải khai báo
imports: [
  BrowserModule,
  FormsModule,
  // add
  RouterModule.forRoot(appRoutes),
];
```

app.component.html

```html
<div class="row">
  <div class="col-xs-12 col-sm-10 col-md-8 col-sm-offset-1 col-md-offset-2">
    <router-outlet></router-outlet>
  </div>
</div>
```

### 5. Navigating with Router Links

Khi thay /servers sẽ load lại => issue

```html
<li role="presentation"><a href="/servers">Servers</a></li>
```

App.component.html sử dụng routerLink

```html
<li role="presentation"
          <a routerLink="/">Home</a>
        </li>
        <li role="presentation">
          <a routerLink="servers">Servers</a>
        </li>
        <li role="presentation"\>
          <a [routerLink]="['users']">Users</a>
        </li>

```

### 6. Understanding Navigation Paths

So if we go to servers here, we see the reload page here and if I click it, you'll see we got an error. This

error here occurs because it doesn't find a route which is servers/servers.

Now this error won't occur if on the servers component, I turn this to /servers,

so to an absolute path, it was a relative path. Here

if we now have our console still open and I click reload page, nothing occurs here, nothing, no error occurs

because now it simply navigates to localhost:4200/servers

as you can see down there and if we turn this back to a relative path, the difference was that now

it tries to go /servers/servers.

So with a relative path, it always append the path you specify in the routerLink to the end of your current

path

`routerLink="servers"` là relative path sẽ append thêm vào url

![image-20200628214050833](angular.assets/image-20200628214050833.png)

Khi ấn vào reload sẽ báo lỗi vì /server/server k tìm thấy

![image-20200628214248596](angular.assets/image-20200628214248596.png)

Tại file servers.component.html

```ts
routerLink="/servers" // phải có dấu / mới load được vì nó là absolute path
./servers currently path
../servers go up a level

```

### 7. Styling Active Router Links

active is a class css có sẵn
app.component.html

```html
<ul class="nav nav-tabs">
  <li
    role="presentation"
    routerLinkActive="active"
    [routerLinkActiveOptions]="{exact: true}"
  >
    <a routerLink="/">Home</a>
  </li>
  <li role="presentation" routerLinkActive="active">
    <a routerLink="servers">Servers</a>
  </li>
  <li role="presentation" routerLinkActive="active">
    <a [routerLink]="['users']">Users</a>
  </li>
</ul>

[routerLinkActiveOptions]="{exact: true} tránh lúc nào cũng được active ở tab
HOME vì nó kiểm tra nếu url có chứa thì sẽ active nên cần them cái này
```

### 8. Navigating Programmatically

home.component.html

```html
<button class="btn btn-primary" (click)="onLoadServer(1)">Load Server 1</button>
```

File home.component.ts

```ts
export class HomeComponent implements OnInit {
  constructor(private router: Router) {} // inject

  onLoadServer(id: number) {
    // complex calculation
    this.router.navigate(['/servers']);
  }
}
```

### 9. Using Relative Paths in Programmatic Navigation

the **navigate method doesn't know on which route you are currently** on, so to say. The **routerLink** always knows in which component it sits, in which components template and therefore it knows what the currently loaded route is.

Now you could argue that here we also call this inside the component TypeScript code, so it could determine where it is in but it's just not how it works.

servers.component.html

```html
<button class="btn btn-primary" (click)="onReload()">Reload Page</button>
```

Servers.component.ts

```ts
constructor(private serversService: ServersService,
              private router: Router
) { }

  onReload() {
    this.router.navigate(['servers']);
  }

```

Navigate method doesn’t know route you are currently on is different routerLink
Nếu muốn biết route mà bạn đang ở đó thì SD:

```ts
constructor(private serversService: ServersService,
              private router: Router,
              private route: ActivatedRoute) {
  }

// this.router.navigate(['servers'], {relativeTo: this.route}); // /servers/servers => error
this.router.navigate(['servers']);
```

### 10. Passing Parameters to Routes

app.modules.ts

```ts
{ path: "users/:id", component: UsersComponent },
```

### 11. Fetching Route Parameters

user.component.ts

```ts
constructor(private route: ActivatedRoute) { } // inject

  ngOnInit() {
    this.user = {
      id: this.route.snapshot.params['id']
    };
  }

```

### 12. Fetching Route Parameters Reactively

user.component.html

```html
<p>User with ID {{ user.id }} loaded.</p>
<p>User name is {{ user.name }}</p>
<hr />
<a [routerLink]="['/users', 10, 'Anna']">Load Anna (10)</a>
```

**Khi ở trang này bấm vào sẽ không cập nhật được data, Bởi vì ta đang ở trên component mà mình định load nên angular sẽ k tạo ra instance mới**

user.component.ts

```ts
import { ActivatedRoute, Params } from '@angular/router';

export class UserComponent implements OnInit, OnDestroy {
  user: { id: number; name: string };
  paramsSubscription: Subscription;

  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    this.user = {
      id: this.route.snapshot.params['id'],
      name: this.route.snapshot.params['name'],
    };
    // add
    this.paramsSubscription = this.route.params.subscribe((params: Params) => {
      this.user.id = params['id'];
      this.user.name = params['name'];
    });
  }

  ngOnDestroy() {
    this.paramsSubscription.unsubscribe();
  }
}
```

**Observable is an easy way to subscribe to some event may happen in the future, async** => should wait
Param is an observable

Params here is an observable and now observables is something I will come to right after this section

where we will take a closer look.

Basically, observables are a feature added by some other third-party package, not by Angular but heavily

used by Angular which allow you to easily work with asynchronous tasks and this is an asynchronous task because the parameters of your currently loaded route might change at some point in the future if the user clicks this link but you don't know when, you didn't know if and you don't know how long it will take.

So therefore, you can't block your code and wait for this to happen here because it might never happen.

So an observable is an easy way to subscribe to some event which might happen in the future, to then execute

some code when it happens without having to wait for it now and that is what params is. It is such an observable and as the name implies, we can observe it and we

do so by subscribing to it.

So you can call the subscribe method on it and this is still called on params,

### 13. An Important Note about Route Observables

Well once you left, this component will be destroyed and when you come back, a new one will be created but this subscription here will always live on in memory because it's not closely tied to your component, so if the component is destroyed, the subscription won't. Now it will be here because Angular handles this

destroying of the subscription for you

Must unsubscribe when destroy Component

```ts
// Add
paramsSubscription: Subscription;

ngOnInit() {
    this.user = {
      id: this.route.snapshot.params['id'],
      name: this.route.snapshot.params['name']
    };
    this.paramsSubscription = this.route.params
      .subscribe(
        (params: Params) => {
          this.user.id = params['id'];
          this.user.name = params['name'];
        }
      );
  }
// Add
ngOnDestroy() {
    this.paramsSubscription.unsubscribe();
  }

```

### 14. Passing Query Parameters and Fragments

```ts
  { path: "servers/:id/edit", component: EditServersComponent }

```

servers.component.html

```html
<a
  [routerLink]="['/servers', 5, 'edit']"
  [queryParams]="{allowEdit: server.id === 3 ? '1' : '0'}"
  fragment="loading"
  href="#"
  class="list-group-item"
  *ngFor="let server of servers"
>
  {{ server.name }}
</a>
```

Modify button Load server

home.component.html

```html
<button (click)="onLoadServer(1)">Load server 1<button></button></button>
```

home.component.ts

```ts
onLoadServer(id: number) {
    // complex calculation
    this.router.navigate(['/servers', id, 'edit'], {queryParams: {allowEdit: '1'}, fragment: 'loading'});
  }

```

Localhost:4200/servers/5/edit?allowEdit=3#loading

### 15. Retrieving Query Parameters and Fragments

edit-server.component.ts

```ts
constructor(private serversService: ServersService,
              private route: ActivatedRoute, // add
              private router: Router) {
  }

  ngOnInit() {
    // 2 cách để access query params, only access when component create
    console.log(this.route.snapshot.queryParams);
    console.log(this.route.snapshot.fragment);
    this.route.queryParams
      .subscribe(
        (queryParams: Params) => {
          this.allowEdit = queryParams['allowEdit'] === '1' ? true : false;
        }
      );
    this.route.fragment.subscribe();
    const id = +this.route.snapshot.params['id'];
    this.server = this.serversService.getServer(id);
    // Subscribe route params to update the id if params change
    this.serverName = this.server.name;
    this.serverStatus = this.server.status;
  }

```

You **don't need to unsubscribe** here, Angular will handle it for you just like it did for params but this is how you can now get access to these extra features and how you can make sure that you don't miss

### 16. Practicing and some Common Gotchas

users.component.html thêm

```html
<a
  [routerLink]="['/users', user.id, user.name]"
  href="#"
  class="list-group-item"
  *ngFor="let user of users"
>
  {{ user.name }}
</a>
```

fix to only load **ServerComponent**

servers.component.html

```html
<a
  [routerLink]="['/servers', server.id]"
  [queryParams]="{allowEdit: server.id === 3 ? '1' : '0'}"
  fragment="loading"
  href="#"
  class="list-group-item"
  *ngFor="let server of servers"
>
  {{ server.name }}
</a>
```

Server.component.ts

```ts
  constructor(private serversService: ServersService,
              private route: ActivatedRoute, // add
              private router: Router) {
  }

  ngOnInit() {
    // lấy tham số từ /user/:id khi click
    const id = +this.route.snapshot.params['id'];
     this.server = this.serversService.getServer(id);
     this.route.params
       .subscribe(
         (params: Params) => {
           this.server = this.serversService.getServer(+params['id']);
         }
       );
  }

```

Comment servers.component.html because of error khi chưa có id

```html
<!-- <app-server></app-server> -->
```

### 17. Setting up Child (Nested) Routes

servers.component.html

```html
<div class="col-xs-12 col-sm-4">
  // add
  <router-outlet></router-outlet>
  // comment
  <!--<button class="btn btn-primary" (click)="onReload()">Reload Page</button>-->
  <!--<app-edit-server></app-edit-server>-->
  <!--<hr>-->
  <!--&lt;!&ndash;<app-server></app-server>&ndash;&gt;-->
</div>
```

```ts
const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users',
    component: UsersComponent,
    children: [{ path: ':id/:name', component: UserComponent }],
  },
  {
    path: 'servers',
    component: ServersComponent,
    children: [
      { path: ':id', component: ServerComponent },
      { path: ':id/edit', component: EditServerComponent },
    ],
  },
];
```

users.component.html

```html
<div class="col-xs-12 col-sm-4">
  <!--<app-user></app-user>-->
  <router-outlet></router-outlet>
</div>
```

![image-20200609222917591](angular.assets/image-20200609222917591.png)

### 18. Using Query Parameters - Practice

server.component.html

```html
<h5>{{ server.name }}</h5>
<p>Server status is {{ server.status }}</p>
<button class="btn btn-primary" (click)="onEdit()">Edit Server</button>
```

server.component.ts

```ts
onEdit() {
    this.router.navigate(['edit'], {relativeTo: this.route, queryParamsHandling: 'preserve'});
  }

```

relativeTo: this.route load đường dẫn hiện tại thêm /edit vào

edit-server.component.ts

```ts
this.route.queryParams.subscribe((queryParams: Params) => {
  this.allowEdit = queryParams['allowEdit'] === '1' ? true : false;
});
```

edit-server.component.html

```html
<h4 *ngIf="!allowEdit">You're not allowed to edit!</h4>
<div *ngIf="allowEdit"></div>
```

![image-20200609234204378](angular.assets/image-20200609234204378.png)

Khi ấn vào edit btn

### 19. Configuring the Handling of Query Parameters

server.component.ts
Fix params bị mất khi ấn vào Link ở list server rồi ấn vào button Edit server thêm `queryParamsHandling: 'preserve'`
queryParamsHandling : 'merge'

Now query params handling takes a string as a value and this could be merge, to merge our old query params

with any new we might add here. Now we don't add any new ones, so we can simply choose preserve instead and preserve which will overwrite the default behavior which is to simply drop them and make sure that the old ones are kept.

![image-20200628222433865](angular.assets/image-20200628222433865.png)

allowEdit khi vào page Server vẫn được giữ nguyên qua edit server page

### 20. Redirecting and Wildcard Routes

Tạo component page not found để url sai sẽ vào đây
{ path: "not-found", component: PageNotFoundComponent },
{ path: '\*\*', redirectTo: '/not-found' } // phải để cuối cùng

### 21. Important Redirection Path Matching.html

In our example, we didn't encounter any issues when we tried to redirect the user. But that's not always the case when adding redirections.

By default, Angular matches paths by prefix. That means, that the following route will match both /recipes and just /

```ts
{ path: '', redirectTo: '/somewhere-else' }

```

Actually, Angular will give you an error here, because that's a common gotcha: This route will now ALWAYS redirect you! Why?

Since the default matching strategy is "prefix" , Angular checks if the path you entered in the URL does start with the path specified in the route. Of course every path starts with '' (Important: That's no whitespace, it's simply "nothing").

To fix this behavior, you need to change the matching strategy to "full" :

```ts
{ path: '', redirectTo: '/somewhere-else', pathMatch: 'full' }

```

Now, you only get redirected, if the full path is '' (so only if you got NO other content in your path in this example).

### 22. Outsourcing the Route Configuration

Tạo file app-routing.module.ts

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { PageNotFoundComponent } from './page-not-found/page-not-found.component';
import { EditServerComponent } from './servers/edit-server/edit-server.component';
import { ServerComponent } from './servers/server/server.component';
import { ServersComponent } from './servers/servers.component';
import { UserComponent } from './users/user/user.component';
import { UsersComponent } from './users/users.component';
import { HomeComponent } from './home/home.component';
import { AuthGuard } from './auth-guard.service';
import { CanDeactivateGuard } from './servers/edit-server/can-deactivate-guard.service';
import { ErrorPageComponent } from './error-page/error-page.component';
import { ServerResolver } from './servers/server/server-resolver.service';

const appRoutes: Routes = [
  { path: '', component: HomeComponent },
  {
    path: 'users',
    component: UsersComponent,
    children: [{ path: ':id/:name', component: UserComponent }],
  },
  {
    path: 'servers',
    // canActivate: [AuthGuard],
    canActivateChild: [AuthGuard],
    component: ServersComponent,
    children: [
      {
        path: ':id',
        component: ServerComponent,
        resolve: { server: ServerResolver },
      },
      {
        path: ':id/edit',
        component: EditServerComponent,
        canDeactivate: [CanDeactivateGuard],
      },
    ],
  },
  // { path: 'not-found', component: PageNotFoundComponent },
  {
    path: 'not-found',
    component: ErrorPageComponent,
    data: { message: 'Page not found!' },
  },
  { path: '**', redirectTo: '/not-found' },
];

@NgModule({
  imports: [
    // RouterModule.forRoot(appRoutes, {useHash: true})
    RouterModule.forRoot(appRoutes),
  ],
  exports: [RouterModule],
})
export class AppRoutingModule {}
```

Module

```ts
imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule
  ],


```

### 23. An Introduction to Guards

### 24. Protecting Routes with canActivate

Tạo file auth-guard.service.ts
we will define that angular will execute this code before a route is loaded

```ts
canActivate(route: ActivatedRouteSnapshot,
              state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean

```

return về Observable, run asynchronously
auth.service.ts

```ts
export class AuthService {
  loggedIn = false;

  isAuthenticated() {
    const promise = new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve(this.loggedIn);
      }, 800);
    });
    return promise;
  }

  login() {
    this.loggedIn = true;
  }

  logout() {
    this.loggedIn = false;
  }
}
```

Thêm Injectable và constructor

auth-guard.service.ts

```ts
import {
  CanActivate,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
  Router,
  CanActivateChild,
} from '@angular/router';
import { Observable } from 'rxjs/Observable';
import { Injectable } from '@angular/core';

import { AuthService } from './auth.service';

@Injectable()
export class AuthGuard implements CanActivate, CanActivateChild {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<boolean> | Promise<boolean> | boolean {
    return this.authService.isAuthenticated().then((authenticated: boolean) => {
      if (authenticated) {
        return true;
      } else {
        this.router.navigate(['/']);
      }
    });
  }

  canActivateChild(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<boolean> | Promise<boolean> | boolean {
    return this.canActivate(route, state);
  }
}
```

Vào app-routing.module thêm canActivate

```ts
{
    path: 'servers',
    // Add
    canActivate: [AuthGuard],
    // canActivateChild: [AuthGuard],
    component: ServersComponent,
    children: [
    { path: ':id', component: ServerComponent, resolve: {server: ServerResolver} },
    { path: ':id/edit', component: EditServerComponent, canDeactivate: [CanDeactivateGuard] }
  ] },

Nhớ khai báo
// add
  providers: [ServersService, AuthService, AuthGuard],

```

Vào tab server, back to home after 800s

Declare new service in module

In the last lecture, we added the canActivate guard and it was working fine but it was working for our whole servers path here.

Now we could grab it from here and add it to our child to make sure that only the child are protected,

the children and not our root path but that is not the easiest way because if we add more child items, we have to add canActivate to each of them.

There is another guard we can use, it's pretty similar to canActivate,

it's called **CanActivateChild**.

So let's implement this interface too,

### 25. Protecting Child (Nested) Routes with canActivateChild

In the last lecture, we added the canActivate guard and it was working fine but it was working for our whole servers path here.

Now we could grab it from here and add it to our child to make sure that only the child are protected,

the children and not our root path but that is not the easiest way because if we add more child items, we have to add canActivate to each of them.

There is another guard we can use, it's pretty similar to canActivate, it's called CanActivateChild.

**Khi bạn đang edit muốn leave page => ask for confirmation**

Implement thêm CanActivateChild

```ts
@Injectable()
export class AuthGuard implements CanActivate, CanActivateChild {
  constructor(private authService: AuthService, private router: Router) {}

    ...
  // add for child routes
  canActivateChild(route: ActivatedRouteSnapshot,
                   state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean {
    return this.canActivate(route, state);
  }
}

```

Thêm `canActivateChild: [AuthGuard]`, rồi comment lại `canActivate: [AuthGuard],`
khi click vào link child routes ở tab server thì redirect to home page

**So now this is the finegrained control you can implement to protect a whole route and all its child routes**

So with this in place, we should now be able to go to servers, this works but if we try to load a single

server, now we get redirected back because now only the child routes are protected, something I can also prove by trying to go to /1/edit, this also navigates us back.

### 26. Using a Fake Auth Service

Vào home tạo btn login và log out

home

```ts
onLogin() {
    this.authService.login();
  }

  onLogout() {
    this.authService.logout();
  }
```

home.html

```html
<h4>Welcome to Server Manager 4.0</h4>
<p>Manage your Servers and Users.</p>
<button class="btn btn-primary" (click)="onLoadServer(1)">Load Server 1</button>
<button class="btn btn-default" (click)="onLogin()">Login</button>
<button class="btn btn-default" (click)="onLogout()">Logout</button>
```

Sau khi log in mới vào tab server được

### 27. Controlling Navigation with canDeactivate

now I want to focus on the control of whether you are allowed to leave a route or not.

Now we for example are allowed to edit the dev server and here, if we actually changed something, I want to ask the user if he accidentally clicks back or somewhere else, if you really want to leave or if you maybe forgot to click update server first, so this convenience method of keeping the user from accidentally navigating away.

edit-server.component.ts

Thêm thuộc tính `changesSaved = false`;

```ts
onUpdateServer() {
    this.serversService.updateServer(this.server.id, {name: this.serverName, status: this.serverStatus});
    // add
    this.changesSaved = true;
    this.router.navigate(['../'], {relativeTo: this.route});
  }

```

Tạo file edit-server/ can-deactivate-guard.service.ts

```ts
import { Observable } from 'rxjs/Observable';
import {
  CanDeactivate,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
} from '@angular/router';

export interface CanComponentDeactivate {
  canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean;
}

export class CanDeactivateGuard
  implements CanDeactivate<CanComponentDeactivate> {
  canDeactivate(
    component: CanComponentDeactivate,
    currentRoute: ActivatedRouteSnapshot,
    currentState: RouterStateSnapshot,

    nextState?: RouterStateSnapshot
  ): Observable<boolean> | Promise<boolean> | boolean {
    // ?: is optional
    return component.canDeactivate();
  }
}
```

app-routing.module.ts

```ts
    { path: ':id/edit', component: EditServerComponent, canDeactivate: [CanDeactivateGuard] }

```

app.module.ts

```ts
providers: [ServersService, AuthService, AuthGuard, CanDeactivateGuard];
```

edit-server.component.ts

```ts
implements CanComponentDeactivate
canDeactivate(): Observable<boolean> | Promise<boolean> | boolean {
    if (!this.allowEdit) {
      return true;
    }
    if ((this.serverName !== this.server.name || this.serverStatus !== this.server.status) && !this.changesSaved) {
      return confirm('Do you want to discard the changes?');
    } else {
      return true;
    }
  }

// thêm in onInit get by id
const id = +this.route.snapshot.params['id'];
    this.server = this.serversService.getServer(id); // thay vì update id = 1
    // Subscribe route params to update the id if params change

```

![image-20200610090229308](angular.assets/image-20200610090229308.png)

### 28. Passing Static Data to a Route

Tạo component error page and declare

```ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Data } from '@angular/router';

@Component({
  selector: 'app-error-page',
  templateUrl: './error-page.component.html',
  styleUrls: ['./error-page.component.css'],
})
export class ErrorPageComponent implements OnInit {
  errorMessage: string;

  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    // this.errorMessage = this.route.snapshot.data['message'];
    this.route.data.subscribe((data: Data) => {
      this.errorMessage = data['message'];
    });
  }
}
```

app-routing.module.ts

```ts
// { path: 'not-found', component: PageNotFoundComponent },
  { path: 'not-found', component: ErrorPageComponent, data: {message: 'Page not found!'} },

```

Khai báo ErrorPageComponent

So here, you could then also set it equal to data message, both would work depending on whether it may change or not,

so yes, both should work.

I will comment out the first use case here but again, if it doesn't change, the using the snapshot is absolutely correct or fine.

### 29. Resolving Dynamic Data with the resolve Guard

Tạo file server-resolver.service.ts

```ts
import {
  Resolve,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
} from '@angular/router';
import { Observable } from 'rxjs/Observable';
import { Injectable } from '@angular/core';

import { ServersService } from '../servers.service';

interface Server {
  id: number;
  name: string;
  status: string;
}

@Injectable()
export class ServerResolver implements Resolve<Server> {
  constructor(private serversService: ServersService) {}

  resolve(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<Server> | Promise<Server> | Server {
    return this.serversService.getServer(+route.params['id']);
  }
}
```

Khai báo module

```ts
providers: [ServersService, AuthService, AuthGuard, CanDeactivateGuard, ServerResolver],

```

file routing

```ts
    { path: ':id', component: ServerComponent, resolve: {server: ServerResolver} },

```

server.component.ts

```ts
ngOnInit() {
    this.route.data
      .subscribe(
        (data: Data) => {
          this.server = data['server'];
        }
      );
    // const id = +this.route.snapshot.params['id'];
    // this.server = this.serversService.getServer(id);
    // this.route.params
    //   .subscribe(
    //     (params: Params) => {
    //       this.server = this.serversService.getServer(+params['id']);
    //     }
    //   );
  }

```

Sử dụng cho async data before component render

### 30. Understanding Location Strategies

URL will be parses by the server first not angular =>care about localhost:4200/# and ignore the rest don't return 404 error
`RouterModule.forRoot(appRoutes, {useHash: true})`

the default is false which is why we didn't have to pass it.

If we do this and we save that, let's see what happens.

You out of the box see that now we have this hashtag in our URL and if I click on servers, you see there is this hashtag in between and that's no bug, that belongs here because this is hash mode routing.

What this hashtag will do is, it informs your web server, hey only care about the part in this URL before this hashtag,

so all the parts thereafter will be ignored by your web server.

Therefore this will run even on servers which don't return the index.html file in case of 404 errors

because they will only care about the part in front of the hashtag.

![image-20200610093847143](angular.assets/image-20200610093847143.png)

### 31. Wrap Up

## 12. Course Project - Routing

### 1. Planning the General Structure

![](angular.assets/2019-11-23-10-29-39.png)

### 2. Setting Up Routes

Tạo file app-routing.module.ts

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { RecipesComponent } from './recipes/recipes.component';
import { ShoppingListComponent } from './shopping-list/shopping-list.component';
import { RecipeStartComponent } from './recipes/recipe-start/recipe-start.component';
import { RecipeDetailComponent } from './recipes/recipe-detail/recipe-detail.component';
import { RecipeEditComponent } from './recipes/recipe-edit/recipe-edit.component';

const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  { path: 'recipes', component: RecipesComponent },
  { path: 'shopping-list', component: ShoppingListComponent },
];

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule],
})
export class AppRoutingModule {}
```

pathMatch: 'full' nếu không bất kì path nào cũng redirect nên báo lỗi

![image-20200610095808083](angular.assets/image-20200610095808083.png)

Khai báo module

```ts
imports: [
    BrowserModule,
    FormsModule,
    AppRoutingModule
  ],

```

app.component.html

```html
<app-header (featureSelected)="onNavigate($event)"></app-header>
<div class="container">
  <div class="row">
    <div class="col-md-12">
      <!-- thay cho if-->
      <router-outlet></router-outlet>
    </div>
  </div>
</div>

<router-outlet></router-outlet> component được render
```

### 3. Adding Navigation to the App

header.component.html

```html
<li routerLinkActive="active"><a routerLink="/recipes">Recipes</a></li>
<li routerLinkActive="active">
  <a routerLink="/shopping-list">Shopping List</a>
</li>
```

header.component.ts sửa thành

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-header',
  templateUrl: './header.component.html',
})
export class HeaderComponent {
  // comment
  // @Output() featureSelected = new EventEmitter<string>();
  // onSelect(feature: string) {
  //   this.featureSelected.emit(feature);
  // }
}
```

### 4. Marking Active Routes

Thêm routerLinkActive

![image-20200610110625719](angular.assets/image-20200610110625719.png)

### 5. Fixing Page Reload Issues

Khi bấm vào list recipe thì page sẽ bị load lại
Vào file recipe-item.component.html, recipe-detail.component.html, header.component.html xóa `href=#`

```html
<a
  style="cursor: pointer;"
  [routerLink]="[index]"
  routerLinkActive="active"
  class="list-group-item clearfix"
>
  <div class="pull-left">
    <h4 class="list-group-item-heading">{{ recipe.name }}</h4>
    <p class="list-group-item-text">{{ recipe.description }}</p>
  </div>
  <span class="pull-right">
    <img
      [src]="recipe.imagePath"
      alt="{{ recipe.name }}"
      class="img-responsive"
      style="max-height: 50px;"
    />
  </span>
</a>
```

Thêm style="cursor: pointer;"

### 6. Child Routes Challenge

```ts
const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  // add
  {
    path: 'recipes',
    component: RecipesComponent,
    children: [
      { path: '', component: RecipeStartComponent },
      { path: 'new', component: RecipeEditComponent },
      { path: ':id', component: RecipeDetailComponent },
      { path: ':id/edit', component: RecipeEditComponent },
    ],
  },
  { path: 'shopping-list', component: ShoppingListComponent },
];
```

### 7. Adding Child Routing Together

```ts
ng g c recipes/recipe-start
```

Nội dung file html

```html
<h3>Please select a Recipe!</h3>
```

Khai báo RecipeStartComponent trong module
recipes.component.html

```html
<div class="row">
  <div class="col-md-5">
    <app-recipe-list></app-recipe-list>
  </div>
  <div class="col-md-7">
    <router-outlet></router-outlet>
  </div>
</div>
```

now cannot run app load detail recipe

### 8. Configuring Route Paramieters

Remove event select item in recipe-item.component.html
recipe-detail.component.ts

```ts
export class RecipeDetailComponent implements OnInit {
  recipe: Recipe;
  id: number;

  // xóa  @Input() recipe: Recipe;

  constructor(
    private recipeService: RecipeService,
    private route: ActivatedRoute,
    private router: Router
  ) {}

  ngOnInit() {
    this.route.params.subscribe((params: Params) => {
      this.id = +params['id'];
      this.recipe = this.recipeService.getRecipe(this.id);
    });
  }
}
```

Vào recipe xóa các event không cần thiết
recipe.service

```ts
getRecipe(index: number) {
    return this.recipes[index];
  }

```

### 9. Passing Dynamic Parameters to Links

recipe-item.component.html

```html
<a
  style="cursor: pointer;"
  // Add
  [routerLink]="[index]"
  routerLinkActive="active"
  class="list-group-item clearfix">
  <div class="pull-left">
    <h4 class="list-group-item-heading">{{ recipe.name }}</h4>
    <p class="list-group-item-text">{{ recipe.description }}</p>
  </div>
  <span class="pull-right">
        <img
          [src]="recipe.imagePath"
          alt="{{ recipe.name }}"
          class="img-responsive"
          style="max-height: 50px;">
      </span>
</a>

```

Thêm ở file recipe-item.component.ts: `@Input() index: number;`

recipe-list.component.html

```html
<div class="col-xs-12">
    <app-recipe-item
      *ngFor="let recipeEl of recipes; let i = index"
      // ADD
      [recipe]="recipeEl"
      [index]="i"></app-recipe-item>
  </div>

```

### 10. Styling Active Recipe Items

### 11. Adding Editing Routes

Tạo component recipe-edit

```ts
ng g c recepies/recipe-edit --spec false

```

Vào recipe-list thêm

```html
<div class="col-xs-12">
  <button class="btn btn-success" (click)="onNewRecipe()">New Recipe</button>
</div>
```

```ts
export class RecipeListComponent implements OnInit {
  recipes: Recipe[];

  constructor(
    private recipeService: RecipeService,
    private router: Router,
    private route: ActivatedRoute
  ) {}

  ngOnInit() {
    this.recipes = this.recipeService.getRecipes();
  }

  onNewRecipe() {
    this.router.navigate(['new'], { relativeTo: this.route }); // current route
  }
}
```

Để new lên trước nếu không nó sẽ nhận new là id mà parse => err

```ts
	{ path: 'new', component: RecipeEditComponent },
    { path: ':id', component: RecipeDetailComponent },
    { path: ':id/edit', component: RecipeEditComponent },

```

### 12. Retrieving Route Parameters

recipe-edit.component.ts

```ts
export class RecipeEditComponent implements OnInit {
  id: number;
  editMode = false;

  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    this.route.params.subscribe((params: Params) => {
      this.id = +params['id'];
      this.editMode = params['id'] != null; // pb với new
    });
  }
}
```

### 13. Programmatic Navigation to the Edit Page

recipe-detail.component.html

```html
<li><a style="cursor: pointer;" (click)="onEditRecipe()">Edit Recipe</a></li>
```

recipe-detail.component.ts

```ts
constructor(private recipeService: RecipeService,
              private route: ActivatedRoute,
              private router: Router) {
  }

onEditRecipe() {
    this.router.navigate(['edit'], {relativeTo: this.route});
    // this.router.navigate(['../', this.id, 'edit'], {relativeTo: this.route}); cách 2
  }


```

### 14. One Note about Route Observables

Now as I explained, you don't need to clean up the subscription here, I just want to bring it to your

attention again.

In other cases where you use your own observables, observables you created and not managed by Angular

therefore, you will need to clean up the subscription.

### 15. Project Cleanup.html

There's one thing I forgot to clean up here (will be cleaned up later in the course). Feel free to do the cleanup right now though.

Our app.component.html file looks like that:

```html
<app-header (featureSelected)="onNavigate($event)"></app-header>
<div class="container">
  <div class="row">
    <div class="col-md-12">
      <router-outlet></router-outlet>
    </div>
  </div>
</div>
```

The `(featureSelected)="..."` event listener is a relict of our "old" navigation approach using ngIf. We no longer need it, so feel free to change this template to:

```html
<app-header></app-header>
<div class="container">
  <div class="row">
    <div class="col-md-12">
      <router-outlet></router-outlet>
    </div>
  </div>
</div>
```

## 13. Understanding Observables

### 1. Module Introduction

![](angular.assets/2019-11-23-15-33-46.png)

So what is an observable? An **observable** basically can be thought of as a data source.

Now in our Angular project, an observable basically just is an object we import from a third-party package,

RxJS. The observable here is implemented in a way that it follows the observable pattern,

so we have an observable and we have an observer. In between, we have a stream, a timeline

and on this timeline, we can have multiple events emitted by the observable or data packages

you could say emitted by the observable, depending on the data source of that observable of course.

So the observable could emit data because you trigger it to do so, you can do that programmatically,

it could be connected to a button and therefore whenever the button is clicked, an event in a data package

is emitted automatically or as the Angular HTTP service does it, it's connected to a HTTP request.

So when the response returns, the response is emitted as a data package and there are dozens of other data sources too,

we will have a look on where to find more soon.

So as I said, the other part is the **observer**, this actually is your code you could say. It's the subscribe function you saw earlier or at least it has something to do with that.

There, you have **three ways of handling data packages** - you can handle the normal data, you can handle errors or you can handle the completion of the observable because these are the three types of data packages you can receive and in these hooks, in these boxes you could say, your code gets executed.

Angular uses them a lot and actually, observables have one major advantage,

their operators, which I will show later in the section too. Back to this slide,

### 2. Analyzing Angular Observables

![image-20200610140954649](angular.assets/image-20200610140954649.png)

user.component.ts

```ts
export class UserComponent implements OnInit {
  id: number;

  constructor(private route: ActivatedRoute) {}

  ngOnInit() {
    this.route.params.subscribe((params: Params) => {
      this.id = +params.id;
    });
  }
}
```

So that's how this built-in observable works and how you can think about it, params is the observable, it's that stream of data that gives us new values.

Now that's all nice and Angular will heavily use such observables and there you will never need

to create them yourselves, you only subscribe to them, you don't need to create them but to understand them, it certainly doesn't hurt to also create them.

### 3. Getting Closer to the Core of Observables

Observables nằm trong rxjs
2.1 obs-01-start.zip.zip
home.component.ts

```ts
import { Component, OnDestroy, OnInit } from '@angular/core';

import { interval, Subscription } from 'rxjs';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css'],
})
export class HomeComponent implements OnInit, OnDestroy {
  private firstObsSubscription: Subscription;

  constructor() {}

  ngOnInit() {
    this.firstObsSubscription = interval(1000).subscribe((count) => {
      console.log(count);
    });
  }

  ngOnDestroy(): void {
    this.firstObsSubscription.unsubscribe();
  }
}
```

**memory leak**

Hàm interval sau 1s sẽ emit event, khi vào trang chủ sẽ tự động tăng biến count nếu quay lại thì sẽ có thêm 1 biến đếm bắt đầu từ 0 và tăng song song => destroy khắc phục memory leak

Param k cần unsubscribe bởi vì nó được cung cấp bởi angular nên không cần làm thủ công

### 4. Building a Custom Observable

home.component.ts

```ts
ngOnInit() {
    // this.firstObsSubscription = interval(1000).subscribe(count => {
    //   console.log(count);
    // });
    const customIntervalObservable = Observable.create(observer => {
      let count = 0;
      setInterval(() => {
        observer.next(count); // emit
        if (count === 5) {
          observer.complete();
        }
        if (count > 3) {
          observer.error(new Error('Count is greater 3!'));
        }
        count++;
      }, 1000);
    });

    this.firstObsSubscription = customIntervalObservable.subscribe(data => {
      console.log(data);
    }, error => {
      console.log(error);
      alert(error.message);
    }, () => {
      console.log('Completed!');
    });
  }

  ngOnDestroy(): void {
    this.firstObsSubscription.unsubscribe();
  }

```

Now what's an **observer**?

Now you heard about the observer in the first video of this module. The observer in the end is a part

that is interested in being informed about new data, about errors or about the observable being completed.

Now our job here is to tell the observer about new data, about an error or about the observable being

completed. Here, we're not responsible for listening because the observer is the listener, here

we get that listening part as an argument and we need to tell it once we're done, once new data is there and so on.

### 5. Errors & Completion

### 6. Observables & You!

However, you rarely, very very very rarely build your own observables.

More often, you use observables that come with libraries like Angular, like the route params observable

we already used. Under the hood, that in the end is a custom observable built by the Angular team but

of course you just use it like that.

You rarely build your own ones but still, it's super important to understand how they work under the

hood and in the end, they all work a bit like that.

### 7. Understanding Operators

![](angular.assets/2019-11-23-16-02-35.png)

Operators are the magic feature of the RxJS library and they are the thing that really turn observable

into awesome constructs.

If we have an observable and an observer, we of course get data and we listen to that with a subscription,

that is what you learned.

Now however, sometimes you don't need the raw data, You might want to transform it or filter out certain

data points and of course, you could do all of that inside of your subscription or in the function you pass to your

subscription but there's a more elegant way. Instead of setting up that subscription like this, you can use built-in

operators in between.

![image-20200610143554172](angular.assets/image-20200610143554172.png)

```ts
this.firstObsSubscription = customIntervalObservable
  .pipe(
    filter((data) => {
      return data > 0;
    }),
    map((data: number) => {
      return 'Round: ' + (data + 1);
    })
  )
  .subscribe(
    (data) => {
      console.log(data);
    },
    (error) => {
      console.log(error);
      alert(error.message);
    },
    () => {
      console.log('Completed!');
    }
  );
```

https://www.academind.com/learn/javascript/understanding-rxjs/

https://www.learnrxjs.io/

You can use them on any observable, like our custom interval observable, by calling a method called **pipe**.

Now every observable has a pipe method, the pipe method is built into RxJS.

Now you can import observables, not from the RxJS package but from rxjs/operators and there

are tons of built-in operators, like the map operator which is one of the operators you'll use more often.

As a side note, if you want to learn more about RxJS and operators and so on, you can visit my home

page, academind.com and there on the Learn Javascript, you'll find a complete series on RxJS which introduces you to RxJS and to operators as well.

### 8. Subjects

user.component.html

```html
<p>User with <strong>ID {{ id }}</strong> was loaded</p>
<button class="btn btn-primary" (click)="onActivate()">Activate</button>
```

user.component.ts

```ts
constructor(private route: ActivatedRoute, private userService: UserSe
rvice) {
  }

  ngOnInit() {
    this.route.params.subscribe((params: Params) => {
      this.id = +params.id;
    });
  }

  onActivate() {
    // emit(true) nếu xài EvenEmitter
    this.userService.activatedEmitter.next(true);
  }
```

user.service.ts

```ts
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';

@Injectable({ providedIn: 'root' })
export class UserService {
  //activatedEmitter = new EvenEmitter<boolean>(); cách cũ
  activatedEmitter = new Subject<boolean>();
}
```

app.component.ts

```ts
export class AppComponent implements OnInit, OnDestroy {
  userActivated = false;
  private activatedSub: Subscription;

  constructor(private userService: UserService) {}

  ngOnInit() {
    this.activatedSub = this.userService.activatedEmitter.subscribe(
      (didActivate) => {
        this.userActivated = didActivate;
      }
    );
  }

  ngOnDestroy(): void {
    this.activatedSub.unsubscribe();
  }
}
```

app.component.html

```html
<p *ngIf="userActivated">Activated!</p>
```

This is the old approach with the event emitter and this is an approach you could use but there is a

better one, **a more recommended one and that new approach**, the better approach uses a **subject**. Now a subject

is something we import from RxJS, SO you import subject from RxJS, instead of event emitter, you now create a subject here. Other than that, it's pretty similar though, it's a generic type where you define which data will eventually

be emitted, in this case a boolean.

So it's very similar to event emitter thus far.

![](angular.assets/2019-11-23-16-22-39.png)

=>
Recommend
**If use @Output not use Subject**

You don't use subjects instead of event emitter when you're using @output.

So in a component if you're using @output here with your own event, you still use the

Angular event emitter,you're not using subject there because the subject is not suitable for that,

there you need the Angular event emitter, you only use subjects to communicate across components, through services so through a mechanism where you in the end subscribe to somewhere, like here in the app component.

If you're not subscribing to an event emitter, then it probably is an output,

### 9. Wrap Up

### 10. Useful Resources & Links.html

Useful Resources:
• Official Docs: https://rxjs-dev.firebaseapp.com/
• RxJS Series: https://academind.com/learn/javascript/understanding-rxjs/
• Updating to RxJS 6: https://academind.com/learn/javascript/rxjs-6-what-changed/

## 14. Course Project - Observables

EventEmitter push new info from A to B
Vào app.component.ts và .html xóa hàm onNavigate

shopping-list.service.ts

```ts
export class ShoppingListService {
  // add
  ingredientsChanged = new Subject<Ingredient[]>();
```

thay hết emit => next

shopping-list.component.ts

```ts
export class ShoppingListComponent implements OnInit, OnDestroy {
  ingredients: Ingredient[];
    // add
  private igChangeSub: Subscription;

  constructor(private slService: ShoppingListService) {
  }

  ngOnInit() {
    this.ingredients = this.slService.getIngredients();
    this.igChangeSub = this.slService.ingredientsChanged
      .subscribe(
        (ingredients: Ingredient[]) => {
          this.ingredients = ingredients;
        }
      );
  }

// Add
  ngOnDestroy(): void {
    this.igChangeSub.unsubscribe();
  }
}

 xóa recipeSelected = new EventEmitter<Recipe>(); trong service và
recipes component
recipes.component.ts vẫn subscribe bình thường

```

Xem lai recipes.component.ts xoa vi da add routing in item-recipe

=> xóa subscribe đi vì đã SD routing cho load recipe

### 1. Improving the Reactive Service with Observables (Subjects)

### 2. Changed the Subscription Name.html

Don't wonder - I changed the `igChangeSub` property to just subscription. So if you see that name change in code in future videos, that's why. Other than that, nothing changed!

## 15. Handling Forms in Angular Apps

### 1. Module Introduction

### 2. Why do we Need Angular's Help

![image-20200610162107124](angular.assets/image-20200610162107124.png)

### 3. Template-Driven (TD) vs Reactive Approach

![](angular.assets/2019-11-23-21-58-25.png)

It offers the **template driven approach**, which is called like this because there, you simply set up your form in the template, in HTML code and Angular will automatically infer the structure of your form, will infer which controls your forms has, which inputs and makes it easy for you to get started quickly.

It also has a more complex approach, the reactive approach.

There, you actually define the structure of the form in TypeScript code, you also set up the HTML code and then you manually connect it which might sound more complicated than it is in the end and therefore, it gives you greater control over it, you can fine tune every little piece about your form.

### 4. An Example Form

![image-20200610162542106](angular.assets/image-20200610162542106.png)

### 5. TD Creating the Form and Registering the Controls

This will be enough to tell Angular, hey this input is actually a control of my form, so **ngModel in the end is a directive** made available in the forms module, something I mentioned earlier in the course when we had a look at **two-way data binding.**

This is key to understand, you can use it to get two-way data binding but it actually is part of a bigger module with more features giving you full control over forms.

Now for this to work, for this to be recognized as a control in your form, we need to give Angular one other piece of information, the name of this control.

Import FormsModule

```ts
import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    // Add
    FormsModule,
  ],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

Sau đó vào thẻ input thêm ngModel(is not two-way data binding) và name attr in HTML

```html
<input type="email" id="email" class="form-control" ngModel name="email" />
```

**ngModel tell angular this is a control, not two-way data binding**

### 6. TD Submitting and Using the Form

File html
**ngSubmit is directive**

**ngForm tell angular please help me can access the form**

Now you learned about local references you can place on HTML elements to get access to them,

so we could place #f on the form element and now we could access this form element on the f

reference in our template and we could pass f as an argument to the onSubmit method and print it there.

```html
<form (ngSubmit)="onSubmit()" #f="ngForm"></form>
```

`#f="ngForm">` : cho phép truy cập vào form
Nếu để #f thì phải truyền như tham số vào hàm onSubmit, ghi log ra để xem

![image-20200628235549476](angular.assets/image-20200628235549476.png)

app.component.ts

```ts
  // cach 1
  // <form (ngSubmit)="onSubmit(f)" #f>

  // onSubmit(f: HTMLFormElement) {   Nếu để #f
  //   console.log(f);
  // }

  // cach 2
  // <form (ngSubmit)="onSubmit(f)" #f="ngForm">

  onSubmit(form: NgForm) {
    // form.value
    console.log(form);
  }

```

![image-20200610164518463](angular.assets/image-20200610164518463.png)

cách 2 mới in ra được value còn cách 1 print thẳng form ra luôn

### 7. TD Understanding Form State

dirty, value, valid, controls

**Dirty** for example is **true** because we changed something about that form.

If I reload the page and submit it now, you will see that dirty is false because I didn't type into any

input, so therefore of course dirty is false.

**Disabled** would be true if the form was disabled for some reason, invalid is false because we haven't

added any validators, so it isn't invalid, it is indeed valid.

![image-20200629000018474](angular.assets/image-20200629000018474.png)

### 8. TD Accessing the Form with @ViewChild

Nếu không truyền tham số vào hàm thì sử dụng @ViewChild => access local ref

Nhưng bên file html phải là ` <form (ngSubmit)="onSubmit()" #f="ngForm">`

```ts

  @ViewChild('f', { static: false }) signupForm: NgForm;

  onSubmit() {
    this.submitted = true;
    this.user.username = this.signupForm.value.userData.username;
    this.user.email = this.signupForm.value.userData.email;
    this.user.secretQuestion = this.signupForm.value.secret;
    this.user.answer = this.signupForm.value.questionAnswer;
    this.user.gender = this.signupForm.value.gender;

    this.signupForm.reset();
  }

```

### 9. TD Adding Validation to check User Input

Thêm require, email => nhập giá trị hợp lên ghi log ra console giá trị valid = true và F12 để kiểm tra angular sẽ thêm các class
email la 1 directive

![image-20200610165635460](angular.assets/image-20200610165635460.png)

### 10. Built-in Validators & Using HTML5 Validation.html

Which Validators do ship with Angular?

Check out the Validators class: https://angular.io/api/forms/Validators - these are all built-in validators, though that are the methods which actually get executed (and which you later can add when using the reactive approach).

For the template-driven approach, you need the directives. You can find out their names, by searching for "validator" in the official docs: https://angular.io/api?type=directive - everything marked with "D" is a directive and can be added to your template.

Additionally, you might also want to enable HTML5 validation (by default, Angular disables it). You can do so by adding the ngNativeValidate to a control in your template.

### 11. TD Using the Form State

```html
<button class="btn btn-primary" type="submit" [disabled]="!f.valid">
  Submit
</button>
```

File css

```cs
input.ng-invalid.ng-touched {
  border: 1px solid red;
}

```

.ng-touched assure user had clicked in it

### 12. TD Outputting Validation Error Messages

```html
<input
  type="email"
  id="email"
  class="form-control"
  ngModel
  name="email"
  required
  email
  #email="ngModel"
/>
<span
  class="help-
block"
  *ngIf="!email.valid && email.touched"
  >Please enter a valid email!</span
>
```

Thêm local reference `#email=”ngModel”`
ngModel is a directive

So just like the form directive automatically added by Angular when it detects a form element, the

**ngModel** directive here also kind of exposes some additional information about the control it creates

for us on the overarching form by accessing ngModel.

### 13. TD Set Default Values with ngModel Property Binding

Thêm biến defaultQuestion ở file ts và để ngModel trong dấu [] là prop binding

```html
<div class="form-group">
  <label for="secret">Secret Questions</label>
  <select
    id="secret"
    class="form-control"
    [ngModel]="defaultQuestion"
    name="secret"
  >
    <option value="pet">Your first Pet?</option>
    <option value="teacher">Your first teacher?</option>
  </select>
</div>
```

### 14. TD Using ngModel with Two-Way-Binding

add html

```html
<div class="form-group">
  <textarea
    name="questionAnswer"
    rows="3"
    class="form-control"
    [(ngModel)]="answer"
  ></textarea>
</div>
<p>Your reply: {{ answer }}</p>
```

```ts
defaultQuestion = 'teacher';
answer = '';
```

3 type:

- No binding: is a control
- One way binding
- Two way binding

this is still part of this value object, it just is updated with every keystroke but of course if we submit it, we will get a snapshot of the value at a point of time we hit submit.

So two-way binding is still possible, you can still use ngModel with two-way binding and with that, you saw all three forms. No binding to just tell Angular that an input is a control, one-way binding to give that control a default value and two-way binding to instantly output it or do whatever you want to do with that value.

### 15. TD Grouping Form Controls

Sử dụng ngModelGroup để group sau này truy cập ra phải .userData
userData is local reference

```html
      <form (ngSubmit)="onSubmit()" #f="ngForm">
		<div
          id="user-data"
          // Add
          ngModelGroup="userData"
          #userData="ngModelGroup"> // like  email
          <div class="form-group">
            <label for="username">Username</label>
            <input
              type="text"
              id="username"
              class="form-control"
              ngModel
              name="username"
              required>
          </div>
          <button
            class="btn btn-default"
            type="button"
            (click)="suggestUserName()">Suggest an Username</button>
          <div class="form-group">
            <label for="email">Mail</label>
            <input
              type="email"
              id="email"
              class="form-control"
              ngModel
              name="email"
              required
              email
              #email="ngModel">
            <span class="help-block" *ngIf="!email.valid && email.touched">Please enter a valid email!</span>
          </div>
        </div>
<!--add-->
<p *ngIf="!userData.valid && userData.touched">User Data is invalid!</p>

```

### 16. TD Handling Radio Buttons

genders = ['male', 'female'];

```html
<div class="radio" *ngFor="let gender of genders">
  <label>
    <input type="radio" name="gender" ngModel [value]="gender" required />
    {{ gender }}
  </label>
</div>
```

### 17. TD Setting and Patching Form Values

```ts
suggestUserName() {
    const suggestedName = 'Superuser';
    // sẽ override all
    // this.signupForm.setValue({
    //   userData: {
    //     username: suggestedName,
    //     email: ''
    //   },
    //   secret: 'pet',
    //   questionAnswer: '',
    //   gender: 'male'
    // });

// cách này k ghi đè giá trị da chon mà merge
    this.signupForm.form.patchValue({
      userData: {
        username: suggestedName
      }
    });
  }

```

### 18. TD Using Form Data

set ở trong hàm submit vào object user được tạo mới

```html
<div class="row" *ngIf="submitted">
  <div class="col-xs-12">
    <h3>Your Data</h3>
    <p>Username: {{ user.username }}</p>
    <p>Mail: {{ user.email }}</p>
    <p>Secret Question: Your first {{ user.secretQuestion }}</p>
    <p>Answer: {{ user.answer }}</p>
    <p>Gender: {{ user.gender }}</p>
  </div>
</div>
```

### 19. TD Resetting Forms

```ts
this.signupForm.reset();
// can use set value with obj you want
```

### 20. Practicing Template-Driven Forms.html

### 21. Introduction to the Reactive Approach

### 22. Reactive Setup

```ts
import { FormArray, FormControl, FormGroup, Validators } from '@angular/forms';

export class AppComponent implements OnInit {
  genders = ['male', 'female'];
    // add
  signupForm: FormGroup;

```

khai báo ReactiveFormsModule

```ts
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';

import { ReactiveFormsModule } from '@angular/forms';

import { AppComponent } from './app.component';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    // Add
    ReactiveFormsModule,
  ],
  providers: [],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

### 23. Reactive Creating a Form in Code

Sử dụng hàm onInit before render

```ts
ngOnInit() {
    // create control
    this.signupForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, Validators.required),
        'email': new FormControl(null, [Validators.required, Validators.email])
      }),
      'gender': new FormControl('male')
    });
  }

```

New **FormControl** nhận 2 tham số, **thứ nhất là giá trị khởi tạo, in form, tham số thứ 2 là single validator, tham số thứ 3 là potential async validator**

Now to this FormControl constructor, we can pass a couple of arguments, the first argument is the initial state, the initial value of this control you could say.

The second argument will be a single validator or an array of validators we want to apply to this control,

I'll come back to this. The third argument will be potential asynchronous validators,

### 24. Reactive Syncing HTML and Form

Thông báo sử dụng directive formGroup tham chiếu đến signupForm bằng cách thêm vào thẻ form
Sử dụng directive formControlName thay cho name
Có thể sử dụng [formControlName]="'username'" thay cho formControlName="username"

```html
<form [formGroup]="signupForm" (ngSubmit)="onSubmit()">
  <div formGroupName="userData">
    <div class="form-group">
      <label for="username">Username</label>
      <input
        type="text"
        id="username"
        formControlName="username"
        class="form-control"
      />
    </div>
    <div class="form-group">
      <label for="email">email</label>
      <input
        type="text"
        id="email"
        formControlName="email"
        class="form-control"
      />
    </div>
  </div>
  <div class="radio" *ngFor="let gender of genders">
    <label>
      <input type="radio" formControlName="gender" [value]="gender" />{{ gender
      }}
    </label>
  </div>
</form>
```

### 25. Reactive Submitting the Form

Để submit thì thêm hàm (ngSubmit)="onSubmit()

```ts
onSubmit() {
    console.log(this.signupForm);
    this.signupForm.reset();
  }

```

### 26. Reactive Adding Validation

Nếu muốn config tham số thì truyền tham số ở file ts

```ts
ngOnInit() {
    // create control
    this.signupForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, Validators.required),
        'email': new FormControl(null, [Validators.required, Validators.email])
      }),
      'gender': new FormControl('male')
    });
  }

```

![image-20200610184337138](angular.assets/image-20200610184337138.png)

### 27. Reactive Getting Access to Controls

```html
<span
  *ngIf="!signupForm.get('userData.username').valid && signupForm.get('userData.username').touched"
  class="help-block"
>
  <!-- <span *ngIf="signupForm.get('userData.username').errors['nameIsForbidden']">This name is invalid!</span>
              <span *ngIf="signupForm.get('userData.username').errors['required']">This field is required!</span> -->
  Invalid name
</span>

<span *ngIf="!signupForm.valid && signupForm.touched" class="help-block"
  >Please enter valid data!</span
>
<button class="btn btn-primary" type="submit">Submit</button>
```

Add css class

```css
input.ng-invalid.ng-touched {
  border: 1px solid red;
}
```

### 28. Reactive Grouping Controls

Tạo form Group để chứa form control

```html
<div formGroupName="userData"></div>
```

### Fixing a Bug

In the next lecture, we'll add some code to access the controls of our form array:

```ts
*ngFor="let hobbyControl of signupForm.get('hobbies').controls; let i = index"

```

This code will fail as of the latest Angular version.

You can fix it easily though. Outsource the "get the controls" logic into a method of your component code (the .ts file):

```ts
getControls() {
  return (<FormArray>this.signupForm.get('hobbies')).controls;
}

```

In the template, you can then use:

```ts
*ngFor="let hobbyControl of getControls(); let i = index"

```

Alternatively, you can set up a getter and use an alternative type casting syntax:

```ts
get controls() {
  return (this.signupForm.get('hobbies') as FormArray).controls;
}

```

and then in the template:

```ts
*ngFor="let hobbyControl of controls; let i = index"

```

This adjustment is required due to the way TS works and Angular parses your templates (it doesn't understand TS there).

### 29. Reactive Arrays of Form Controls (FormArray)

```ts
      'hobbies': new FormArray([])
---

onAddHobby() {
    const control = new FormControl(null, Validators.required);
    (<FormArray>this.signupForm.get('hobbies')).push(control);
  }

```

File html: formArrayName="hobbies" connect

```html
// add
<div formArrayName="hobbies">
  <h4>Your Hobbies</h4>
  <button class="btn btn-default" type="button" (click)="onAddHobby()">
    Add Hobby
  </button>
  <div
    class="form-group"
    *ngFor="let hobbyControl of signupForm.get('hobbies').controls; let i = index"
  >
    <input type="text" class="form-control" [formControlName]="i" />
  </div>
</div>
```

### 30. Reactive Creating Custom Validators

```ts
// add
forbiddenUsernames = ['Chris', 'Anna'];

forbiddenNames(control: FormControl): {[s: string]: boolean} {
    if (this.forbiddenUsernames.indexOf(control.value) !== -1) {
      return {'nameIsForbidden': true};
    }
    return null;
  }


this.signupForm = new FormGroup({
      'userData': new FormGroup({
        'username': new FormControl(null, [Validators.required,
        // this.forbiddenEmails.bind(this) refers this class
                                           this.forbiddenNames.bind(this)]),
        'email': new FormControl(null, [Validators.required, Validators.email],

        this.forbiddenEmails)
      }),
      'gender': new FormControl('male'),
      'hobbies': new FormArray([])
    });
// 32  add
forbiddenEmails(control: FormControl): Promise<any> | Observable<any> {
    const promise = new Promise<any>((resolve, reject) => {
      setTimeout(() => {
        if (control.value === 'test@test.com') {
          resolve({'emailIsForbidden': true});
        } else {
          resolve(null);
        }
      }, 1500);
    });
    return promise;
  }

```

Phải có bind this nó mới hiểu this trong hàm kia
[s: string]: boolean => mean: key: value; key is a string

### 31. Reactive Using Error Codes

```html
<span
  *ngIf="!signupForm.get('userData.username').valid && signupForm.get('userData.username').touched"
  class="help-block"
>
  // add -------
  <span *ngIf="signupForm.get('userData.username').errors['nameIsForbidden']"
    >This name is invalid!</span
  >
  <span *ngIf="signupForm.get('userData.username').errors['required']"
    >This field is required!</span
  >
</span>
```

F12/ FormGroup/ controls/ userData/ controls/ username/ error

![image-20200610192405967](angular.assets/image-20200610192405967.png)

### 32. Reactive Creating a Custom Async Validator

```ts
forbiddenEmails(control: FormControl): Promise<any> | Observable<any>
{
    const promise = new Promise<any>((resolve, reject) => {
      setTimeout(() => {
        if (control.value === 'test@test.com') {
          resolve({'emailIsForbidden': true});
        } else {
          resolve(null);
        }
      }, 1500);
    });
    return promise;
  }

```

### 33. Reactive Reacting to Status or Value Changes

Try it

```ts
ngOnInit() {
    // add
    // this.signupForm.valueChanges.subscribe(
    //   (value) => console.log(value)
    // );
    this.signupForm.statusChanges.subscribe(
      (status) => console.log(status)
    );
}
```

![image-20200610192935422](angular.assets/image-20200610192935422.png)

### 34. Reactive Setting and Patching Values

ngOnInit

```ts
// intitial
this.signupForm.setValue({
      'userData': {
        'username': 'Max',
        'email': 'max@test.com'
      },
      'gender': 'male',
      'hobbies': []
    });
    // only set this field
    this.signupForm.patchValue({
      'userData': {
        'username': 'Anna',
      }
    });

// cách 2
    this.signupForm.reset();
có thẻ chỉ rõ field cần reset in oject in reset({}) to don't clear radio button

```

![image-20200610193026967](angular.assets/image-20200610193026967.png)

### 35. Practicing Reactive Forms.html

### 36. [OPTIONAL] Assignment Solution

```html
<form [formGroup]="projectForm" (ngSubmit)="onSaveProject()">
  <div class="form-group">
    <label for="name">Project Name</label>
    <input
      type="text"
      id="name"
      formControlName="projectName"
      class="form-control"
    />
  </div>
  <div class="form-group">
    <label for="email">Mail</label>
    <input
      type="email"
      id="email"
      formControlName="email"
      class="form-control"
    />
  </div>
  <div class="form-group">
    <label for="status">Projectstatus</label>
    <select id="status" formControlName="projectStatus" class="form-control">
      <option value="stable">Stable</option>
      <option value="critical">Critical</option>
      <option value="finished">Finished</option>
    </select>
  </div>
  <button class="btn btn-primary" type="submit">Create Project</button>
</form>
```

ts

```ts
ngOnInit() {
    this.projectForm = new FormGroup({
      'projectName': new FormControl(
        null,
        [Validators.required, CustomValidators.invalidProjectName],
        CustomValidators.asyncInvalidProjectName
      ),
      'email': new FormControl(null, [Validators.required, Validators.email]),
      'projectStatus': new FormControl('critical')
    });
  }
```

## 16. Course Project - Forms

### 1. Introduction

### 2. TD Adding the Shopping List Form

shopping-edit.component.html
Nhớ khai báo FormModule trước
Không cần sử dụng local ref như cũ thêm ngForm và name

```html
<form (ngSubmit)="onSubmit(f)" #f="ngForm">
  <div class="row">
    <div class="col-sm-5 form-group">
      <label for="name">Name</label>
      <input type="text" id="name" class="form-control" name="name" ngModel />
    </div>
    <div class="col-sm-2 form-group">
      <label for="amount">Amount</label>
      <input
        type="number"
        id="amount"
        class="form-control"
        name="amount"
        ngModel
      />
    </div>
  </div>
  <div class="row">
    <div class="col-xs-12">
      <button class="btn btn-success" type="submit" [disabled]="!f.valid">
        {{ editMode ? 'Update' : 'Add' }}
      </button>
    </div>
  </div>
</form>
```

shopping-edit.component.ts

```ts
onSubmit(form: NgForm) {
    const value = form.value;
    const newIngredient = new Ingredient(value.name, value.amount);

```

### 3. Adding Validation to the Form

```html
<div class="col-sm-2 form-group">
  <label for="amount">Amount</label>
  <input
    type="number"
    id="amount"
    class="form-control"
    name="amount"
    ngModel
    <!--
    add
    --
  />
  required pattern="^[1-9]+[0-9]*$" // [pattern]="'^[1-9]+[0-9]*$'" >
</div>
```

Check số dương bằng pattern

### 4. Allowing the Selection of Items in the List

shopping-list.component.html thêm event onEditItem

```html
<a
        class="list-group-item"
        style="cursor: pointer"
        *ngFor="let ingredient of ingredients; let i = index"
        (click)="onEditItem(i)" // add
      >
        {{ ingredient.name }} ({{ ingredient.amount }})
      </a>

```

shopping-list.component.ts

```ts
// add
onEditItem(index: number) {
    this.slService.startedEditing.next(index); // emit event
  }

```

shopping-list.service.ts
Thêm `startedEditing = new Subject<number>();`

shopping-edit.component.ts lắng nghe lấy ra item mà click đổ data vào form

```ts
// add
@ViewChild('f', { static: false }) slForm: NgForm; // local ref
  subscription: Subscription;
  editMode = false;
  editedItemIndex: number;
  editedItem: Ingredient;

  constructor(private slService: ShoppingListService) { }

  ngOnInit() {
    this.subscription = this.slService.startedEditing
      .subscribe(
        (index: number) => {
          this.editedItemIndex = index;
          this.editMode = true;
          this.editedItem = this.slService.getIngredient(index);
          // set value to form
          this.slForm.setValue({
            name: this.editedItem.name,
            amount: this.editedItem.amount
          })
        }
      );
  }

  ngOnDestroy() {
    this.subscription.unsubscribe();
  }

```

### 5. Loading the Shopping List Items into the Form

shopping-list.service.ts

```ts
getIngredient(index: number) {
    return this.ingredients[index];
  }

```

### 6. Updating existing Items

Hiển thị đúng tên btn khi edit

```html
<button class="btn btn-success" type="submit" [disabled]="!f.valid">
  {{ editMode ? 'Update' : 'Add' }}
</button>
```

Service

```ts
updateIngredient(index: number, newIngredient: Ingredient) {
    this.ingredients[index] = newIngredient;
    this.ingredientsChanged.next(this.ingredients.slice());
  }

```

shopping-edit.component.ts

```ts
onSubmit(form: NgForm) {
    const value = form.value;
    const newIngredient = new Ingredient(value.name, value.amount);
    if (this.editMode) {
      // add
      this.slService.updateIngredient(this.editedItemIndex, newIngredient);
    } else {
      this.slService.addIngredient(newIngredient);
    }
    this.editMode = false;
    form.reset();
  }

```

### 7. Resetting the Form

Hàm add

```ts
this.editMode = false;
form.reset(); // clear
```

### 8. Allowing the the User to Clear (Cancel) the Form

```ts
onClear() {
    this.slForm.reset();
    this.editMode = false;
  }

```

### 9. Allowing the Deletion of Shopping List Items

```html
<button class="btn btn-danger" type="button" (click)="onDelete()" <!-- add -->
  *ngIf="editMode">Delete
</button>
```

```ts
onDelete() {
    this.slService.deleteIngredient(this.editedItemIndex);
    this.onClear();
  }

 // Service
deleteIngredient(index: number) {
    this.ingredients.splice(index, 1);
    this.ingredientsChanged.next(this.ingredients.slice());
  }

```

### 10. Creating the Template for the (Reactive) Recipe Edit Form

Cách 2
recipe-edit.component.html tạo template bình thường
Nhớ khai báo ReactiveFormModule

### 11. Creating the Form For Editing Recipes

Tạo hàm init

```ts
  recipeForm: FormGroup;

private initForm() {
    let recipeName = '';
    let recipeImagePath = '';
    let recipeDescription = '';
    let recipeIngredients = new FormArray([]);

    if (this.editMode) {
      const recipe = this.recipeService.getRecipe(this.id);
      recipeName = recipe.name;
      recipeImagePath = recipe.imagePath;
      recipeDescription = recipe.description;
	// thêm sau
      if (recipe['ingredients']) {
        for (let ingredient of recipe.ingredients) {
          recipeIngredients.push(
            new FormGroup({
              'name': new FormControl(ingredient.name, Validators.required),
              'amount': new FormControl(ingredient.amount, [
                Validators.required,
                Validators.pattern(/^[1-9]+[0-9]*$/)
              ])
            })
          );
        }
      }
    }

    this.recipeForm = new FormGroup({
      'name': new FormControl(recipeName, Validators.required),
      'imagePath': new FormControl(recipeImagePath, Validators.required),
      'description': new FormControl(recipeDescription, Validators.required),
      'ingredients': recipeIngredients
    });
  }

```

### 12. Syncing HTML with the Form

import ReactiveFormsModule
Thêm FormControlName, FormGroup vào file html

### 13. Adding Ingredient Controls to a Form Array

```html
<div class="row">
  <div class="col-xs-12" formArrayName="ingredients">
    <div
      class="row"
      *ngFor="let ingredientCtrl of recipeForm.get('ingredients').controls; let i = index"
      [formGroupName]="i"
      style="margin-top: 10px;"
    >
      <div class="col-xs-8">
        <input type="text" class="form-control" formControlName="name" />
      </div>
      <div class="col-xs-2">
        <input type="number" class="form-control" formControlName="amount" />
      </div>
      <div class="col-xs-2">
        <button
          type="button"
          class="btn btn-danger"
          (click)="onDeleteIngredient(i)"
        >
          X
        </button>
      </div>
    </div>
    <hr />
    <div class="row">
      <div class="col-xs-12">
        <button
          type="button"
          class="btn btn-success"
          (click)="onAddIngredient()"
        >
          Add Ingredient
        </button>
      </div>
    </div>
  </div>
</div>
```

### 14. Fixing a Bug.html

Fixing a Bug
In the next lecture, we'll add some code to access the controls of our form array:

```ts
*ngFor="let ingredientCtrl of recipeForm.get('ingredients').controls; let i = index"

```

This code will fail with the latest Angular version.

You can fix it easily though. Outsource the "get the controls" logic into a getter of your component code (the .ts file):

```ts
get controls() { // a getter!
  return (<FormArray>this.recipeForm.get('ingredients')).controls;
}

```

In the template, you can then use:

```ts
*ngFor="let ingredientCtrl of controls; let i = index"

```

This adjustment is required due to the way TS works and Angular parses your templates (it doesn't understand TS there).

### 15. Adding new Ingredient Controls

```ts
onAddIngredient() {
    (<FormArray>this.recipeForm.get('ingredients')).push(
      new FormGroup({
        'name': new FormControl(null, Validators.required),
        'amount': new FormControl(null, [
          Validators.required,
          Validators.pattern(/^[1-9]+[0-9]*$/)
        ])
      })
    );
  }

```

### 16. Validating User Input

File css

```css
input.ng-invalid.ng-touched,
textarea.ng-invalid.ng-touched {
  border: 1px solid red;
}
```

### 17. Submitting the Recipe Edit Form

recipe-edit.component.ts

```ts
onSubmit() {
    // const newRecipe = new Recipe(
    //   this.recipeForm.value['name'],
    //   this.recipeForm.value['description'],
    //   this.recipeForm.value['imagePath'],
    //   this.recipeForm.value['ingredients']);
    if (this.editMode) {
      this.recipeService.updateRecipe(this.id, this.recipeForm.value);
    } else {
      this.recipeService.addRecipe(this.recipeForm.value);
    }
    this.onCancel();
  }

```

Service

```ts
  recipesChanged = new Subject<Recipe[]>();

addRecipe(recipe: Recipe) {
    this.recipes.push(recipe);
    this.recipesChanged.next(this.recipes.slice());
  }

  updateRecipe(index: number, newRecipe: Recipe) {
    this.recipes[index] = newRecipe;
    this.recipesChanged.next(this.recipes.slice());
  }

  deleteRecipe(index: number) {
    this.recipes.splice(index, 1);
    this.recipesChanged.next(this.recipes.slice());
  }

```

recipe-list.component.ts

```ts
ngOnInit() {
    this.subscription = this.recipeService.recipesChanged
      .subscribe(
        (recipes: Recipe[]) => {
          this.recipes = recipes;
        }
      );
    this.recipes = this.recipeService.getRecipes();
  }

```

### 18. Adding a Delete and Clear (Cancel) Functionality

recipe-detail

```ts
onDeleteRecipe() {
    this.recipeService.deleteRecipe(this.id);
    this.router.navigate(['/recipes']);
  }

```

recipe-edit

```ts
// after submit call this.onCancel();
onCancel() {
    this.router.navigate(['../'], {relativeTo: this.route});
  }

```

### 19. Redirecting the User (after Deleting a Recipe)

### 20. Adding an Image Preview

Thêm local ref imagePath; truy cập imagePath.value

```html
<div class="row">
  <div class="col-xs-12">
    <div class="form-group">
      <label for="imagePath">Image URL</label>
      <input
        type="text"
        id="imagePath"
        formControlName="imagePath"
        class="form-control"
        <!--
        add
        --
      />
      #imagePath>
    </div>
  </div>
</div>
<!-- add -->
<div class="row">
  <div class="col-xs-12">
    <img [src]="imagePath.value" class="img-responsive" />
  </div>
</div>
```

### 21. Providing the Recipe Service Correctly

Khai báo service trong module để đảm bảo có 1 instance được tạo k khia bao trong recipes vi di chuyen qua shopping list se mat

```ts
  providers: [ShoppingListService, RecipeService],

```

The issue we encounter here is that we provide our recipe service in the recipes component,

so all the components in this area share the same instance

but if we navigate away to the shopping list area, the recipes component is destroyed and so is the instance

### 22. Deleting Ingredients and Some Finishing Touches

recipe-edit.component

```ts
onDeleteIngredient(index: number) {
    (<FormArray>this.recipeForm.get('ingredients')).removeAt(index);
  }

```

Thêm recipe-list.component

```ts
ngOnDestroy() {
    this.subscription.unsubscribe();
  }

```

### 23. Deleting all Items in a FormArray.html

Deleting all Items in a FormArray
As of Angular 8, there's a new way of clearing all items in a FormArray.

```ts
(<FormArray>this.recipeForm.get('ingredients')).clear();
```

The clear() method automatically loops through all registered FormControls (or FormGroups) in the FormArray and removes them.

It's like manually creating a loop and calling removeAt() for every item.

## 17. Using Pipes to Transform Output

### 1. Introduction & Why Pipes are Useful

Pipe: Transform output value to out template

This is the main purpose of a pipe, it transforms some output.

Now there are pipes for different types of output and also for synchronous and asynchronous data,

![image-20200610211055008](angular.assets/image-20200610211055008.png)

### 2. Using Pipes

app.component.ts

```ts
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css'],
})
export class AppComponent {
  appStatus = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('stable');
    }, 2000);
  });
  servers = [
    {
      instanceType: 'medium',
      name: 'Production',
      status: 'stable',
      started: new Date(15, 1, 2017),
    },
    {
      instanceType: 'large',
      name: 'User Database',
      status: 'stable',
      started: new Date(15, 1, 2017),
    },
    {
      instanceType: 'small',
      name: 'Development Server',
      status: 'offline',
      started: new Date(15, 1, 2017),
    },
    {
      instanceType: 'small',
      name: 'Testing Environment Server',
      status: 'stable',
      started: new Date(15, 1, 2017),
    },
  ];
  filteredStatus = '';
  getStatusClasses(server: {
    instanceType: string;
    name: string;
    status: string;
    started: Date;
  }) {
    return {
      'list-group-item-success': server.status === 'stable',
      'list-group-item-warning': server.status === 'offline',
      'list-group-item-danger': server.status === 'critical',
    };
  }
  onAddServer() {
    this.servers.push({
      instanceType: 'small',
      name: 'New Server',
      status: 'stable',
      started: new Date(15, 1, 2017),
    });
  }
}
```

![image-20200610211120186](angular.assets/image-20200610211120186.png)

Thay đổi

```html
<strong>{{ server.name }}</strong> | {{ server.instanceType | uppercase }} | {{
server.started | date:'fullDate' | uppercase }}
```

![image-20200610211222544](angular.assets/image-20200610211222544.png)

### 3. Parametrizing Pipes

**date:'fullDate'**

![image-20200629205346413](angular.assets/image-20200629205346413.png)

https://angular.io/guide/pipes
https://angular.io/api?query=pipe

https://angular.io/api/common/DatePipe

### 4. Where to learn more about Pipes

### 5. Chaining Multiple Pipes

Lưu ý thứ tự từ trái qua phải

### 6. Creating a Custom Pipe

Tạo file shorten.pipe.ts

```ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'shorten',
})
export class ShortenPipe implements PipeTransform {
  transform(value: any, limit: number) {
    if (value.length > limit) {
      return value.substr(0, limit) + ' ...';
    }
    return value;
  }
}
```

Khai báo

```ts
declarations: [
    AppComponent,
    ShortenPipe,
    FilterPipe
  ],

```

### 7. Parametrizing a Custom Pipe

`{{ server.name | shorten:15 }}`

Neu nhieu tham so: shorten:15:12

### 8. Example Creating a Filter Pipe

```html
<input type="text" [(ngModel)]="filteredStatus" />
```

Gõ

```ts
ng generate pipe filter
ng g p filter

```

filter.pipe.ts

```ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filter',
  pure: false,
})
export class FilterPipe implements PipeTransform {
  transform(value: any, filterString: string, propName: string): any {
    if (value.length === 0 || filterString === '') {
      return value;
    }
    const resultArray = [];
    for (const item of value) {
      if (item[propName] === filterString) {
        resultArray.push(item);
      }
    }
    return resultArray;
  }
}
```

Must import

```html
<input type="text" [(ngModel)]="filteredStatus" />
<li
  class="list-group-item"
  *ngFor="let server of servers | filter:filteredStatus:'status'"
  [ngClass]="getStatusClasses(server)"
></li>
```

![image-20200610212116956](angular.assets/image-20200610212116956.png)

### 9. Pure and Impure Pipes (or How to fix the Filter Pipe)

Khi thêm mới server khi bam nut ADD, filter sẽ không update nên cần thêm pure: false nó sẽ tính toán lại khi bất cứ thay đổi nào happen => affect performance NG

```ts
@Pipe({
  name: 'filter',
  pure: false
})
// Update array or object doesn't trigger it
```

You can force this pipe to be updated whenever the data changes by adding a second property to the pipe decorator,

it's called pure and you can set it to false. By default, this is true and doesn't need to be added.

Now if you do this and the app reloads, let's filter for stable servers and add new servers and now you see they get added here too.

The reason simply is that the pipe now gets recalculated whenever data changes and as mentioned before, this can lead to performance issues but might be what you're interested in.

### 10. Understanding the async Pipe

app.component.ts

```ts
appStatus = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('stable');
  }, 2000);
});
```

```html
<!-- Print data after 2s -->
<h2>App Status: {{ appStatus | async}}</h2>
```

![image-20200610212655495](angular.assets/image-20200610212655495.png)

Khi nào có nó print

### 11. Practicing Pipes.html

## 18. Making Http Requests

### 1. A New IDE

### 3. How Does Angular Interact With Backends

![](angular.assets/2019-11-25-21-29-49.png)

https://academind.com/learn/javascript/hide-javascript-code/  
https://academind.com/learn/node-js/building-a-restful-api-with/

### 3.1 Securing JS Code.html

### 3.2 Building a REST API.html

### 4. The Anatomy of a Http Request

The most important part about a request of course is the URL you are sending the request to,

that's also called the API endpoint and it is something like yourdomain.com/posts/1

### 5. Backend (Firebase) Setup

https://console.firebase.google.com/?pli=1

Create project/ input name ng-complete-guide

![](angular.assets/2019-11-25-21-55-17.png)  
![](angular.assets/2019-11-25-21-56-23.png)

Vao tab database(It's a complete back-end service)

![](angular.assets/2019-11-25-21-58-49.png)

Vào mục database/ real time db/ Chọn start in test mode

![](angular.assets/2019-11-25-21-59-14.png)

https://ng-complete-guide-35524.firebaseio.com/

https://console.firebase.google.com/project/ng-complete-guide-35524/database/ng-complete-guide-35524/data

### 6. Sending a POST Request

6.1 http-02-post-requests.zip

```ts
import { HttpClient } from '@angular/common/http';

constructor(private http: HttpClient) {}

onCreatePost(postData: { title: string; content: string }) {
    // Send Http request
    this.http
      .post(
        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json',
        postData
      )
      .subscribe(responseData => {
        console.log(responseData);
      });
  }
// neu k subscribe, no se k gui request
// F12 OPTIONS check post req allow
```

Import HttpClientModule

```ts
@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, FormsModule, HttpClientModule],
  providers: [],
  bootstrap: [AppComponent]
})

```

F12 vào tab network để check, hàm post return a Observable

![image-20200610220312608](angular.assets/image-20200610220312608.png)

![image-20200610220110766](angular.assets/image-20200610220110766.png)

### 7. GETting Data

Fetch data làm như post

```ts
private fetchPosts() {
    this.http
      .get('https://ng-complete-guide-c56d3.firebaseio.com/posts.json')
      .subscribe(posts => {
        // ...
        console.log(posts);
      });
  }
}
```

![image-20200629005627924](angular.assets/image-20200629005627924.png)

### 8. Using RxJS Operators to Transform Response Data

```ts
private fetchPosts() {
    this.http
      .get('https://ng-complete-guide-c56d3.firebaseio.com/posts.json')
      .pipe(  // add
        map(responseData => {
          const postsArray = [];
          for (const key in responseData) {
            if (responseData.hasOwnProperty(key)) {
              postsArray.push({ ...responseData[key], id: key });
            }
          }
          return postsArray;
        })
      )
      .subscribe(posts => {
        // ...
        console.log(posts);
      });
  }

```

![image-20200629013657015](angular.assets/image-20200629013657015.png)

Chuyển thành array từ firebase

### 9. Using Types with the HttpClient

post.model.ts

```ts
export interface Post {
  title: string;
  content: string;
  id?: string;
}
```

```ts
.get<{ [key: string]: Post }>
// nghĩa là 1 key có kiểu string sẽ có gtri là Post
    this.http
      .get<{ [key: string]: Post }>(
        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json'
      )
      .pipe(
        map(responseData => {
            // thêm kiểu dl
          const postsArray: Post[] = [];

this.http
      .post<{ name: string }>
```

### 10. Outputting Posts

```ts
 <div class="col-xs-12 col-md-6 col-md-offset-3">
      <p *ngIf="loadedPosts.length < 1 && !isFetching">No posts available!</p>
      <ul class="list-group" *ngIf="loadedPosts.length >= 1 && !isFetching">
        <li class="list-group-item" *ngFor="let post of loadedPosts">
          <h3>{{ post.title }}</h3>
          <p>{{ post.content }}</p>
        </li>
      </ul>
      <p *ngIf="isFetching">Loading...</p>
    </div>
```

### 11. Showing a Loading Indicator

```ts
<p *ngIf="loadedPosts.length < 1 && !isFetching">No posts available!
</p>

```

### 12. Using a Service for Http Requests

posts.service.ts

```ts
@Injectable({ providedIn: 'root' })
export class PostsService {
  error = new Subject<string>();

  constructor(private http: HttpClient) {}

  createAndStorePost(title: string, content: string) {
    const postData: Post = { title: title, content: content };
    this.http
      .post<{ name: string }>(
        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json',
        postData
      )
      .subscribe(
        responseData => {
          console.log(responseData);
        }
      );
  }

  fetchPosts() {
    let searchParams = new HttpParams();
    searchParams = searchParams.append('print', 'pretty');
    searchParams = searchParams.append('custom', 'key');
    return this.http
      .get<{ [key: string]: Post }>(
        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json'
      )
      .pipe(
        map(responseData => {
          const postsArray: Post[] = [];
          for (const key in responseData) {
            if (responseData.hasOwnProperty(key)) {
              postsArray.push({ ...responseData[key], id: key });
            }
          }
          return postsArray;
        })
      );
  }

----

```

lost connection between fetched data from service and template

### 13. Services & Components Working Together

```ts
constructor(private http: HttpClient, private postsService:
PostsService) {}

  onFetchPosts() {
    // Send Http request
    this.isFetching = true;
    this.postsService.fetchPosts().subscribe(
      posts => {
        this.isFetching = false;
        this.loadedPosts = posts;
      },
      error => {
        this.error = error.message;
        console.log(error);
      }
    );
  }
```

### 14. Sending a DELETE Request

```ts
onClearPosts() {
    // Send Http request
    this.postsService.deletePosts().subscribe(() => {
      this.loadedPosts = [];
    });
  }

----
// Service
deletePosts() {
    return this.http
      .delete('https://ng-complete-guide-c56d3.firebaseio.com/posts.json');
}

```

### 15. Handling Errors

![](angular.assets/2019-11-26-00-30-02.png)

read : false

```ts
ngOnInit() {
    this.isFetching = true;
    this.postsService.fetchPosts().subscribe(
      posts => {
        this.isFetching = false;
        this.loadedPosts = posts;
      },
      // Add
      error => {
        this.isFetching = false;
        this.error = error.message;
        console.log(error);
      }
    );
  }
```

### 16. Using Subjects for Error Handling

service

```ts
// add
error = new Subject<string>();

  createAndStorePost(title: string, content: string) {
    const postData: Post = { title: title, content: content };
    this.http
      .post<{ name: string }>(
        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json',
        postData,
        {
          observe: 'response'
        }
      )
      .subscribe(
        responseData => {
          console.log(responseData);
        },
        // Add
        error => {
          this.error.next(error.message);
        }
      );
  }
```

app.component.ts

```ts
// Add trong ham onInit
this.errorSub = this.postsService.error.subscribe((errorMessage) => {
  this.error = errorMessage;
});
// Destroy
```

### 17. Using the catchError Operator

service

```ts
fetchPosts() {
    // let searchParams = new HttpParams();
    // searchParams = searchParams.append('print', 'pretty');
    // searchParams = searchParams.append('custom', 'key');
    return this.http
      .get<{ [key: string]: Post }>(
        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json',
        // {
        //   headers: new HttpHeaders({ 'Custom-Header': 'Hello' }),
        //   params: searchParams,
        //   responseType: 'json'
        // }
      )
      .pipe(
        map(responseData => {
          const postsArray: Post[] = [];
          for (const key in responseData) {
            if (responseData.hasOwnProperty(key)) {
              postsArray.push({ ...responseData[key], id: key });
            }
          }
          return postsArray;
        }),
        // add
        catchError(errorRes => {
          // Send to analytics server
          return throwError(errorRes);
        })
      );
  }

```

### 18. Error Handling & UX

app

```ts
onFetchPosts() {
    // Send Http request
    this.isFetching = true;
    this.postsService.fetchPosts().subscribe(
      posts => {
        this.isFetching = false;
        this.loadedPosts = posts;
      },

      // Add
      error => {
        this.isFetching = false;
        this.error = error.message;
        console.log(error);
      }
    );
  }

onHandleError() {
    this.error = null;
  }
```

### 19. Setting Headers

```ts
let searchParams = new HttpParams();
searchParams = searchParams.append('print', 'pretty');
searchParams = searchParams.append('custom', 'key');
return this.http.get<{ [key: string]: Post }>(
  'https://ng-complete-guide-c56d3.firebaseio.com/posts.json',
  {
    headers: new HttpHeaders({ 'Custom-Header': 'Hello' }),
    params: searchParams,
    responseType: 'json',
  }
);
```

### 20. Adding Query Params

### 21. Observing Different Types of Responses

Có thể observe là body để chỉ nhận body, response để xem nhiều thứ khác như stt code

```ts
this.http
      .post<{ name: string }>(
        'https://ng-complete-guide-c56d3.firebaseio.com/posts.json',
        postData,
        {
          observe: 'response'  // 'body'
        }
      )
      // convert to js object

deletePosts() {
    return this.http
      .delete('https://ng-complete-guide-c56d3.firebaseio.com/posts.json', {
        observe: 'events',
        responseType: 'text'
      })
      .pipe(
        // execute without altering the response
        tap(event => {
          console.log(event);
          if (event.type === HttpEventType.Sent) {
            // ...
          }
          if (event.type === HttpEventType.Response) {
            console.log(event.body); // in ra null vì body trong event là null
          }
        })
      );
  }
```

![image-20200629213754067](angular.assets/image-20200629213754067.png)

![image-20200610223802139](angular.assets/image-20200610223802139.png)

### 22. Changing the Response Body Type

thay từ json sang text để test rồi revert lại

### 23. Introducing Interceptors

But let's imagine we want to attach this custom header to all our outgoing requests and a more realistic

scenario would be that you want to authenticate your user and you need to add a certain param or a certain

header to every outgoing request therefore so that the back-end can read that, you don't want to manually configure every request because that is very cumbersome and for that, you can add interceptors.

auth-interceptor.service

```ts
import {
  HttpInterceptor,
  HttpRequest,
  HttpHandler,
} from '@angular/common/http';

export class AuthInterceptorService implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    console.log('Request is on its way');
    // let req continue run
    return next.handle(req);
  }
}
```

the first key is the provide key and there, you have to use **HTTP_INTERCEPTORS**, all capital cases,

that is a type that is imported from @angular/common/http. So import that from this package

and use it here as a value for provide.

This is the token by which this injection can later be identified by Angular, so it will basically

know that all the classes you provide on that token, so by using that identifier, should be treated as HTTP interceptors and should therefore run their intercept method whenever a request leaves the application.

The second key you pass to that object is the use class key where you now point at your interceptor

class you want to add as an interceptor and here, that would be the auth interceptor service

which you of course also need to import.

Chay truoc khi req leave app => send

Khai báo:

```ts
providers: [
    {
      provide: HTTP_INTERCEPTORS, // this is a token
      useClass: AuthInterceptorService,
      multi: true // not replace exist intercepters
    }
  ],

```

![image-20200629214736597](angular.assets/image-20200629214736597.png)

### 24. Manipulating Request Objects

However, the request object itself is **immutable**, so you **can't set request URL to a new URL**, that

will not work and you also get an error here.

Instead if you want to modify the request, you have to create a new one, like modified request sounds

like a fitting name for the constant, where you call request clone and inside of **clone**, you pass in

a Javascript object where you now can overwrite all the core things. You could set a new URL here

or you could add new headers, if you want to keep the old headers by the way, then you simply do that

by using the request headers and calling append or you add new params or whatever you want.

Khi muốn thay đổi request obj

![image-20200610225106065](angular.assets/image-20200610225106065.png)

```ts
export class AuthInterceptorService implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    const modifiedRequest = req.clone({
      headers: req.headers.append('Auth', 'xyz'),
    });
    console.log(req.url);
    return next.handle(modifiedRequest);
  }
}
```

### 25. Response Interceptors

Có thể thay đổi response

![](angular.assets/2019-11-26-01-43-47.png)

Now here again, I'm just doing some logging but as I just mentioned, you could use other operators like

map here and even transform the response, that would be possible.

![image-20200610225315812](angular.assets/image-20200610225315812.png)

### 26. Multiple Interceptors

Tạo file logging-intercepter.service.ts

```ts
import {
  HttpInterceptor,
  HttpRequest,
  HttpHandler,
  HttpEventType
} from '@angular/common/http';
import { tap } from 'rxjs/operators';

export class LoggingInterceptorService implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler) {
    console.log('Outgoing request');
    console.log(req.url);
    console.log(req.headers);
    return next.handle(req).pipe(
      tap(event => {
        if (event.type === HttpEventType.Response) {
          console.log('Incoming response');
          console.log(event.body);
        }
      })
    );
  }
}

// Add - Luu y thu tu
providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: LoggingInterceptorService,
      multi: true
    },
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true
    }
  ],
```

![image-20200610225602519](angular.assets/image-20200610225602519.png)

### 27. Wrap Up

### 28. Useful Resources & Links.html

## 19. Course Project - Http

### 1. Module Introduction

SAVE AND FETCH in header

### 2. Backend (Firebase) Setup

Project name: ng-course-recipe-book / real time db

### 3. Setting Up the DataStorage Service

### 4. Storing Recipes

![image-20200610230750447](angular.assets/image-20200610230750447.png)

![image-20200610230835806](angular.assets/image-20200610230835806.png)

data-storage.service.ts ở header active 2 button

```ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { map } from 'rxjs/operators';

import { Recipe } from '../recipes/recipe.model';
import { RecipeService } from '../recipes/recipe.service';

@Injectable({ providedIn: 'root' })
export class DataStorageService {
  constructor(private http: HttpClient, private recipeService: RecipeService) {}

  storeRecipes() {
    const recipes = this.recipeService.getRecipes();
    this.http
      .put(
        'https://ng-course-recipe-book-65f10.firebaseio.com/recipes.json',
        recipes
      )
      .subscribe((response) => {
        console.log(response);
      });
  }

  fetchRecipes() {
    this.http
      .get<Recipe[]>(
        'https://ng-course-recipe-book-65f10.firebaseio.com/recipes.json'
      )
      // add => always have ingredients
      .pipe(
        map((recipes) => {
          // map step2 is an arraya func
          return recipes.map((recipe) => {
            return {
              ...recipe,
              ingredients: recipe.ingredients ? recipe.ingredients : [],
            };
          });
        })
      )
      // end add
      .subscribe((recipes) => {
        this.recipeService.setRecipes(recipes);
      });
  }
}
```

Nhớ import HttpClientModule

recipe.service.ts

```ts
private recipes: Recipe[] = [];

setRecipes(recipes: Recipe[]) {
    this.recipes = recipes;
    this.recipesChanged.next(this.recipes.slice());
  }
```

### 5. Fetching Recipes

### 6. Transforming Response Data

### 7. Resolving Data Before Loading

O page detail an reload => fail

![image-20200610231654060](angular.assets/image-20200610231654060.png)

boi vi khi k an nut FETCH DATA thi khi data empty o page detail => reload detail => fail

A **resolver** is essentially some code that runs before a route is loaded to ensure that certain data

the route depends on is there.

recipes-resolver.service

```ts
import { Injectable } from '@angular/core';
import {
  Resolve,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
} from '@angular/router';

import { Recipe } from './recipe.model';
import { DataStorageService } from '../shared/data-storage.service';
import { RecipeService } from './recipe.service';

@Injectable({ providedIn: 'root' })
export class RecipesResolverService implements Resolve<Recipe[]> {
  constructor(
    private dataStorageService: DataStorageService,
    private recipesService: RecipeService
  ) {}

  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    const recipes = this.recipesService.getRecipes();

    if (recipes.length === 0) {
      // Always get new one step 8
      return this.dataStorageService.fetchRecipes();
    } else {
      return recipes;
    }
  }
}
```

data-storage.service.ts

```ts
fetchRecipes() {
    return this.http
      .get<Recipe[]>(
        'https://ng-course-recipe-book-65f10.firebaseio.com/recipes.json'
      )
      .pipe(
        map(recipes => {
          return recipes.map(recipe => {
            return {
              ...recipe,
              ingredients: recipe.ingredients ? recipe.ingredients : []
            };
          });
        }),
        // add
        tap(recipes => {
          this.recipeService.setRecipes(recipes);
        })
      )
  }

  // header.component.ts
  onFetchData() {
    this.dataStorageService.fetchRecipes().subscribe();
  }
```

The tap operator allows us to execute some code here in place without altering the data that is funneled through that observable.

routing

```ts
children: [
  { path: '', component: RecipeStartComponent },
  { path: 'new', component: RecipeEditComponent },
  {
    path: ':id',
    component: RecipeDetailComponent,
    resolve: [RecipesResolverService],
  },
  {
    path: ':id/edit',
    component: RecipeEditComponent,
    resolve: [RecipesResolverService],
  },
];
```

### 8. Fixing a Bug with the Resolver

edit not save

It fetches new recipes from the server and that simply overwrites our existing recipes, including our changes to these recipes.

Now the solution is to first check whether we do have recipes and only fetch new ones if we don't.

`if (recipes.length === 0)`

## 20. Authentication & Route Protection in Angular

### 1. Module Introduction

### 2. How Authentication Works

Happen in the server not client
Traditional web using session but in angular we will handle with angular and its router, Server is Rest API  
Server and client is decouple

RestAPI là stateless vì vậy server không quan tâm đến client nên session không được sử dụng => token: string được mã hóa và giải mã bởi client, token được tạo ra ở server và mã hóa bằng thuật toán chỉ có server biết
Chỉ có server có thể validate incoming token

![](angular.assets/2019-11-26-23-19-19.png)

### 3. Adding the Auth Page

auth.component.html

```html
<div class="row">
  <div class="col-xs-12 col-md-6 col-md-offset-3">
    <form>
      <div class="form-group">
        <label for="email">E-Mail</label>
        <input type="email" id="email" class="form-control" />
      </div>
      <div class="form-group">
        <label for="password">Password</label>
        <input type="password" id="password" class="form-control" />
      </div>
      <div>
        <button class="btn btn-primary">Sign Up</button> |
        <button class="btn btn-primary">Switch to Login</button>
      </div>
    </form>
  </div>
</div>
```

auth.component.ts

```ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-auth',
  templateUrl: './auth.component.html',
})
export class AuthComponent {}
```

Nhớ khai báo component
Routing

```ts
  { path: 'shopping-list', component: ShoppingListComponent },
  { path: 'auth', component: AuthComponent }

```

Vào header thêm

```html
<li routerLinkActive="active">
  <a routerLink="/auth">Authenticate</a>
</li>
```

### 4. Switching Between Auth Modes

```ts
export class AuthComponent {
  isLoginMode = true;

  onSwitchMode() {
    this.isLoginMode = !this.isLoginMode;
  }

  onSubmit(form: NgForm) {
    console.log(form.value);
    form.reset();
  }
}
```

File auth.component.html

```html
<form #authForm="ngForm" (ngSubmit)="onSubmit(authForm)">
  <div class="form-group">
    <label for="email">E-Mail</label>
    <input
      type="email"
      id="email"
      class="form-control"
      ngModel
      name="email"
      required
      email
    />
  </div>
  <div class="form-group">
    <label for="password">Password</label>
    <input
      type="password"
      id="password"
      class="form-control"
      ngModel
      name="password"
      required
      minlength="6"
    />
  </div>
  <div>
    <button class="btn btn-primary" type="submit" [disabled]="!authForm.valid">
      {{ isLoginMode ? 'Login' : 'Sign Up' }}
    </button>
    |
    <button class="btn btn-primary" (click)="onSwitchMode()" type="button">
      Switch to {{ isLoginMode ? 'Sign Up' : 'Login' }}
    </button>
  </div>
</form>
```

### 5. Handling Form Input

### 6. Preparing the Backend

Vao database/ rule/

```js
{
  "read": "auth != null",
  "write": "auth != null"
}

```

![](angular.assets/2019-11-27-00-25-19.png)

Authen... / set up the sign in method

![](angular.assets/2019-11-27-00-37-11.png)

SAVE sau do vao tab USER

### 7. Make sure you got Recipes in your backend!.html

Make sure you got Recipes in your backend!
In order to continue with this module and send successful authenticated requests, you need to ensure that you got recipes stored in your backend database.

So in case you deleted those (or never added any), make sure you do add some recipes before you turn on protection as shown in the last lecture!

### 8. Preparing the Signup Request

GG: firebase auth rest api
https://firebase.google.com/docs/reference/rest/auth/

Xem Endpoint

### 9. Sending the Signup Request

auth-03-signup-request
Sign up with email / password

![](angular.assets/2019-11-27-00-45-22.png)  
get key from Project setting copy web api key paste vào url

auth.service.ts

```ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { catchError } from 'rxjs/operators';
import { throwError } from 'rxjs';

interface AuthResponseData {
  kind: string;
  idToken: string;
  email: string;
  refreshToken: string;
  expiresIn: string;
  localId: string;
}

@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(private http: HttpClient) {}

  signup(email: string, password: string) {
    return this.http.post<AuthResponseData>(
      'https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=[API_KEY]',
      {
        email: email,
        password: password,
        returnSecureToken: true,
      }
    );
  }
}
```

auth.component.ts

```ts
onSubmit(form: NgForm) {
    if (!form.valid) {
      return;
    }
    const email = form.value.email;
    const password = form.value.password;

    this.isLoading = true;
    if (this.isLoginMode) {
      // ...
    } else {
      this.authService.signup(email, password).subscribe(
        resData => {
          console.log(resData);
          this.isLoading = false;
        },
        errorMessage => {
          console.log(errorMessage);
          this.error = errorMessage;
          this.isLoading = false;
        }
      );
    }

    form.reset();
  }
```

![image-20200611083556258](angular.assets/image-20200611083556258.png)

![image-20200611083619149](angular.assets/image-20200611083619149.png)

Nếu đăng kí cùng email

![image-20200611083703725](angular.assets/image-20200611083703725.png)

### 10. Adding a Loading Spinner & Error Handling Logic

GG: css loading spinner
https://loading.io/css/
Vào share tạo folder loading tạo component loading va Khai bao

vào css chỉnh từ #fff thành màu #2102cf

auth.component.html

```html
<div class="alert alert-danger" *ngIf="error">
  <p>{{ error }}</p>
</div>
<div *ngIf="isLoading" style="text-align: center;">
  <app-loading-spinner></app-loading-spinner>
</div>
<form
  #authForm="ngForm"
  (ngSubmit)="onSubmit(authForm)"
  *ngIf="!isLoading"
></form>
```

### 11. Improving Error Handling

Xem lại thêm auth-03-signup-request
Hàm sign up auth.service.ts

```ts
signup(email: string, password: string) {
    return this.http
      .post<AuthResponseData>(
        'https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=AIzaSyDb0xTaRAoxyCgvaDF3kk5VYOsTwB_3o7Y',
        {
          email: email,
          password: password,
          returnSecureToken: true
        }
      )
      .pipe(
        catchError(errorRes => {
          // Ban dau dat trong auth.component.ts ham subscribe
          let errorMessage = 'An unknown error occurred!';
          if (!errorRes.error || !errorRes.error.error) {
            return throwError(errorMessage);
          }
          switch (errorRes.error.error.message) {
            case 'EMAIL_EXISTS':
              errorMessage = 'This email exists already';
          }
          return throwError(errorMessage);
        })
      );
  }

```

auth.component.ts

```ts
if (this.isLoginMode) {
  // ...
} else {
  this.authService.signup(email, password).subscribe(
    (resData) => {
      console.log(resData);
      this.isLoading = false;
    },
    (errorMessage) => {
      // add
      console.log(errorMessage);
      this.error = errorMessage;
      this.isLoading = false;
    }
  );
}
```

![image-20200611084912077](angular.assets/image-20200611084912077.png)

### 12. Sending Login Requests

service

```ts
  login(email: string, password: string) {
    return this.http
      .post<AuthResponseData>(
        'https://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyPassword?key=AIzaSyDb0xTaRAoxyCgvaDF3kk5VYOsTwB_3o7Y',
        {
          email: email,
          password: password,
          returnSecureToken: true
        }
      )
      .pipe(
        // # 13 add
        catchError(this.handleError),
        tap(resData => {
          this.handleAuthentication(
            resData.email,
            resData.localId,
            resData.idToken,
            +resData.expiresIn
          );
        })
      );
  }
```

auth.component.ts

```ts
// Add
let authObs: Observable<AuthResponseData>;

this.isLoading = true;

if (this.isLoginMode) {
  // add
  authObs = this.authService.login(email, password);
} else {
  authObs = this.authService.signup(email, password);
}

// đỡ subcrbe nhiều lần
authObs.subscribe(
  (resData) => {
    console.log(resData);
    this.isLoading = false;
  },
  (errorMessage) => {
    console.log(errorMessage);
    this.error = errorMessage;
    this.isLoading = false;
  }
);
// run meet error
```

### 13. Login Error Handling

sevice

```ts
private handleError(errorRes: HttpErrorResponse) {
    let errorMessage = 'An unknown error occurred!';
    if (!errorRes.error || !errorRes.error.error) {
      return throwError(errorMessage);
    }
    switch (errorRes.error.error.message) {
      case 'EMAIL_EXISTS':
        errorMessage = 'This email exists already';
        break;
      case 'EMAIL_NOT_FOUND':
        errorMessage = 'This email does not exist.';
        break;
      case 'INVALID_PASSWORD':
        errorMessage = 'This password is not correct.';
        break;
    }
    return throwError(errorMessage);
  }

  // add in login method
  .pipe(
        catchError(this.handleError)
      );
```

![image-20200611090150629](angular.assets/image-20200611090150629.png)

### 14. Creating & Storing the User Data

Tạo file user.model

```ts
export class User {
  constructor(
    public email: string,
    public id: string,
    private _token: string,
    private _tokenExpirationDate: Date
  ) {}

  get token() {
    // getter
    // !this._tokenExpirationDate : not exist
    if (!this._tokenExpirationDate || new Date() > this._tokenExpirationDate) {
      return null;
    }
    return this._token;
  }
}
```

auth.service.ts

```ts
  user = new BehaviorSubject<User>(null);


Thêm hàm tap: thực hiện action mà k change response

private handleAuthentication(
    email: string,
    userId: string,
    token: string,
    expiresIn: number
  ) {
    const expirationDate = new Date(new Date().getTime() + expiresIn * 1000); // milisecond
    const user = new User(email, userId, token, expirationDate);
    this.user.next(user);
  }

----
// Add ham signup and login
      .pipe(
        catchError(this.handleError),
        tap(resData => {
          this.handleAuthentication(
            resData.email,
            resData.localId,
            resData.idToken,
            +resData.expiresIn
          );
        })
      );
```

### 15. Reflecting the Auth State in the UI

auth-05-added-token-to-requests
auth.component.ts

```ts
authObs.subscribe(
  (resData) => {
    console.log(resData);
    this.isLoading = false;
    // Add
    this.router.navigate(['/recipes']);
  },
  (errorMessage) => {
    console.log(errorMessage);
    this.error = errorMessage;
    this.isLoading = false;
  }
);
```

Thêm button log out
header.component.ts

```ts
ngOnInit() {
    this.userSub = this.authService.user.subscribe(user => {
      this.isAuthenticated = !!user; // ? false: true
      console.log(!user);
      console.log(!!user);
    });
  }

```

Hien an button fetch...

```html
<li routerLinkActive="active" *ngIf="isAuthenticated">
  <a routerLink="/recipes">Recipes</a>
</li>
<li routerLinkActive="active" *ngIf="!isAuthenticated">
  <a routerLink="/auth">Authenticate</a>
</li>

<li *ngIf="isAuthenticated">
  <a style="cursor: pointer;">Logout</a>
</li>
```

![image-20200611092113554](angular.assets/image-20200611092113554.png)

### 16. Adding the Token to Outgoing Requests

Khi an FETCH DATA gap loi vi firebase cannot know we have a valid token

This **subject** is a subject to which we can subscribe and we'll get information whenever new data is emitted.

Now actually, there is a different type of subject RxJS offers which is called behavior subject.

Now this is also imported from RxJS and generally, it behaves just like the other subject, which means we can call next, to emit a value and we can subscribe to it to be informed about new values.

The difference is that **behavior subject** also gives subscribers **immediate access to the previously emitted value** even if they haven't subscribed at the point of time that value was emitted.

That means we can get access to be currently active user even if we only subscribe after that user has been emitted.

So this means when we fetch data and we need that token at this point of time, even if the user logged in before that point of time which will have been the case, **we get access to that latest user**.

Now therefore behavior subject also needs to be initialized with a starting value, which in my case will be null here, it has to be a user object and null is a valid replacement because I don't want to start off with a user.

auth.service.ts

```ts
user = new BehaviorSubject<User>(null);
// The difference is that behavior subjects gives subscribers immediate access to the previously emitted value even if they haven't subscribed at the point of time the value was emitted => get lastest user token even if user logged
```

data-storage.service.ts

```ts
fetchRecipes() {
    return this.authService.user.pipe(
      take(1), //take once value from observable and auto unsubcribes
      // exhaustMap is return observable
      exhaustMap(user => {
        return this.http.get<Recipe[]>(
          'https://ng-course-recipe-book-65f10.firebaseio.com/recipes.json',
          {
            params: new HttpParams().set('auth', user.token)
          }
        );
      }),
      map(recipes => {
        return recipes.map(recipe => {
          return {
            ...recipe,
            ingredients: recipe.ingredients ? recipe.ingredients : []
          };
        });
      }),
      tap(recipes => {
        this.recipeService.setRecipes(recipes);
      })
    );
  }
```

**Take** is also imported from rxjs/operator and take is called as a function and you simply pass a number to it and I pass one here and what this tells RxJS is that I only want to take one value from that observable and thereafter, **it should automatically unsubscribe**.

So this manages the subscription for me, gives me the latest user and unsubscribes and I'm not getting future users because I just want to get them on demand when fetch recipes is called, so whenever this code executes.

### 17. Attaching the Token with an Interceptor

auth-06-logout

Add auth-interceptor.service.ts

```ts
import { Injectable } from '@angular/core';
import {
  HttpInterceptor,
  HttpRequest,
  HttpHandler,
  HttpParams,
} from '@angular/common/http';
import { take, exhaustMap } from 'rxjs/operators';

import { AuthService } from './auth.service';

@Injectable()
export class AuthInterceptorService implements HttpInterceptor {
  constructor(private authService: AuthService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler) {
    // this.authService.user is an observable
    return this.authService.user.pipe(
      take(1),
      exhaustMap((user) => {
        // if user null cannot access token
        if (!user) {
          return next.handle(req);
        }
        const modifiedReq = req.clone({
          params: new HttpParams().set('auth', user.token),
        });
        // this is an observable
        return next.handle(modifiedReq);
      })
    );
  }
}
```

Khai bao

```ts
providers: [
    ShoppingListService,
    RecipeService,
    // Add
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true
    }
  ],
```

Sau do sua ham fetch data về ban đầu

data-storage.service.ts

```ts

  fetchRecipes() {
    return this.http
      .get<Recipe[]>(
        'https://ng-course-recipe-book-65f10.firebaseio.com/recipes.json'
      )
      .pipe(
        map(recipes => {
          return recipes.map(recipe => {
            return {
              ...recipe,
              ingredients: recipe.ingredients ? recipe.ingredients : []
            };
          });
        }),
        tap(recipes => {
          this.recipeService.setRecipes(recipes);
        })
      );
  }
}
```

### 18. Adding Logout

auth.service.ts

```ts
logout() {
    this.user.next(null);
    this.router.navigate(['/auth']);
  }
  // Vao header sua them ham logout
```

### 19. Adding Auto-Login

**When we re load a page the app will be reload => use local storage or cookie**

which we have once we reload the page because at the moment when we reload the page we lose all that status because when you reload the page, your Angular application restarts, the old one is basically dumped and since right now, we're managing everything in memory,

remember that we're storing the token in a user model which happens in Javascript only and which therefore

happens in memory, since we manage that all in memory, we'll lose all that state whenever the application restarts because that memory gets cleared automatically,

auth.service.ts

```ts
// handleAuthentication
private handleAuthentication(
    email: string,
    userId: string,
    token: string,
    expiresIn: number
  ) {
    const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);
    const user = new User(email, userId, token, expirationDate);
    this.user.next(user);
    this.autoLogout(expiresIn * 1000);
    // add
    // convert to string
    localStorage.setItem('userData', JSON.stringify(user));
  }



//
autoLogin() {
    const userData: {
      email: string;
      id: string;
      _token: string;
      _tokenExpirationDate: string;
    } = JSON.parse(localStorage.getItem('userData'));
    if (!userData) {
      return;
    }

    const loadedUser = new User(
      userData.email,
      userData.id,
      userData._token,
      new Date(userData._tokenExpirationDate)
    );

    if (loadedUser.token) {
      this.user.next(loadedUser);
      // end
      const expirationDuration =
        new Date(userData._tokenExpirationDate).getTime() -
        new Date().getTime();
      this.autoLogout(expirationDuration);
    }
  }


```

app.component.ts

```ts
ngOnInit() {
    this.authService.autoLogin();
  }
```

app.component.html

```html
<app-header></app-header>
<div class="container">
  <div class="row">
    <div class="col-md-12">
      <router-outlet></router-outlet>
    </div>
  </div>
</div>
```

### 20. Adding Auto-Logout

auth.service.ts

```ts
 private tokenExpirationTimer: any;
logout() {
    this.user.next(null);
    this.router.navigate(['/auth']);

    // Clear
    localStorage.removeItem('userData');
    // when click button logout
    if (this.tokenExpirationTimer) {
      clearTimeout(this.tokenExpirationTimer);
    }
    this.tokenExpirationTimer = null;
  }

autoLogout(expirationDuration: number) {
    this.tokenExpirationTimer = setTimeout(() => {
      this.logout();
    }, expirationDuration); // thay expirationDuration  = 2000 de xem khi log in co log out after 2s chứ bình thưởng là 3600000
  }

// handleAuthentication
private handleAuthentication(
    email: string,
    userId: string,
    token: string,
    expiresIn: number
  ) {
    const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);
    const user = new User(email, userId, token, expirationDate);
    this.user.next(user);
    // add
    this.autoLogout(expiresIn * 1000);
    localStorage.setItem('userData', JSON.stringify(user));
  }
```

### 21. Adding an Auth Guard

Do you remember the routing section? There we had a look at **route guards** and that is exactly what we need here. A **route guard allows us to run logic right before a route is loaded** and we can deny access if a certain condition is not met and this is exactly what we need here. For that in the auth folder, let's create a new file and I'll name it auth.guard.ts

Khi chỉnh sửa directly on url => back về home

auth-08-finished
auth.guard.ts

```ts
import {
  CanActivate,
  ActivatedRouteSnapshot,
  RouterStateSnapshot,
  Router,
  UrlTree,
} from '@angular/router';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { map, tap, take } from 'rxjs/operators';

import { AuthService } from './auth.service';

@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    router: RouterStateSnapshot
  ):
    | boolean
    | UrlTree
    | Promise<boolean | UrlTree>
    | Observable<boolean | UrlTree> {
    return this.authService.user.pipe(
      take(1), // take the lastest user them unsubcribed => don't need listen
      map((user) => {
        const isAuth = !!user;
        if (isAuth) {
          return true;
        }
        // cach 2
        return this.router.createUrlTree(['/auth']);
      })
      // cách 1
      //	map(user => {
      //    const isAuth = !!user;
      //    return !!user;
      //    })
      //, tap(isAuth => {
      //   if (!isAuth) {
      //     this.router.navigate(['/auth']);
      //   }
      // })
    );
  }
}
```

we essentially set up an ongoing subscription here though. This user subject of course can emit

data more than once and I don't want that here, this can lead to strange side effects if our guard keeps on listening to that subject, instead we want to look inside the user value for one time only and then not care about it anymore unless

we run the guard again and therefore here just as in other places too, we should use take one to make

sure that we always just take the latest user value and then unsubscribe for this guard execution so that

we don't have an ongoing listener to that which we really don't need and therefore here, you need to

import the take operator, the take rxjs/operator and add it here in front of map so that we

don't have an ongoing user subscription.

routing

```ts
{
    path: 'recipes',
    component: RecipesComponent,
    // add
    canActivate: [AuthGuard],
    children: [
      { path: '', component: RecipeStartComponent },
      { path: 'new', component: RecipeEditComponent },
      {
        path: ':id',
        component: RecipeDetailComponent,
        resolve: [RecipesResolverService]
      },
      {
        path: ':id/edit',
        component: RecipeEditComponent,
        resolve: [RecipesResolverService]
      }
    ]
  }
```

### 22. Wrap Up

### 23. Useful Resources & Links.html

Useful Resources & Links
Useful Docs:

Firebase Auth REST API Docs: https://firebase.google.com/docs/reference/rest/auth

More on JWT: https://jwt.io

## 21. Dynamic Components

### 1. Module Introduction

Now what are dynamic components? Dynamic components are essentially components which you create dynamically

at runtime.

So let's say you want to show an alert,

you want to show a modal, some overlay which should only be loaded upon a certain action,

for example you have an error and you want to not show that error box which we're currently showing

in our course project but we want to show an overlay on the entire screen or something like that, that

could be done or could be implemented by using dynamic components. And dynamic components is not a

specific term, not a specific feature provided by Angular but we can simply add components that we load

through our code and that's exactly what we'll do in this module. You will learn how to create such a

component and how to then load it on demand, how to communicate with it and also how to get rid of it.

### 10. Useful Resources & Links.html

Useful Resources:

Official Docs: https://angular.io/guide/dynamic-component-loader

### 2. Adding an Alert Modal Component

Vào folder share tại component alert
alert.component.html

```html
<div class="backdrop" (click)="onClose()"></div>
<div class="alert-box">
  <p>{{ message }}</p>
  <div class="alert-box-actions">
    <button class="btn btn-primary" (click)="onClose()">Close</button>
  </div>
</div>
```

nho khai bao modules

![image-20200611141137611](angular.assets/image-20200611141137611.png)

alert.component.ts

```ts
@Component({
  selector: 'app-alert',
  templateUrl: './alert.component.html', // xem css
  styleUrls: ['./alert.component.css'],
})
export class AlertComponent {
  @Input() message: string;
  @Output() close = new EventEmitter<void>();

  onClose() {
    this.close.emit();
  }
}
```

css

```css
.backdrop {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.75);
  z-index: 50;
}

.alert-box {
  position: fixed;
  top: 30vh;
  left: 20vw;
  width: 60vw;
  padding: 16px;
  z-index: 100;
  background: white;
  box-shadow: 0 2px 8px rbga(0, 0, 0, 0.26);
}

.alert-box-actions {
  text-align: right;
}
```

auth.component.html

```html
<app-alert
  [message]="error"
  *ngIf="error"
  (close)="onHandleError()"
></app-alert>
```

auth.component.ts

```ts
onHandleError() {
    this.error = null;
  }
```

### 3. Understanding the Different Approaches

![](angular.assets/2019-11-30-01-49-08.png)

The alternative is that you use something which in the past was named **dynamic component loader**.

Now this was a helper utility that doesn't exist anymore or that you shouldn't use anymore but in the

end, it's now about a general concept you could say of creating a component in code and then manually

attaching it to the DOM.

So there, you have to control, in your code by yourself, how that component is instantiated, that data is

passed into it and also that it is removed.

So everything ngIf does for you, you have to do on your own there. Still, this approach can be useful,

it also of course allows you to control it entirely from code and you don't have to touch the template.

### 4. Using ngIf

auth.component.ts

```ts
onHandleError() {
    this.error = null;
  }
```

### 5. Preparing Programmatic Creation

auth.component.ts

```ts
error: string = null;
// give angular a ref, a pointer to the place in the DOM
  @ViewChild(PlaceholderDirective, { static: false }) alertHost: PlaceholderDirective;

  private closeSub: Subscription;

constructor(
    private authService: AuthService,
    private router: Router,
    private componentFactoryResolver: ComponentFactoryResolver // add inject
  ) {}

// add
private showErrorAlert(message: string) {
    // const alertCmp = new AlertComponent(); => ts will fail to create component

    // create component for you
    const alertCmpFactory = this.componentFactoryResolver.resolveComponentFactory(
      AlertComponent
    );
    const hostViewContainerRef = this.alertHost.viewContainerRef;
    hostViewContainerRef.clear();

    const componentRef = hostViewContainerRef.createComponent(alertCmpFactory);

    componentRef.instance.message = message;
    this.closeSub = componentRef.instance.close.subscribe(() => {
      this.closeSub.unsubscribe();
      hostViewContainerRef.clear();
    });
  }

// ham onsubmit
onSubmit(form: NgForm) {
    // .....

	errorMessage => {
        console.log(errorMessage);
        this.error = errorMessage;
        // Add start
        this.showErrorAlert(errorMessage);
        // add end
        this.isLoading = false;
      }
```

Tạo placeholder.directive.ts

```ts
import { Directive, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appPlaceholder]',
})
export class PlaceholderDirective {
  //inject
  constructor(public viewContainerRef: ViewContainerRef) {}
}
```

### 6. Creating a Component Programmatically

auth.component.html

```html
<ng-template appPlaceholder></ng-template>
```

![image-20200611143217725](angular.assets/image-20200611143217725.png)

### 7. Understanding entryComponents

![image-20200629234952252](angular.assets/image-20200629234952252.png)

Meet strange error

**If you're not getting this error or if it just works for you then this is the case because you are using**

**angular 9 or higher**.

This is simply a tiny changed it was made behind the scenes of angular sort of general syntax since

on didn't change what I showed you works and all angular versions but in angular 9 or higher.

There was a behind the scenes change which makes this work out of the box which of course is great but

if you are getting this error which is also not unlikely because not everyone is using the latest version

well then here's why we get it.

app.module

```ts
 bootstrap: [AppComponent],
 // declare without routing and selector
  entryComponents: [
    AlertComponent
  ]
```

auth.component.ts

```ts
// Add closeSub
ngOnDestroy() {
    if (this.closeSub) {
      this.closeSub.unsubscribe();
    }
  }
```

There is a property we haven't worked with thus far and Data's entry components entry components also

is an array and it's an array of components types but only of components that will eventually need to

be created without a selector or the root content being used.

So whenever a component is created by selector or you use it with the root configuration you don't need

to add it here which is why.

Thus far we haven't the added anything to entry components for alert components differently.

If you're in a project with angular 9 or higher you can omit entry components by default because they're

angular under the hood uses a different rendering engine. Its name is Ivy and there.

It works differently under the hood so the Iverson text doesn't change.

The only difference is that you can omit entry components.

You don't have to specifying a day or two isn't a problem. You will never make an error.

If you do specify entry components just in some cases you could omit it.

Vì tạo bằng cách 2 nên nó k biết tìm ở đâu => entry

### 8. Data Binding & Event Binding

### 9. Wrap Up

## 22. Angular Modules & Optimizing Angular Apps

### 1. Module Introduction

### 2. What are Modules

![](angular.assets/2019-11-30-15-57-21.png)

### 3. Analyzing the AppModule

![](angular.assets/2019-11-30-16-08-07.png)

### 4. Getting Started with Feature Modules

Tạo file recipes.module

```ts
@NgModule({
  declarations: [
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    RecipeStartComponent,
    RecipeEditComponent,
  ],
  // fix next
  imports: [RouterModule, CommonModule, ReactiveFormsModule],
  exports: [
    RecipesComponent,
    RecipeListComponent,
    RecipeDetailComponent,
    RecipeItemComponent,
    RecipeStartComponent,
    RecipeEditComponent,
  ],
})
export class RecipesModule {}
```

vào app

```ts
imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    // Add import
    RecipesModule
  ],

```

CommonModule fix lỗi cho ngIf, ngfor

So to be able to use ngFor in the recipes module, besides the router module, we probably also need

the browser module.

However, this is now just a special case and the only special case. The browser module must only be used

once and that is in the app module because it does more than just add ngIf and ngFor, it does

some general application start up work that only has to run once. Instead of the browser module,

use the common module in all other places, in all other modules where you want to get access to ngIf and

ngFor.

### 5. Splitting Modules Correctly

### 6. Adding Routes to Feature Modules

create new file, cut from routing to here
recipes-routing.module.ts

```ts
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';

import { RecipesComponent } from './recipes.component';
import { AuthGuard } from '../auth/auth.guard';
import { RecipeStartComponent } from './recipe-start/recipe-start.component';
import { RecipeEditComponent } from './recipe-edit/recipe-edit.component';
import { RecipeDetailComponent } from './recipe-detail/recipe-detail.component';
import { RecipesResolverService } from './recipes-resolver.service';

const routes: Routes = [
  {
    path: 'recipes',
    component: RecipesComponent,
    canActivate: [AuthGuard],
    children: [
      { path: '', component: RecipeStartComponent },
      { path: 'new', component: RecipeEditComponent },
      {
        path: ':id',
        component: RecipeDetailComponent,
        resolve: [RecipesResolverService],
      },
      {
        path: ':id/edit',
        component: RecipeEditComponent,
        resolve: [RecipesResolverService],
      },
    ],
  },
];

@NgModule({
  imports: [RouterModule.forChild(routes)],
  exports: [RouterModule],
})
export class RecipesRoutingModule {}
```

Khai bao trong Module moi

```ts
imports: [
    RouterModule,
    CommonModule,
    ReactiveFormsModule,
    RecipesRoutingModule // add
  ],


```

### 7. Component Declarations

Because using routing recipe internal so **you can remove it**

The other important thing I wanted to highlight is that now that we manage the loading of our components,

here with recipes routing, we do define which component should be loaded for which route, there is no reason

to still export all these recipe components because we're now only using them internally in the recipes

module. We're using them either embedded into other components here or by loading them through the recipes routing

module, both is part of this file. So there is no reason to export the recipe components anymore

```ts
exports: [
  RecipesComponent,
  RecipeListComponent,
  RecipeDetailComponent,
  RecipeItemComponent,
  RecipeStartComponent,
  RecipeEditComponent,
];
```

### 8. The ShoppingList Feature Module

```ts
@NgModule({
  declarations: [ShoppingListComponent, ShoppingEditComponent],
  imports: [
    FormsModule,
    RouterModule.forChild([
      { path: 'shopping-list', component: ShoppingListComponent },
    ]),
    SharedModule, // add next nếu bt thì commonmodule and form module là ok
  ],
})
export class ShoppingListModule {}
// Sau do vao AppModule khai bao
```

### 9. Understanding Shared Modules

![image-20200611155248204](angular.assets/image-20200611155248204.png)

shared.module.ts

```ts
import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

import { AlertComponent } from './alert/alert.component';
import { LoadingSpinnerComponent } from './loading-spinner/loading-spinner.component';
import { PlaceholderDirective } from './placeholder/placeholder.directive';
import { DropdownDirective } from './dropdown.directive';

@NgModule({
  declarations: [
    AlertComponent,
    LoadingSpinnerComponent,
    PlaceholderDirective,
    DropdownDirective,
  ],
  imports: [CommonModule],
  exports: [
    AlertComponent,
    LoadingSpinnerComponent,
    PlaceholderDirective,
    DropdownDirective,
    CommonModule,
  ],
  entryComponents: [AlertComponent],
})
export class SharedModule {}
```

use in app.modules.ts xóa những cái đã được định nghĩa trong share

```ts
@NgModule({
  declarations: [AppComponent, HeaderComponent, AuthComponent],
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule,
    HttpClientModule,
    AppRoutingModule,
    RecipesModule,
    ShoppingListModule,
    SharedModule,
  ],
  providers: [
    ShoppingListService,
    RecipeService,
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true,
    },
  ],
  bootstrap: [AppComponent],
})
export class AppModule {}
```

### 10. Understanding the Core Module

![](angular.assets/2019-11-30-22-56-11.png)
Nen sử dụng @Injectable({ providedIn: 'root' }) thay vì khai báo trong
app.modules

core.module.ts

```ts
@NgModule({
  providers: [
    ShoppingListService,
    RecipeService,
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true,
    },
  ],
})
export class CoreModule {}
```

app.module.ts

```ts
@NgModule({
  declarations: [AppComponent, HeaderComponent, AuthComponent],
  imports: [
    BrowserModule,
    FormsModule,
    ReactiveFormsModule, // phan sau xoa
    HttpClientModule,
    AppRoutingModule,
    RecipesModule,
    ShoppingListModule,
    SharedModule,
    // Add new
    CoreModule
  ],
```

The core module is basically there to make the app module a bit leaner, let's say in the app module, we

have the app component and here we are providing two services.

Well then we can use a core module to move these services out of the app module into the core module

which then in turn is added back to the app module.

The alternative to that would of course be to use provided in in @injectable on the services which

### 11. Adding an Auth Feature Module

auth.module.ts

```ts
@NgModule({
  declarations: [AuthComponent],
  imports: [
    CommonModule,
    FormsModule,
    RouterModule.forChild([{ path: '', component: AuthComponent }]),
    SharedModule, // error loading spiner
  ],
})
export class AuthModule {}
```

### 12. Understanding Lazy Loading

![](angular.assets/2019-11-30-23-10-48.png)

Chỉ load những gì mình cần root route content, xóa url ở file con  
Khi reload F12 o tab network a bunch of files were downloaded

![image-20200611160535656](angular.assets/image-20200611160535656.png)

---

recipes-routing.module.ts

```ts
 path: '', // replace recipes with ''
    component: RecipesComponent,
    canActivate: [AuthGuard]
```

app-routing.module.ts

```ts
const appRoutes: Routes = [
  { path: '', redirectTo: '/recipes', pathMatch: 'full' },
  // Add
  { path: 'recipes', loadChildren: './recipes/recipes.module#RecipesModule' },
  // add in 15
  {
    path: 'shopping-list',
    loadChildren: './shopping-list/shopping-list.module#ShoppingListModule',
  },
  {
    path: 'auth',
    loadChildren: './auth/auth.module#AuthModule',
  },
];
// => only download bunch of code that you need it
```

app.modules

```ts
@NgModule({
  declarations: [AppComponent, HeaderComponent],
  // Delete RecipeModule
  imports: [
    BrowserModule,
    HttpClientModule,
    AppRoutingModule,
    SharedModule,
    CoreModule
  ],
  bootstrap: [AppComponent]
})

```

### 13. Implementing Lazy Loading

### 14. Alternative Lazy Loading Syntax.html

If you're using Angular 8+, you can use an alternative syntax for specifying lazy-loaded routes:

Instead of

```ts
const routes: Routes = [
  {
    path: 'your-path',
    loadChildren: './your-module-path/module-name.module#ModuleName',
  },
];
```

you can use

```ts
const routes: Routes = [
  {
    path: 'your-path',
    loadChildren: () =>
      import('./your-module-path/module-name.module').then((m) => m.ModuleName),
  },
];
```

Please note, that you need to ensure that in your tsconfig.json file, you use

```ts
"module": "esnext",

```

instead of

```ts
"module": "es2015",

```

Why would you use this syntax? In the future, it'll replace the "string-only" approach (i.e. the first alternative mentioned here). It also will give you better IDE support.

### 15. More Lazy Loading

shopping-list.module.ts

Add and delete path in file module.ts

```ts
@NgModule({
  declarations: [ShoppingListComponent, ShoppingEditComponent],
  imports: [
    FormsModule,
    RouterModule.forChild([
      // modify
      { path: '', component: ShoppingListComponent },
    ]),
    SharedModule,
  ],
})
export class ShoppingListModule {}
```

app.module.ts
Xoa ShoppingListModule, AuthModule

![image-20200611163345520](angular.assets/image-20200611163345520.png)

### 16. Preloading Lazy-Loaded Code

Now the downside of that of course is that this is downloaded and parsed

just when we need it, leading to a very tiny delay in our application. We might not see that here because

the module is small and the internet connection is fast but the bigger the module and the slower the internet connection or for example if you temporarily have

no internet connection, the longer that delay will be and therefore, we can actually tell Angular to preload lazy loaded modules to avoid this delay.

Avoid delay because internet...
app-routing

```ts
@NgModule({
  imports: [
    RouterModule.forRoot(appRoutes, { preloadingStrategy: PreloadAllModules })
  ],
  exports: [RouterModule]
  // add preloadingStrategy prepare to load => optimize
})

```

But with preload all modules imported and set here as a preloading strategy, you're telling Angular generally we're using lazy loading, so it will not put all that code into one bundle, it will split it as we saw it but it will preload the bundles as soon as possible, so when we are on the auth page, it will already preload recipes and shopping list so that these code bundles are already available when we need them.

![image-20200611164044210](angular.assets/image-20200611164044210.png)

### 17. Modules & Services

![](angular.assets/2019-11-30-23-56-50.png)

### 18. Loading Services Differently

Tạo file logging.service.ts

```ts
import { Injectable } from '@angular/core';

@Injectable({ providedIn: 'root' })
export class LoggingService {
  lastlog: string;

  printLog(message: string) {
    console.log(message);
    console.log(this.lastlog);
    this.lastlog = message;
  }
}
```

app.component.ts

```ts
ngOnInit() {
    this.authService.autoLogin();
    // Add
    this.loggingService.printLog('Hello from AppComponent ngOnInit');
  }

  // add in shopping-list.component.ts

```

Khi chay in lastlog dau la undefined va cai sau o shopping list co value => same instance when use Injectable

![image-20200611164543754](angular.assets/image-20200611164543754.png)

---

Thêm ` providers: [LoggingService]` ở app.module or core.module để test => same instance when use Injectable
File shopping list module thì khác instance with lazy khi khai bao o app.module va shopping-list.module => undefined all

![image-20200611164814137](angular.assets/image-20200611164814137.png)

We're using a separate instance in our application in general for the service provided in app module

but since the shopping list module brings its own instance by providing the logging service again here,

the shopping list module and all the components in there use a separate instance of the logging

service, they don't use the application-wide available instance, they use their own instance created

by that child injector.

shared.module : eager loading => undefined all

### 19. Ahead-of-Time Compilation

So before we deploy our built angular app onto a server and that is ahead of time where is this just

in time compilation.

![](angular.assets/2019-12-01-00-23-02.png)

recipe-edit

```ts
// modify because build fail
get ingredientsControls() {
    return (this.recipeForm.get('ingredients') as FormArray).controls;
  }

```

```html
<div
  class="row"
  *ngFor="let ingredientCtrl of ingredientsControls; let i = index"
  [formGroupName]="i"
  style="margin-top: 10px;"
></div>
```

Vào folder dist sau khi build

```ts
Ng build --prod
// build to few file to deloy
```

We want to have a good development experience with rich error messages and so on but as soon as we're

preparing ourselves for production and for building our angular app for production to then upload it

on a server we want to optimize our code as much as possible and shrink it to a small of a bunch less

possible. And we do that with a command you'll also see in the deployment section I quit.

### 21. Useful Resources & Links.html

Useful Resources & Links
Useful Resources:

Official Docs: https://angular.io/guide/ngmodules

NgModules FAQ: https://angular.io/guide/ngmodule-faq

## 23. Deploying an Angular App

### 1. Module Introduction

### 2. Deployment Preparation & Steps

![](angular.assets/2019-12-01-00-36-36.png)

### 3. Using Environment Variables

environment.ts,
environment.prod.ts // build for production

```ts
export const environment = {
  production: false,
  firebaseAPIKey: 'AIzaSyDb0xTaRAoxyCgvaDF3kk5VYOsTwB_3o7Y'
};

...
// auth.service.ts
import { environment } from '../../environments/environment';

```

### 4. Deployment Example Firebase Hosting

GG: static website host
aws s3
firebase hosting
vao doc firebase.gooole.com => install CLI

```
npm install -g firevbse-tools
firebase login
firebase init // connect to app
Chon hosting
nhap dist/ten-project  // use for public dir
yes // rewrite all url
no // ovewrite

firebase deloy
```

### 5. Server Routing vs Browser Routing.html

Server Routing vs Browser Routing
When deploying your Angular app, it's really important to make sure that your server (like S3) is configured to always serve the index.html file.

Here's why: https://academind.com/learn/angular/angular-q-a/#how-to-fix-broken-routes-after-deployment

## 24. Bonus Working with NgRx in our Project

### 1. Module Introduction

### 2. What is Application State

Nếu app lớn hơn các state phụ thuộc vào component, component phụ thuộc vào service
State is app is loading state => wait fetch data
application state => affect all app

![](angular.assets/2019-12-01-08-31-14.png)

State is not just data like stored exercises or recipes, state could also be things like "this app is currently

waiting for some data to be fetched", so the app is in a loading state, it's showing a spinner maybe.

So basically, any data, any information that controls what should be visible on the screen, that is state.

![](angular.assets/2019-12-01-08-41-12.png)  
![](angular.assets/2019-12-01-08-42-43.png)

Well we already have a remedy to that and that is rxjs, at least partly. RxJS already allows

us to create a streamlined state management experience. With RxJS and there specifically with

subjects, we can react to user events in the user interface or to application events like some data fetching

finishing, we can react to such a state changing event, so to an event where we want to update some

data or some information in our app by using observables or as I said, subjects and we can emit or next a

new data piece there and maybe use operators to even transform data in the way we want it and then

listen to such state changes in other parts of the application where we need it to then update the UI

and we're doing this already as well.

If I dive back into the code and back into the recipes service, there indeed, recipes are managed

with the help of these recipes changed subject here.

### 3. What is NgRx

This RxJS driven approach has some issues as I outlined, to be precise you could still have an

app where state can be updated from anywhere because you maybe failed to set up a clear flow of data.

Your state might also possibly be mutable, which means that whilst you might have only a couple of places

where your state is intended to change, your code in there might not force you to state the old data

by overwriting it with new data and that is what I would recommend doing though because otherwise Angular

sometimes doesn't pick up some changes to your state because of the reference type nature of objects

and arrays in Javascript, where if you only change a property of an object, the overall object didn't

change and therefore such a state change might not get picked up.

And in addition, handling side effects and that means things like HTTP requests,

it's unclear where this should happen - should you write the code for sending them in a component? Should

you do it in a service?

![](angular.assets/2019-12-01-08-47-22.png)  
Redux là 1 js obj lớn gồm all data, central store  
Reducer là js func that get current state which stored in a store, copy in and change the copy return a copy of old state

**Redux** is a state management pattern, it's also a library that helps you implement that pattern into any application.

The idea behind Redux, so behind that approach for managing state and always keep in mind, state is just data or information in your app, so the idea behind managing that state with Redux is that you **have one central store in your entire application that holds your application state**, so think of that as a large Javascript object that contains all the data the different parts of your application need, of course kind of categorized in properties that might then hold nested objects but in the end that's the idea, have one large data store. Your different parts of the application, services and components, can still interact with each other but they receive their state from that store,

so that store is the single source of truth that manages the entire application state.

![image-20200611182807494](angular.assets/image-20200611182807494.png)

![](angular.assets/2019-12-01-08-57-27.png)

It also embraces RxJS and observables, so all the state is managed as one large observable

you could say and that also can yield certain advantages,

for example you can use all the observable operators to then edit the state you are fetching in the

component where you need it in the way you need it there,

this will not change the store state of course

and it of course also supports TypeScript.

### 4. Getting Started with Reducers

```ts
Npm install –-save @ngrx/store

```

Tạo file shopping-list.reducer.ts

```ts
import { Action } from '@ngrx/store';

import { Ingredient } from '../shared/ingredient.model';

const initialState = {
  ingredients: [new Ingredient('Apples', 5), new Ingredient('Tomatoes', 10)],
};

export function shoppingListReducer(state = initialState, action: Action) {
  switch (action.type) {
    case 'ADD_INGREDIENT':
      return {
        ...state,
        ingredients: [...state.ingredients, action], // action duoc them tam
      };
  }
}
```

State is immutable

So the first time this reducer will run, it will receive that initial state for subsequent actions,

so once the state has been initialized for the first time and it will be initialized globally

by NgRx, once it has been initialized, state will always be the previous state only for the first time,

so when NgRx is initializing the application state, it will be our initial state.

### 5. Adding Logic to the Reducer

### 6. Understanding & Adding Actions

Tạo file shopping-list.actions

```ts
import { Action } from '@ngrx/store';

import { Ingredient } from '../../shared/ingredient.model';

export const ADD_INGREDIENT = 'ADD_INGREDIENT';

export class AddIngredient implements Action {
  readonly type = ADD_INGREDIENT;
  payload: Ingredient; // riêng tên này có thể thay đổi trừ type
}
```

Khi export nhiều thứ từ 1 class
shopping-list.reducer

```ts
import { Ingredient } from '../../shared/ingredient.model';
import * as ShoppingListActions from './shopping-list.actions';

const initialState = {
  ingredients: [new Ingredient('Apples', 5), new Ingredient('Tomatoes', 10)],
};

export function shoppingListReducer(
  state = initialState,
  action: ShoppingListActions.AddIngredient
) {
  switch (action.type) {
    case ShoppingListActions.ADD_INGREDIENT:
      return {
        ...state,
        ingredients: [...state.ingredients, action.payload],
      };
    default:
      return state;
  }
}
```

### 7. Setting Up the NgRx Store

app.module.ts

```ts
import { StoreModule } from '@ngrx/store';
import { shoppingListReducer } from './shopping-list/store/shopping-list.reducer';

imports: [
    BrowserModule,
    HttpClientModule,
    AppRoutingModule,
    // Add
    StoreModule.forRoot({shoppingList: shoppingListReducer}),
    SharedModule,
    CoreModule
  ],

```

So now all action will dispatch to reducer

### 8. Selecting State

shopping-list.component.ts

```ts
ingredients: Observable<{ ingredients: Ingredient[] }>; // add
constructor(
    private slService: ShoppingListService,
    private loggingService: LoggingService,
    private store: Store<{ shoppingList: { ingredients: Ingredient[] } }> // thêm
  ) {}

ngOnInit() {
    this.ingredients = this.store.select('shoppingList'); // select a slice of your state
    // this.ingredients = this.slService.getIngredients();
    // this.subscription = this.slService.ingredientsChanged.subscribe(
    //   (ingredients: Ingredient[]) => {
    //     this.ingredients = ingredients;
    //   }
    // );

    this.loggingService.printLog('Hello from ShoppingListComponent ngOnInit!');
  }
```

shopping-list.component.html

```html
<a
  class="list-group-item"
  style="cursor: pointer"
  *ngFor="let ingredient of (ingredients | async).ingredients; let i = index"
  (click)="onEditItem(i)"
>
</a>
```

(ingredients | async).ingredients bằng cách này nó sẽ subcribe ingredients observable
Reducer

```ts
export function shoppingListReducer(
  state = initialState,
  action: ShoppingListActions.ShoppingListActions
) {
  switch (action.type) {
    case ShoppingListActions.ADD_INGREDIENT:
      return {
        ...state,
        ingredients: [...state.ingredients, action.payload],
      };
    case ShoppingListActions.ADD_INGREDIENTS:
      return {
        ...state,
        ingredients: [...state.ingredients, ...action.payload],
      };
    // add
    default:
      return state;
  }
}
```

we need to add a default case to our switch statement to handle any cases we're not explicitly handling and we're only handling one explicit case here and that's not the action NgRx will dispatch automatically when it starts, it kind of dispatches an initialization action and we need to handle this and we can handle it here with the default case

and there I simply want to return the unchanged state and that will now be the initial state.

### 9. Dispatching Actions

Now here, NgRx and Angular should also clear the subscription for you

but to be super safe, I would recommend storing this in a subscription property and try clearing it manually

as well just to avoid memory leaks and bugs

shopping-edit.component.ts

```ts
constructor(
    private slService: ShoppingListService,
    // Add
    private store: Store<{ shoppingList: { ingredients: Ingredient[] } }>
  ) {}

onSubmit(form: NgForm) {
    const value = form.value;
    const newIngredient = new Ingredient(value.name, value.amount);
    if (this.editMode) {
      this.slService.updateIngredient(this.editedItemIndex, newIngredient);
    } else {
      // this.slService.addIngredient(newIngredient);
      this.store.dispatch(new ShoppingListActions.AddIngredient(newIngredient));
    }
    this.editMode = false;
    form.reset();
  }

```

shopping-list.action.ts

```ts
import { Action } from '@ngrx/store';

import { Ingredient } from '../../shared/ingredient.model';

export const ADD_INGREDIENT = 'ADD_INGREDIENT';
export const ADD_INGREDIENTS = 'ADD_INGREDIENTS';

export class AddIngredient implements Action {
  readonly type = ADD_INGREDIENT;

  constructor(public payload: Ingredient) {} // change payload properties
}
```

![image-20200611210145619](angular.assets/image-20200611210145619.png)

### 10. Multiple Actions

shopping-list.action.ts

```ts
export class AddIngredients implements Action {
  readonly type = ADD_INGREDIENTS;

  constructor(public payload: Ingredient[]) {}
}

export type ShoppingListActions = AddIngredient | AddIngredients;
```

Recipe.service

```ts
 constructor(
    private slService: ShoppingListService,
    // Add
    private store: Store<{ shoppingList: { ingredients: Ingredient[] } }>
  ) {}

addIngredientsToShoppingList(ingredients: Ingredient[]) {
    // this.slService.addIngredients(ingredients);
    this.store.dispatch(new ShoppingListActions.AddIngredients(ingredients));
  }

```

shopping-list.reducer.ts

```ts
import { Ingredient } from '../../shared/ingredient.model';
import * as ShoppingListActions from './shopping-list.actions';

const initialState = {
  ingredients: [new Ingredient('Apples', 5), new Ingredient('Tomatoes', 10)],
};

export function shoppingListReducer(
  state = initialState,
  action: ShoppingListActions.ShoppingListActions // declare
) {
  switch (action.type) {
    case ShoppingListActions.ADD_INGREDIENT:
      return {
        ...state,
        ingredients: [...state.ingredients, action.payload],
      };
    case ShoppingListActions.ADD_INGREDIENTS:
      return {
        ...state,
        ingredients: [...state.ingredients, ...action.payload],
      };
    default:
      return state;
  }
}
```

recipe-detail.component.ts

```ts
// button add all
onAddToShoppingList() {
    this.recipeService.addIngredientsToShoppingList(this.recipe.ingredients);
  }
```

### 11. Preparing Update & Delete Actions

action

```ts
export class UpdateIngredient implements Action {
  readonly type = UPDATE_INGREDIENT;

  constructor(public payload: Ingredient) {}
}

export class DeleteIngredient implements Action {
  readonly type = DELETE_INGREDIENT;
}

export type ShoppingListActions =
  | AddIngredient
  | AddIngredients
  | UpdateIngredient
  | DeleteIngredient;
```

### 12. Updating & Deleting Ingredients

reducer

```ts
case ShoppingListActions.UPDATE_INGREDIENT:
      const ingredient = state.ingredients[state.editedIngredientIndex];
      const updatedIngredient = {
        ...ingredient,
        ...action.payload
      };
      const updatedIngredients = [...state.ingredients];
      updatedIngredients[state.editedIngredientIndex] = updatedIngredient;

      return {
        ...state,
        ingredients: updatedIngredients,
        editedIngredientIndex: -1,
        editedIngredient: null
      };
    case ShoppingListActions.DELETE_INGREDIENT:
      return {
        ...state,
        ingredients: state.ingredients.filter((ig, igIndex) => {
          return igIndex !== state.editedIngredientIndex;
        }),
        editedIngredientIndex: -1,
        editedIngredient: null
      };

Hàm filter trả về arr copy

```

shopping-edit.component.ts

```ts
// this.slService.updateIngredient(this.editedItemIndex, newIngredient);
this.store.dispatch(new ShoppingListActions.UpdateIngredient(newIngredient));
```

### 13. Expanding the State

shopping-list.reducer.ts

```ts
// Add
export interface State {
  ingredients: Ingredient[];
  editedIngredient: Ingredient;
  editedIngredientIndex: number;
}

// them nhung sau nay se xoa
export interface AppState {
  shoppingList: State;
}
//end

const initialState: State = { // thêm kiểu là state
  ingredients: [new Ingredient('Apples', 5), new Ingredient('Tomatoes', 10)],
  // Add
  editedIngredient: null,
  editedIngredientIndex: -1
};

// add action reducer
	case ShoppingListActions.START_EDIT:
      return {
        ...state,
        editedIngredientIndex: action.payload,
        editedIngredient: { ...state.ingredients[action.payload] }
      };
    case ShoppingListActions.STOP_EDIT:
      return {
        ...state,
        editedIngredient: null,
        editedIngredientIndex: -1
      };
```

shopping-list.component.ts

```ts
import * as fromShoppingList from './store/shopping-list.reducer';

constructor(
    private loggingService: LoggingService,
    // remove private store: Store<{ shoppingList: { ingredients: Ingredient[] } }>
    private store: Store<fromShoppingList.AppState> // add change state
  ) {}

// add
onEditItem(index: number) {
    // this.slService.startedEditing.next(index);
    this.store.dispatch(new ShoppingListActions.StartEdit(index));
  }

```

shopping-edit.component.ts
Lam tuong tu thay kiểu cho store

### 14. Managing More State via NgRx

shopping-list.actions.ts

```ts
export const START_EDIT = 'START_EDIT';
export const STOP_EDIT = 'STOP_EDIT';

export class StartEdit implements Action {
  readonly type = START_EDIT;

  constructor(public payload: number) {}
}

export class StopEdit implements Action {
  readonly type = STOP_EDIT;
}
export type ShoppingListActions =
  | AddIngredient
  | AddIngredients
  | UpdateIngredient
  | DeleteIngredient
  | StartEdit
  | StopEdit; // add
```

shopping-list.reducer.ts

```ts
    case ShoppingListActions.START_EDIT:
      return {
        ...state,
        editedIngredientIndex: action.payload,
        editedIngredient: { ...state.ingredients[action.payload] }
      };
    case ShoppingListActions.STOP_EDIT:
      return {
        ...state,
        editedIngredient: null,
        editedIngredientIndex: -1
      };
```

shopping-list.component.ts

```ts
onEditItem(index: number) {
    // this.slService.startedEditing.next(index);
    this.store.dispatch(new ShoppingListActions.StartEdit(index));
  }

```

shopping-edit.component.ts

```ts
//	ngOnInit() {
  //   this.subscription = this.slService.startedEditing
  //     .subscribe(
  //       (index: number) => {
  //         this.editedItemIndex = index;
  //         this.editMode = true;
  //         this.editedItem = this.slService.getIngredient(index);
  //         this.slForm.setValue({
  //           name: this.editedItem.name,
  //           amount: this.editedItem.amount
  //         })
  //       }
  //     );
  // }
ngOnInit() {
  // add
    this.subscription = this.store
      .select('shoppingList')
      .subscribe(stateData => {
        if (stateData.editedIngredientIndex > -1) {
          this.editMode = true;
          this.editedItem = stateData.editedIngredient;
	        // update form
          this.slForm.setValue({
            name: this.editedItem.name,
            amount: this.editedItem.amount
          });
        } else {
          this.editMode = false;
        }
      });
  }

onClear() {
    this.slForm.reset();
    this.editMode = false;
    // Add
    this.store.dispatch(new ShoppingListActions.StopEdit());
  }

  onDelete() {
    // this.slService.deleteIngredient(this.editedItemIndex);
    this.store.dispatch(new ShoppingListActions.DeleteIngredient());
    this.onClear();
  }

  ngOnDestroy() {
    this.subscription.unsubscribe();
    // add
    this.store.dispatch(new ShoppingListActions.StopEdit());
  }

 onSubmit(form: NgForm) {
    const value = form.value;
    const newIngredient = new Ingredient(value.name, value.amount);
    if (this.editMode) {
       // add
      // this.slService.updateIngredient(this.editedItemIndex, newIngredient);
      this.store.dispatch(
        new ShoppingListActions.UpdateIngredient(newIngredient)
      );
    } else {
      // this.slService.addIngredient(newIngredient);
      this.store.dispatch(new ShoppingListActions.AddIngredient(newIngredient));
    }
    this.editMode = false;
    form.reset();
  }

```

now can have error

---

app.reducer.ts

```ts
import { ActionReducerMap } from '@ngrx/store';

import * as fromShoppingList from '../shopping-list/store/shopping-list.reducer';
import * as fromAuth from '../auth/store/auth.reducer';

export interface AppState {
  shoppingList: fromShoppingList.State;
  auth: fromAuth.State;
}

export const appReducer: ActionReducerMap<AppState> = {
  shoppingList: fromShoppingList.shoppingListReducer,
  auth: fromAuth.authReducer,
};
```

### 15. Removing Redundant Component State Management

delete all editedIngredientIndex
modify(xem lai)
shopping-list.reducer.ts

```ts
case ShoppingListActions.UPDATE_INGREDIENT:
      const ingredient = state.ingredients[state.editedIngredientIndex];
      const updatedIngredient = {
        ...ingredient,
        ...action.payload
      };
      const updatedIngredients = [...state.ingredients];
      updatedIngredients[state.editedIngredientIndex] = updatedIngredient;

      return {
        ...state,
        ingredients: updatedIngredients,
        editedIngredientIndex: -1,
        editedIngredient: null
      };
    case ShoppingListActions.DELETE_INGREDIENT:
      return {
        ...state,
        ingredients: state.ingredients.filter((ig, igIndex) => {
          return igIndex !== state.editedIngredientIndex;
        }),
        editedIngredientIndex: -1,
        editedIngredient: null
      };
```

shopping-edit.component.ts

```ts
 onSubmit(form: NgForm) {
    const value = form.value;
    const newIngredient = new Ingredient(value.name, value.amount);
    if (this.editMode) {
      // this.slService.updateIngredient(this.editedItemIndex, newIngredient);
      this.store.dispatch(
        new ShoppingListActions.UpdateIngredient(newIngredient)
      ); // modify
    } else {
      // this.slService.addIngredient(newIngredient);
      this.store.dispatch(new ShoppingListActions.AddIngredient(newIngredient));
    }
    this.editMode = false;
    form.reset();
  }
```

### 16. First Summary & Clean Up

Xoa ShoppingListService cả toàn bộ file

### 17. One Root State

Create file store/auth-reducer.ts

```ts
import { User } from '../user.model';

export interface State {
  user: User;
}

const initialState: State = {
  user: null,
};

export function authReducer(state = initialState, action) {
  return state;
}
```

app.reducer.ts

```ts
import { ActionReducerMap } from '@ngrx/store';

import * as fromShoppingList from '../shopping-list/store/shopping-list.reducer';
import * as fromAuth from '../auth/store/auth.reducer';

export interface AppState {
  shoppingList: fromShoppingList.State;
  auth: fromAuth.State;
}

export const appReducer: ActionReducerMap<AppState> = {
  shoppingList: fromShoppingList.shoppingListReducer,
  auth: fromAuth.authReducer,
};
```

app.module.ts

```ts
import * as fromApp from './store/app.reducer';

@NgModule({
  declarations: [AppComponent, HeaderComponent],
  imports: [
    BrowserModule,
    HttpClientModule,
    AppRoutingModule,
    StoreModule.forRoot(fromApp.appReducer), // add
    SharedModule,
    CoreModule
  ],
  bootstrap: [AppComponent]
  // providers: [LoggingService]
})
```

shopping-list.component.ts

```ts
constructor(
    private loggingService: LoggingService,
    private store: Store<fromApp.AppState> // change
  ) {}
```

recipe.service.ts

```ts
constructor(
    private store: Store<fromApp.AppState> // fix
  ) {}
```

### 18. Setting Up Auth Reducer & Actions

auth.actions.ts

```ts
import { Action } from '@ngrx/store';

export const LOGIN = 'LOGIN';
export const LOGOUT = 'LOGOUT';

export class Login implements Action {
  readonly type = LOGIN;

  constructor(
    public payload: {
      email: string;
      userId: string;
      token: string;
      expirationDate: Date;
    }
  ) {}
}

export class Logout implements Action {
  readonly type = LOGOUT;
}

export type AuthActions = Login | Logout;
```

auth.reducer.ts

```ts
import { User } from '../user.model';
import * as AuthActions from './auth.actions';

export interface State {
  user: User;
}

const initialState: State = {
  user: null,
};

export function authReducer(
  state = initialState,
  action: AuthActions.AuthActions
) {
  switch (action.type) {
    case AuthActions.LOGIN:
      const user = new User(
        action.payload.email,
        action.payload.userId,
        action.payload.token,
        action.payload.expirationDate
      );
      return {
        ...state,
        user: user,
      };
    case AuthActions.LOGOUT:
      return {
        ...state,
        user: null,
      };
    default:
      return state;
  }
}
```

### 19. Dispatching Auth Actions

auth.service.ts

```ts
import * as fromApp from '../store/app.reducer';

constructor(
    private http: HttpClient,
    private router: Router,
    private store: Store<fromApp.AppState> // add
  ) {}


  autoLogin() {
	....
    if (loadedUser.token) {
      // this.user.next(loadedUser);
        // add
      this.store.dispatch(
        new AuthActions.Login({
          email: loadedUser.email,
          userId: loadedUser.id,
          token: loadedUser.token,
          expirationDate: new Date(userData._tokenExpirationDate)
        })
      );
     // .....

    logout() {
        // add
    // this.user.next(null);
    this.store.dispatch(new AuthActions.Logout());
    this.router.navigate(['/auth']);
    localStorage.removeItem('userData');
    if (this.tokenExpirationTimer) {
      clearTimeout(this.tokenExpirationTimer);
    }
    this.tokenExpirationTimer = null;
  }

```

### 20. Auth Finished (For Now...)

auth-interceptor.service.ts

```ts
@Injectable()
export class AuthInterceptorService implements HttpInterceptor {
  constructor(private authService: AuthService,
               // add
               private store: Store<fromApp.AppState>) {}

  intercept(req: HttpRequest<any>, next: HttpHandler) {
    return this.store.select('auth').pipe( // add
        take(1),
        // add
      map(authState => {
        return authState.user;
      }),
```

auth.guard.ts

```ts
 constructor(
    private authService: AuthService,
    private router: Router,
    private store: Store<fromApp.AppState> // add tưởng tự
  ) {}

  canActivate(
    route: ActivatedRouteSnapshot,
    router: RouterStateSnapshot
  ):
    | boolean
    | UrlTree
    | Promise<boolean | UrlTree>
    | Observable<boolean | UrlTree> {
    return this.store.select('auth').pipe(
      take(1),
      map(authState => { // add
        return authState.user;
      }),
```

header.component.ts

```ts
 constructor(
    private dataStorageService: DataStorageService,
    private authService: AuthService,
    private store: Store<fromApp.AppState> // add
  ) {}

  ngOnInit() {
    this.userSub = this.store
      .select('auth') // add
      .pipe(map(authState => authState.user))
      .subscribe(user => {
        this.isAuthenticated = !!user;
        console.log(!user);
        console.log(!!user);
      });
  }
```

### 21. And Important Note on Actions

Khi ấn delete

![image-20200611231946916](angular.assets/image-20200611231946916.png)

Vào file reducer in state ra console để xem

it is important that we **return our default state** for this state slice here,

otherwise if we wouldn't do that, if we would return null here or anything like that, we would basically

drop our state here in the auth reducer when something is dispatched in another part of the app.

So that's the first important thing,

the next important thing is that since our dispatched actions reach all reducers, you really have to

ensure that your identifiers here are login across the entire application because these auth related

actions here are not just handled by the auth reducer, they also reach the shopping list reducer.

Now of course, we in this application we have identifiers that don't really interfere,

add ingredient and login are quite different but for bigger applications, it is of course possible that

you have duplicate identifiers across different parts of your app.

Now since they have to be unique for the entire application because actions reach the entire application,

I would recommend a **technique called prefixing**. Now I will convert like this, it's not a must do but it is recommended especially for bigger apps to avoid clashes, now of course any prefix that ensures uniqueness would be fine but here I'll just implement a pattern you'll also find in the official NgRx docs.

auth.action.ts

```ts
export const LOGIN_START = '[Auth] Login Start';
export const LOGIN = '[Auth] Login';
export const LOGIN_FAIL = '[Auth] Login Fail';
export const LOGOUT = '[Auth] Logout';
```

shopping-list.actions.ts

```ts
export const ADD_INGREDIENT = '[Shopping List] Add Ingredient';
export const ADD_INGREDIENTS = '[Shopping List] Add Ingredients';
export const UPDATE_INGREDIENT = '[Shopping List] Update Ingredient';
export const DELETE_INGREDIENT = '[Shopping List] Delete Ingredient';
export const START_EDIT = '[Shopping List] Start Edit';
export const STOP_EDIT = '[Shopping List] Stop Edit';
```

### 22. Exploring NgRx Effects

`npm install --save @ngrx/effects`

but here I think it is good, especially for learning about NgRx

if we move as much as possible into the NgRx world and therefore if we use @ngrx/effects for managing

our HTTP requests and local storage access.

Side effects are basically parts in your code where you run some logic that of course is important for your application,

otherwise you wouldn't do it but that's not so important for the immediate update of the current state.

So for example here, this HTTP request, of course the result of that matters,

it decides whether we did successfully create a new user or not but for this process, where we start the sign-up process, this is not important.

So we could basically split this up into two actions - start sign-up and sign-up

success for example or even three actions, start sign-up, sign-up success and sign-up error.

### 23. Defining the First Effect

auth.effects.ts

```ts
import { Injectable } from '@angular/core';
import { Router } from '@angular/router';
import { Actions, ofType, Effect } from '@ngrx/effects';
import { switchMap, catchError, map, tap } from 'rxjs/operators';
import { of } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { environment } from '../../../environments/environment';

import * as AuthActions from './auth.actions';

export interface AuthResponseData {
  kind: string;
  idToken: string;
  email: string;
  refreshToken: string;
  expiresIn: string;
  localId: string;
  registered?: boolean;
}

@Injectable()
export class AuthEffects {
  @Effect()
  authLogin = this.actions$.pipe(
    ofType(AuthActions.LOGIN_START),
    switchMap((authData: AuthActions.LoginStart) => {
      return this.http
        .post<AuthResponseData>(
          'https://www.googleapis.com/identitytoolkit/v3/relyingparty/verifyPassword?key=' +
            environment.firebaseAPIKey,
          {
            email: authData.payload.email,
            password: authData.payload.password,
            returnSecureToken: true
          }
        )
        # 24
        // returning a new action simply means that we have to return a new observable.
        .pipe(
          map(resData => {
            const expirationDate = new Date(
              new Date().getTime() + +resData.expiresIn * 1000
            );
            return new AuthActions.Login({
              email: resData.email,
              userId: resData.localId,
              token: resData.idToken,
              expirationDate: expirationDate
            });
          }),
          catchError(errorRes => {
            let errorMessage = 'An unknown error occurred!';
            if (!errorRes.error || !errorRes.error.error) {
              return of(new AuthActions.LoginFail(errorMessage));
            }
            switch (errorRes.error.error.message) {
              case 'EMAIL_EXISTS':
                errorMessage = 'This email exists already';
                break;
              case 'EMAIL_NOT_FOUND':
                errorMessage = 'This email does not exist.';
                break;
              case 'INVALID_PASSWORD':
                errorMessage = 'This password is not correct.';
                break;
            }
            return of(new AuthActions.LoginFail(errorMessage));
          })
        );
    })
  );

  constructor(
    private actions$: Actions,
    private http: HttpClient,
    private router: Router
  ) {}
}

```

Now what is actions? **Actions** is one big observable that will give you access to all dispatched actions

so that you can react to them, you just react differently than in the reducer because in the reducer,

you of course also get access to all dispatched actions as you learned, here in the effect class, in the

auth effects class, the idea now is that you don't change any state but that you can execute any other code that should

happen when such an action is dispatched and that you then can simply dispatch a new action

once that code, which also may be asynchronous, is done.

`authLogin = this.actions$.pipe`

Now don't call subscribe here, @ngrx/effects will subscribe for you, just call **pipe** instead and what

you need to pipe here is now a special RxJS operator which is not part of RxJS but which

is provided by @ngrx/effects, it's the ofType operator. **ofType** simply allows you to define a filter

for which types of effects you want to continue in this observable pipe you're creating, in this observable

stream here because you can have multiple effects by adding multiple properties to your class here

and you can simply define different types of effects that you want to handle in each chain.

So here for example, we could handle the login effect or to be precise, the login action since we're basically

reacting to all dispatched actions here and this is a filter to allow us to define for which exact actions

we want to continue in this chain and now I need more actions.

Thus far, we only had login and logout but now since we actually want to send the HTTP request

here from inside our auth effect, we need a new identifier which could be login start and the value here could be auth login start.

in auth type, we can then refer to auth actions login start here and what this says is only continue in

this observable chain if the action that we're reacting to here is of type login start, all other actions

will not trigger this effect here, only login start will

and you could add multiple actions here by the way if you want to run the same code for different actions.

### 24. Effects & Error Handling

we need to create a new action class here in the auth actions file, the login start class which also implements action,

auth.actions.ts

```ts
export class LoginStart implements Action {
  readonly type = LOGIN_START;

  constructor(public payload: { email: string; password: string }) {}
}

export class LoginFail implements Action {
  readonly type = LOGIN_FAIL;

  constructor(public payload: string) {}
}
```

we can go back to the auth effects and now add another rxjs/operator as a second step.

First step is that we're **filtering**, next step now can be a **switchMap** which allows us, which is imported from rxjs/operators, which allows us to **create a new observable** by taking another observable's data.

So here we get our auth data and we know since we're filtering for the login start action, that the type

of this will be auth actions login start, now referring to the class.

So this is our type of data and in switchMap, we now can return a new observable and the new observable

I want to return here of course uses the Angular HTTP client to send our login request,

so just what we previously did in the login function in our service.

It's important to understand that **an observable completes whenever an error is thrown**,

therefore in the auth service, whenever this here yields an error, catch error kicks in and this code never

executes and this entire observable dies, which is no problem because when we call login again, a new

observable is created.

Now it's a bit differently for effects, effects here this is an ongoing observable stream,

this **must never die**, at least not as long as our application is running and therefore, if we would catch

an error here by adding catch error here as a next step after switchMap, which we could do because switch

map returns an HTTP observable and this could certainly throw an error, if we add the catch error like

this or even if we don't

add it, if this throws an error, this entire observable stream will die which means that **trying to login**

**again will simply not work** because this here will never react to another dispatched login start event

because this entire observable is dead and therefore, errors have to be handled on a different level.

**of:** I also once use auth to create a new observable.

### 25. Login via NgRx Effects

```ts
@Injectable() // add
export class AuthEffects
```

be injected itself so it doesn't need to be provided but it needs @injectable so that things can be

injected into this class and we are injecting actions and the HttpClient, otherwise we would get errors,

app.module.ts

```ts
import { AuthEffects } from './auth/store/auth.effects';

@NgModule({
  declarations: [AppComponent, HeaderComponent],
  imports: [
    BrowserModule,
    HttpClientModule,
    AppRoutingModule,
    StoreModule.forRoot(fromApp.appReducer),
    EffectsModule.forRoot([AuthEffects]), // add
    SharedModule,
    CoreModule,
  ],
  bootstrap: [AppComponent],
  // providers: [LoggingService]
})
export class AppModule {}
```

auth.component.ts

```ts
    constructor(
    private authService: AuthService,
    private router: Router,
    private componentFactoryResolver: ComponentFactoryResolver,
    private store: Store<fromApp.AppState> // add
  ) {}


// trong hàm onSUbmit
if (this.isLoginMode) {
      // authObs = this.authService.login(email, password);
      this.store.dispatch(
          // add
        new AuthActions.LoginStart({ email: email, password: password })
      );
    } else {
      authObs = this.authService.signup(email, password);
    }
// comment lại vì k sd nữa nếu k run sẽ lỗi
// authObs.subscribe(
    //   resData => {
    //     console.log(resData);
    //     this.isLoading = false;
    //     this.router.navigate(['/recipes']);
    //   },
    //   errorMessage => {
    //     console.log(errorMessage);
    //     this.error = errorMessage;
    //     this.showErrorAlert(errorMessage);
    //     this.isLoading = false;
    //   }
    // );
```

![image-20200612092154764](angular.assets/image-20200612092154764.png)

### 26. Managing UI State in NgRx

handle error

auth.reducer.ts

```ts
case AuthActions.LOGIN_FAIL:
      return {
        ...state,
        user: null,
        authError: action.payload,
        loading: false
      };
```

auth.component.ts

```ts
// add
ngOnInit() {
    this.store.select('auth').subscribe(authState => {
      this.isLoading = authState.loading;
      this.error = authState.authError;
        // # 27
      if (this.error) {
        this.showErrorAlert(this.error);
      }
    });
  }
```

auth.effects.ts

```ts
Effect({ dispatch: false });
authSuccess = this.actions$.pipe(
  ofType(AuthActions.LOGIN),
  tap(() => {
    this.router.navigate(['/']);
  })
);
```

I mentioned that typically, your effects do that, they typically return an observable which holds a new

effect which should be dispatched,

this effect doesn't and to let NgRx effect know about that and avoid errors, you have to pass an object

to your @effect decorator where you set dispatch to false

and this lets @ngrx/effects know that this is an effect which will actually not yield a dispatchable action at the end and then you can do that just like this.

### 27. Finishing the Login Effect

```ts
catchError((errorRes) => {
  let errorMessage = 'An unknown error occurred!';
  if (!errorRes.error || !errorRes.error.error) {
    return of(new AuthActions.LoginFail(errorMessage));
  }
  switch (errorRes.error.error.message) {
    case 'EMAIL_EXISTS':
      errorMessage = 'This email exists already';
      break;
    case 'EMAIL_NOT_FOUND':
      errorMessage = 'This email does not exist.';
      break;
    case 'INVALID_PASSWORD':
      errorMessage = 'This password is not correct.';
      break;
  }
  return of(new AuthActions.LoginFail(errorMessage));
});
```

### 28. Preparing Other Auth Actions

auth.actions.ts

```ts
export const AUTHENTICATE_SUCCESS = '[Auth] Login';
export const AUTHENTICATE_FAIL = '[Auth] Login Fail';
export const SIGNUP_START = '[Auth] Signup Start';

export class AuthenticateSuccess implements Action {
  readonly type = AUTHENTICATE_SUCCESS;

  constructor(
    public payload: {
      email: string;
      userId: string;
      token: string;
      expirationDate: Date;
    }
  ) {}
}

export class AuthenticateFail implements Action {
  readonly type = AUTHENTICATE_FAIL;

  constructor(public payload: string) {}
}

export class SignupStart implements Action {
  readonly type = SIGNUP_START;

  constructor(public payload: { email: string; password: string }) {}
}
```

auth.effects.ts

```ts
// thay LOGIN bằng AUTHENTICATE_SUCCESS và return new AuthActions.AuthenticateSuccess
```

### 29. Adding Signup

auth.effects.ts

```ts
// add
@Injectable()
export class AuthEffects {
  @Effect()
  authSignup = this.actions$.pipe(
    ofType(AuthActions.SIGNUP_START),
    switchMap((signupAction: AuthActions.SignupStart) => {
      return this.http
        .post<AuthResponseData>(
          'https://www.googleapis.com/identitytoolkit/v3/relyingparty/signupNewUser?key=' +
            environment.firebaseAPIKey,
          {
            email: signupAction.payload.email,
            password: signupAction.payload.password,
            returnSecureToken: true
          }
        )
        .pipe(
          map(resData => {
            return handleAuthentication(
              +resData.expiresIn,
              resData.email,
              resData.localId,
              resData.idToken
            );
          }),
          catchError(errorRes => {
            return handleError(errorRes);
          })
        );
    })
  );


  const handleAuthentication = (
  expiresIn: number,
  email: string,
  userId: string,
  token: string
) => {
  const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);
      // add 31 start
  const user = new User(email, userId, token, expirationDate);
  localStorage.setItem('userData', JSON.stringify(user));
      // add 31 end
  return new AuthActions.AuthenticateSuccess({
    email: email,
    userId: userId,
    token: token,
    expirationDate: expirationDate
  });
};

const handleError = (errorRes: any) => {
  let errorMessage = 'An unknown error occurred!';
  if (!errorRes.error || !errorRes.error.error) {
    return of(new AuthActions.AuthenticateFail(errorMessage));
  }
  switch (errorRes.error.error.message) {
    case 'EMAIL_EXISTS':
      errorMessage = 'This email exists already';
      break;
    case 'EMAIL_NOT_FOUND':
      errorMessage = 'This email does not exist.';
      break;
    case 'INVALID_PASSWORD':
      errorMessage = 'This password is not correct.';
      break;
  }
  return of(new AuthActions.AuthenticateFail(errorMessage));
};
```

auth.component.ts

```ts
// hàm submit

this.store.dispatch(
  new AuthActions.SignupStart({ email: email, password: password })
);
```

### 30. Further Auth Effects

auth.reducer.ts

```ts
case AuthActions.LOGIN_START:
    case AuthActions.SIGNUP_START: // add
      return {
        ...state,
        authError: null,
        loading: true
      };
    case AuthActions.AUTHENTICATE_FAIL:
      return {
        ...state,
        user: null,
        authError: action.payload,
        loading: false
      };
	case AuthActions.CLEAR_ERROR:
      return {
        ...state,
        authError: null
      };
    default:
      return state;
```

auth.component.ts

```ts
private storeSub: Subscription; // add

  ngOnInit() {
      // add
    this.storeSub = this.store.select('auth').subscribe(authState => {

        ....

     ngOnDestroy() {

   // add
    if (this.closeSub) {
      this.closeSub.unsubscribe();
    }
    if (this.storeSub) {
      this.storeSub.unsubscribe();
    }
  }

    // add
  onHandleError() {
    this.store.dispatch(new AuthActions.ClearError());
  }
```

auth.actions.ts

```ts
export class ClearError implements Action {
  readonly type = CLEAR_ERROR;
}
```

auth.effect.ts

```ts
@Effect({ dispatch: false })
  authRedirect = this.actions$.pipe(
    ofType(AuthActions.AUTHENTICATE_SUCCESS, AuthActions.LOGOUT), // add logout
    tap(() => {
      this.router.navigate(['/']);
    })
  );
```

auth.service.ts

```ts
// xóa hàm login và ssign up đi vì k còn sd

logout() {
    // this.user.next(null);
    this.store.dispatch(new AuthActions.Logout()); // add
```

header.component.ts

```ts

  onLogout() {
    this.store.dispatch(new AuthActions.Logout()); // replace service
  }
```

### 31. Adding Auto-Login with NgRx

auth.actions

```ts
export class AutoLogin implements Action {
  readonly type = AUTO_LOGIN;
}
```

auth.effect.ts

```ts
// trong hàm handleAuthentication
// add
const user = new User(email, userId, token, expirationDate);
  localStorage.setItem('userData', JSON.stringify(user));

// add
@Effect({ dispatch: false })
  authLogout = this.actions$.pipe(
    ofType(AuthActions.LOGOUT),
    tap(() => {
      localStorage.removeItem('userData');
    })
  );

@Effect()
  autoLogin = this.actions$.pipe(
    ofType(AuthActions.AUTO_LOGIN),
    map(() => {
      const userData: {
        email: string;
        id: string;
        _token: string;
        _tokenExpirationDate: string;
      } = JSON.parse(localStorage.getItem('userData'));
      if (!userData) {
        return { type: 'DUMMY' };
      }

      const loadedUser = new User(
        userData.email,
        userData.id,
        userData._token,
        new Date(userData._tokenExpirationDate)
      );

      if (loadedUser.token) {
        // this.user.next(loadedUser);
          // this.store.dispatch({})
        return new AuthActions.AuthenticateSuccess({
          email: loadedUser.email,
          userId: loadedUser.id,
          token: loadedUser.token,
          expirationDate: new Date(userData._tokenExpirationDate)
        });

        // const expirationDuration =
        //   new Date(userData._tokenExpirationDate).getTime() -
        //   new Date().getTime();
        // this.autoLogout(expirationDuration);
      }
      return { type: 'DUMMY' };
    })
  );

```

app.component.ts

```ts
export class AppComponent implements OnInit {
  constructor(
    private store: Store<fromApp.AppState>, // add
    private loggingService: LoggingService
  ) {}

  ngOnInit() {
    this.store.dispatch(new AuthActions.AutoLogin()); // add
    this.loggingService.printLog('Hello from AppComponent ngOnInit');
  }
}
```

![image-20200612123201864](angular.assets/image-20200612123201864.png)

thêm return DUMMy để fix

### 32. Adding Auto-Logout

auth.service.ts xóa những hàm không cần

```ts
import { Injectable } from '@angular/core';
import { Store } from '@ngrx/store';

import * as fromApp from '../store/app.reducer';
import * as AuthActions from './store/auth.actions';

@Injectable({ providedIn: 'root' })
export class AuthService {
  private tokenExpirationTimer: any;

  constructor(private store: Store<fromApp.AppState>) {}

  setLogoutTimer(expirationDuration: number) {
    this.tokenExpirationTimer = setTimeout(() => {
      this.store.dispatch(new AuthActions.Logout());
    }, expirationDuration);
  }

  clearLogoutTimer() {
    if (this.tokenExpirationTimer) {
      clearTimeout(this.tokenExpirationTimer);
      this.tokenExpirationTimer = null;
    }
  }
}
```

auth.effects.ts

```ts
// auth login and sign up
	tap(resData => {
    	// add
            this.authService.setLogoutTimer(+resData.expiresIn * 1000); // khi test 3.6s k cần nhân 1000
          }),

// auto login
   if (loadedUser.token) {
        // this.user.next(loadedUser);
        const expirationDuration =
          new Date(userData._tokenExpirationDate).getTime() -
          new Date().getTime();
        this.authService.setLogoutTimer(expirationDuration); // add

       ....

@Effect({ dispatch: false })
  authLogout = this.actions$.pipe(
    ofType(AuthActions.LOGOUT),
    tap(() => {
      this.authService.clearLogoutTimer(); // add
      localStorage.removeItem('userData');
      this.router.navigate(['/auth']); // add
    })
  );
```

### 33. Finishing the Auth Effects

### 34. Using the Store Devtools

gg redux devtools extension

https://github.com/zalmoxisus/redux-devtools-extension

app.module.ts

```ts
import { StoreDevtoolsModule } from '@ngrx/store-devtools';
import { StoreRouterConnectingModule } from '@ngrx/router-store';
import { environment } from '../environments/environment';

@NgModule({
  declarations: [AppComponent, HeaderComponent],
  imports: [
    BrowserModule,
    HttpClientModule,
    AppRoutingModule,
    StoreModule.forRoot(fromApp.appReducer),
    EffectsModule.forRoot([AuthEffects]),
    // add
    StoreDevtoolsModule.instrument({ logOnly: environment.production }),
    // # 35
    StoreRouterConnectingModule.forRoot(),

    SharedModule,
    CoreModule,
  ],
  bootstrap: [AppComponent],
  // providers: [LoggingService]
})
export class AppModule {}
```

![image-20200612141736124](angular.assets/image-20200612141736124.png)

### 35. The Router Store

`npm install --save @ngrx/router-store`

![image-20200612142122468](angular.assets/image-20200612142122468.png)

### 36. Getting Started with NgRx for Recipes

recipe.actions.ts

```ts
import { Action } from '@ngrx/store';

import { Recipe } from '../recipe.model';

export const SET_RECIPES = '[Recipes] Set Recipes';
export const FETCH_RECIPES = '[Recipes] Fetch Recipes';

export class SetRecipes implements Action {
  readonly type = SET_RECIPES;

  constructor(public payload: Recipe[]) {}
}

export class FetchRecipes implements Action {
  readonly type = FETCH_RECIPES;
}

export type RecipesActions = SetRecipes;
```

recipe.reducer.ts

```ts
import { Recipe } from '../recipe.model';
import * as RecipesActions from './recipe.actions';

export interface State {
  recipes: Recipe[];
}

const initialState: State = {
  recipes: [],
};

export function recipeReducer(
  state = initialState,
  action: RecipesActions.RecipesActions
) {
  switch (action.type) {
    case RecipesActions.SET_RECIPES:
      return {
        ...state,
        recipes: [...action.payload],
      };
    default:
      return state;
  }
}
```

data-storage.service.ts

```ts
 fetchRecipes() {
    return this.http
      .get<Recipe[]>(
        'https://ng-course-recipe-book-65f10.firebaseio.com/recipes.json'
      )
      .pipe(
        map(recipes => {
          return recipes.map(recipe => {
            return {
              ...recipe,
              ingredients: recipe.ingredients ? recipe.ingredients : []
            };
          });
        }),
        tap(recipes => {
          // this.recipeService.setRecipes(recipes);
          this.store.dispatch(new RecipesActions.SetRecipes(recipes)); // add
        })
      );
  }
```

recipe-list.component.ts

```ts
 constructor(
    private router: Router,
    private route: ActivatedRoute,
    private store: Store<fromApp.AppState>  // add
  ) {}

  ngOnInit() {
    this.subscription = this.store
      .select('recipes')
      .pipe(map(recipesState => recipesState.recipes))
      .subscribe((recipes: Recipe[]) => {
        this.recipes = recipes;
      });
  }
```

fetch ok nhưng chọn item thì lỗi

![image-20200612143136509](angular.assets/image-20200612143136509.png)

### 37. Fetching Recipe Detail Data

That's not how NgRx works, there we always access the store and the data in it by using select

and we always get back an observable, so we have no synchronous call as we have it here to get back

a recipe, we always get back an observable that might then give us a recipe depending on what we select. Even

if that happens almost instantly, it's still technically an observable, so therefore we first of all will have to inject our store here

into the recipe-detail component and then we can see how we proceed regarding that.

cách 1

![image-20200612144236999](angular.assets/image-20200612144236999.png)

recipe-detail.component

```ts
ngOnInit() {
    // add
    this.route.params
      .pipe(
        map(params => {
          return +params['id'];
        }),
        switchMap(id => {
          this.id = id;
          return this.store.select('recipes');
        }),
        map(recipesState => {
          return recipesState.recipes.find((recipe, index) => {
            return index === this.id;
          });
        })
      )
      .subscribe(recipe => {
        this.recipe = recipe;
      });
  }
```

recipe-edit.component.ts

```ts

  private initForm() {
    let recipeName = '';
    let recipeImagePath = '';
    let recipeDescription = '';
    let recipeIngredients = new FormArray([]);

    if (this.editMode) {
      // const recipe = this.recipeService.getRecipe(this.id);
        // add
      this.store
        .select('recipes')
        .pipe(
          map(recipeState => {
            return recipeState.recipes.find((recipe, index) => {
              return index === this.id;
            });
          })
        )
        .subscribe(recipe => {
          recipeName = recipe.name;
          recipeImagePath = recipe.imagePath;
          recipeDescription = recipe.description;
          if (recipe['ingredients']) {
            for (let ingredient of recipe.ingredients) {
              recipeIngredients.push(
                new FormGroup({
                  name: new FormControl(ingredient.name, Validators.required),
                  amount: new FormControl(ingredient.amount, [
                    Validators.required,
                    Validators.pattern(/^[1-9]+[0-9]*$/)
                  ])
                })
              );
            }
          }
        });
    }

    this.recipeForm = new FormGroup({
      name: new FormControl(recipeName, Validators.required),
      imagePath: new FormControl(recipeImagePath, Validators.required),
      description: new FormControl(recipeDescription, Validators.required),
      ingredients: recipeIngredients
    });
  }
```

### 38. Fetching Recipes & Using the Resolver

khi xem detail ấn reload => error

![image-20200612144732397](angular.assets/image-20200612144732397.png)

recipe.effects.ts add

```ts
import { Injectable } from '@angular/core';
import { Actions, Effect, ofType } from '@ngrx/effects';
import { HttpClient } from '@angular/common/http';
import { switchMap, map } from 'rxjs/operators';

import * as RecipesActions from './recipe.actions';
import { Recipe } from '../recipe.model';

@Injectable()
export class RecipeEffects {
  @Effect()
  fetchRecipes = this.actions$.pipe(
    ofType(RecipesActions.FETCH_RECIPES),
    switchMap(() => {
      return this.http.get<Recipe[]>(
        'https://ng-course-recipe-book-65f10.firebaseio.com/recipes.json'
      );
    }),
    map((recipes) => {
      return recipes.map((recipe) => {
        return {
          ...recipe,
          ingredients: recipe.ingredients ? recipe.ingredients : [],
        };
      });
    }),
    map((recipes) => {
      return new RecipesActions.SetRecipes(recipes);
    })
  );

  constructor(private actions$: Actions, private http: HttpClient) {}
}
```

header.component.ts

```ts
 onFetchData() {
    // this.dataStorageService.fetchRecipes().subscribe();
    this.store.dispatch(new RecipeActions.FetchRecipes()); // add
  }
```

recipes-resolver.service

```ts
@Injectable({ providedIn: 'root' })
export class RecipesResolverService implements Resolve<Recipe[]> {
  constructor(
    // add
    private store: Store<fromApp.AppState>,
    private actions$: Actions
  ) {}

  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    // add
    // return this.dataStorageService.fetchRecipes();
    this.store.dispatch(new RecipesActions.FetchRecipes());
    return this.actions$.pipe(ofType(RecipesActions.SET_RECIPES), take(1));
  }
}
```

Now again, the thing is I can't return this because this does not yield an observable,

instead we want to wait for the effect that is triggered by that action to complete and there is a neat

little way of doing that.

![image-20200612150429625](angular.assets/image-20200612150429625.png)

Sau khi chọn và reload state ok nhưng vẫn chưa hiện được detail vì nó login bị redirect ra /

### 39. Fixing the Auth Redirect

auth.actions.ts

```ts
constructor(
    public payload: {
      email: string;
      userId: string;
      token: string;
      expirationDate: Date;
      redirect: boolean; // add
    }
  ) {}
```

auth.effects

```ts
//   autoLogin = this.actions$.pipe(

return new AuthActions.AuthenticateSuccess({
          email: loadedUser.email,
          userId: loadedUser.id,
          token: loadedUser.token,
          expirationDate: new Date(userData._tokenExpirationDate),
          redirect: false // add
        });

// handleAuthentication
redirect: true


  @Effect({ dispatch: false })
  authRedirect = this.actions$.pipe(
    ofType(AuthActions.AUTHENTICATE_SUCCESS),
      // add
    tap((authSuccessAction: AuthActions.AuthenticateSuccess) => {
      if (authSuccessAction.payload.redirect) { // add
        this.router.navigate(['/']);
      }
    })
  );
```

### 40. Update, Delete and Add Recipes

recipe.actions

```ts
export class AddRecipe implements Action {
  readonly type = ADD_RECIPE;

  constructor(public payload: Recipe) {}
}

export class UpdateRecipe implements Action {
  readonly type = UPDATE_RECIPE;

  constructor(public payload: { index: number; newRecipe: Recipe }) {}
}

export class DeleteRecipe implements Action {
  readonly type = DELETE_RECIPE;

  constructor(public payload: number) {}
}
```

recipe.reducer.ts

```ts
case RecipesActions.ADD_RECIPE:
      return {
        ...state,
        recipes: [...state.recipes, action.payload]
      };
    case RecipesActions.UPDATE_RECIPE:
      const updatedRecipe = {
        ...state.recipes[action.payload.index],
        ...action.payload.newRecipe
      };

      const updatedRecipes = [...state.recipes];
      updatedRecipes[action.payload.index] = updatedRecipe;

      return {
        ...state,
        recipes: updatedRecipes
      };
    case RecipesActions.DELETE_RECIPE:
      return {
        ...state,
        recipes: state.recipes.filter((recipe, index) => {
          return index !== action.payload;
        })
      };
```

recipe-edit.component

```ts

  onSubmit() {
    // const newRecipe = new Recipe(
    //   this.recipeForm.value['name'],
    //   this.recipeForm.value['description'],
    //   this.recipeForm.value['imagePath'],
    //   this.recipeForm.value['ingredients']);
    if (this.editMode) {
      // this.recipeService.updateRecipe(this.id, this.recipeForm.value);
      this.store.dispatch(
        new RecipesActions.UpdateRecipe({
          index: this.id,
          newRecipe: this.recipeForm.value
        })
      );
    } else {
      // this.recipeService.addRecipe(this.recipeForm.value);
      this.store.dispatch(new RecipesActions.AddRecipe(this.recipeForm.value));
    }
    this.onCancel();
  }
```

recipe-detail.component

```ts
 onDeleteRecipe() {
    // this.recipeService.deleteRecipe(this.id);
    this.store.dispatch(new RecipesActions.DeleteRecipe(this.id));
    this.router.navigate(['/recipes']);
  }
```

recipes-resolver.service

```ts
resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot) {
    // add
    // return this.dataStorageService.fetchRecipes();
    return this.store.select('recipes').pipe(
      take(1),
      map(recipesState => {
        return recipesState.recipes;
      }),
      switchMap(recipes => {
        if (recipes.length === 0) {
          this.store.dispatch(new RecipesActions.FetchRecipes());
          return this.actions$.pipe(
            ofType(RecipesActions.SET_RECIPES),
            take(1)
          );
        } else {
          return of(recipes);
        }
      })
    );
  }
```

recipe-edit.component

```ts
  private storeSub: Subscription;
  ngOnDestroy() {
    if (this.storeSub) { // fix lỗi bên dưới
      this.storeSub.unsubscribe();
    }
  }
```

Khi add

![image-20200612153057966](angular.assets/image-20200612153057966.png)

### 41. Storing Recipes via Effects

recipe.effects

```ts

  @Effect({dispatch: false})
  storeRecipes = this.actions$.pipe(
    ofType(RecipesActions.STORE_RECIPES),
    withLatestFrom(this.store.select('recipes')), // and that allows us to merge a value from another observable into this observable stream here and there,
    switchMap(([actionData, recipesState]) => {
      return this.http.put(
        'https://ng-course-recipe-book-65f10.firebaseio.com/recipes.json',
        recipesState.recipes
      );
    })
  );
```

this is done in this application, so we can **set dispatch to false** here so that NgRx effects knows that

this won't dispatch anything and now we can go to the header component again

header

```ts
onSaveData() {
    // this.dataStorageService.storeRecipes();
    this.store.dispatch(new RecipeActions.StoreRecipes());
  }
```

### 42. Cleanup Work

Xóa service và core module chỉ còn

```ts
import { NgModule } from '@angular/core';
import { HTTP_INTERCEPTORS } from '@angular/common/http';

import { AuthInterceptorService } from './auth/auth-interceptor.service';

@NgModule({
  providers: [
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true,
    },
  ],
})
export class CoreModule {}
```

recipe-detail.component

```ts
onAddToShoppingList() {
    // this.recipeService.addIngredientsToShoppingList(this.recipe.ingredients);
    this.store.dispatch(
      new ShoppingListActions.AddIngredients(this.recipe.ingredients)
    );
  }
```

### 43. Wrap Up - Alternative NgRx Syntax

Alternative NgRx Syntax

The NgRx team also released an **alternative syntax** for creating actions, reducers, effects etc.

The approach and setup shown in this course is a bit more verbose (which actually has the advantage of seeing more of the things that go on under the hood). Exploring the alternative, a bit shorter syntax might therefore be an interesting next step.

Jost created a nice post where he summarizes the new syntax + how to adjust the course project to use it: https://www.udemy.com/the-complete-guide-to-angular-2/learn/lecture/14466642#questions/7350498

Also check out the official docs to learn more about it: https://ngrx.io/docs

**Again, just because it's important**: This syntax is **not** better, faster or more secure than the one taught in the course. The entire switch of the official docs is pretty drastic (and hard to understand to be very honest) since the syntax taught in this course was the syntax used for close to two years now. Many teams will certainly still be on that syntax and that alone is a strong reason to learn it.

### 44. Useful Resources & Links.html

Useful Resources & Links

Useful Resources:

- Official Docs: [https://ngrx.io](https://ngrx.io/)

### 45. MUST READ The [LEGACY] Lectures.html

With the release of Angular 8, I updated a couple of sections in this course (see "Announcements" part of the course).

This section (about NgRx) was one of the updated sections.

All the lectures marked as "[LEGACY]" in their title are OLD and taking them is not recommended. If you went through the lectures at the beginning of this module (i.e. without "[LEGACY]" in the title), you took the new, updated version of this module already. Ignore the "[LEGACY]" lectures then.

Why do the "[LEGACY]" lectures exist?

I'm keeping them around for students who started this section before I released my update. I'll remove them in the future.

---

Hi Everyone,

a few hours ago **Angular 9** was released.

As you know, a new version of Angular is released (roughly) every 6 months and it **does NOT mean that everything changed** or that you have to learn a new framework. Indeed, Angular 9 does not change anything about the code you write.

I summarized the important changes in this **video** which you might want to check out: https://youtu.be/TcdhAxDWWxM

In addition, the official announcement blog post might be worth reading: https://blog.angular.io/version-9-of-angular-now-available-project-ivy-has-arrived-23c97b63cfa3

To sum it up: Angular 9 is a very important release because it contains a new renderer for Angular - its name is "**Ivy**". Ivy makes Angular **apps smaller and faster** - you don't have to do anything for that. It's a "free win"! :)

BUT: This is a pure **behind-the-scenes change** that does **NOT** affect the code you write or the core concepts of Angular.

My Angular courses are **fully up-to-date** with that new version. Minor adjustments that make sense (e.g. entryComponents is no longer mandatory) will be covered in the lectures where they apply.

I still took this as an opportunity to add a **brand-new section** to my "Angular - The Complete Guide" course. It's not really related to Angular 9 but it is something I felt that was missing => A section where we dive a bit deeper into "**Angular as a Platform**". We'll explore the Angular CLI in greater detail, learn about commands like "ng add" or "ng update" and understand the configuration of an Angular project a bit better. This new section will replace the dated "Custom Setup with Webpack" section (which is really not needed anymore because the CLI is so amazing).

I hope you like this update and the resources linked above. For now, nothing changes in the end - but Angular 9 (because of Ivy) gives us a great improvements "for free" (smaller bundles, faster apps). :)

Have a great time and have fun learning!

## 25. Bonus Angular Universal

### 1. Module Introduction

You could say as you know angular allows you to build front end user interfaces user interfaces that

run in the browser.

Your entire angular app runs in the browser angular universal now allows you to pre render your angular

app on the server.

So it's not a suicide framework like express choice or anything like that.

You won't use it to write server side code but it allows you to on the fly pre render pages your users

visit so that when the users load the page they get that finished Page served back and that initial

rendering doesn't need to happen in the browser and only subsequent actions by the user are then handled

as always in the browser only. Imagine that your users are on slower networks.

In such cases the javascript download might take a time and until the javascript code has been downloaded

your users will see nothing.

Or take search engines a search engine.

So the crawler of that search engine looks at different Web sites to index them and to search engine

only sees what's initially downloaded by the server.

It doesn't necessarily wait for all your scripts to be done with rendering what the user sees.

### Angular Universal & ModuleMapLoader

Angular Universal & ModuleMapLoader

A quick note: In the next lecture, I mention that it's important to add `ModuleMapLoader` to your `app.server.ts` file - if you're using Angular 9, this is NOT required anymore!

### Adding Angular Universal

### Adding Angular Universal with NestJS

### Deploying Universal Apps

### Important: Remaining Lectures

### Module Introduction

### Getting Started with Angular Universal

### Working on the App Module

### Adding a Server-Side Build Workflow

### Adding a NodeJS Server

### Pre-Rendering the App on the Server

### Next Steps

### Angular Universal Gotchas

### 2. Important Official Docs & Starting Project.html

### 3. Getting Started with Angular Universal

### 4. Working on the App Module

### 5. Adding a Server-Side Build Workflow

### 6. Adding a NodeJS Server

### 7. Pre-Rendering the App on the Server

### 8. Next Steps

### 9. Angular Universal Gotchas.html

## 26. Angular Animations

### 1. Making Animations Work with Angular 4+.html

Making Animations Work with Angular 4+

With the release of **Angular 4**, the **general syntax of Angular Animations didn't change**.

However, the animation functions were moved into their own package and you now also need to add a special module to your `imports[]` array in the **AppModule**.

**Specifically, the following adjustments are required:**

- You probably need to install the **new animations package** (running the command never hurts): `npm install --save @angular/animations`
- Add the `BrowserAnimationsModule` to your `imports[]` array in **AppModule**
- This Module needs to be imported from `@angular/platform-browser/animations'` => `import { BrowserAnimationsModule } from '@angular/platform-browser/animations'` (in the **AppModule**!)
- You then import `trigger` , `state` , `style` etc from `@angular/animations` **instead of** `@angular/core`

That's all!

###

### 2. Introduction

### 3. Setting up the Starting Project

### 4. Animations Triggers and State

### 5. Switching between States

### 6. Transitions

### 7. Advanced Transitions

### 8. Transition Phases

### 9. The void State

### 10. Using Keyframes for Animations

### 11. Grouping Transitions

### 12. Using Animation Callbacks

## 27. Adding Offline Capabilities with Service Workers

### 1. Module Introduction

### 2. Adding Service Workers

### 3. Caching Assets for Offline Use

### 4. Caching Dynamic Assets & URLs

### 5. Further Links & Resources.html

## 28. A Basic Introduction to Unit Testing in Angular Apps

### 1. About this Section.html

### 2. Introduction

### 3. Why Unit Tests

### 4. Analyzing the Testing Setup (as created by the CLI)

### 5. Running Tests (with the CLI)

### 6. Adding a Component and some fitting Tests

### 7. Testing Dependencies Components and Services

### 8. Simulating Async Tasks

### 9. Using fakeAsync and tick

### 10. Isolated vs Non-Isolated Tests

### 11. Further Resources & Where to Go Next.html

## 29. Angular Changes & New Features

### 1. What's New with Angular 8

### 2. What's New & How to Update.html

## 30. Course Roundup

### 1. Course Roundup

### 2. Bonus More Content!.html

## 31. Custom Project & Workflow Setup

### 1. Introduction

### 2. Initializing the Project

### 3. Setting up the Basic Project Files

### 4. Installing the Core Dependencies

### 5. Filling the Project Files with Some Life

### 6. index.html & Polyfills

### 6. index.html & Polyfills.vtt

### 7. Installing Development Dependencies

### 8. Setting up a Development Workflow

### 9. Updating to Angular 6 + Webpack 4.html

### 10. Finishing & Using the Development Workflow

### 11. Setting up a Production Workflow

### 12. Adding Types & Fixing Bugs

### 13. Finishing Touches

## 32. Bonus TypeScript Introduction (for Angular 2 Usage)

### 1. Introduction

### 2. Using Types

### 3. Classes

### 4. Interfaces

### 5. Generics

### 6. Wrap up & Modules

### 7. Deep dive into TypeScript.html

Angular nghiep
https://www.youtube.com/watch?v=H6IjqFs6Q9o&list=PLJ5qtRQovuENHYHqlQP5XT7zwbCA5Q5He
